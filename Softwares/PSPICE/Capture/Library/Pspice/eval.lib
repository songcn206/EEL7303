* Sample standard device library
*
*  Copyright OrCAD, Inc. 1998 All Rights Reserved.
*
* $Revision:   1.36  $
* $Author:   drocha  $
* $Date:   17 Feb 1999 09:57:54  $
*
*---------------------------------------------------------------------------
*
* This is a reduced version of OrCAD's standard parts model libraries. Some
* components from several types of component libraries have been included
* here.
*
*
*     The following is a summary of parts in this library:
*
*           Part name           Part type
*           ---------           ---------
*           Q2N2222             NPN bipolar transistor
*           Q2N2907A            PNP bipolar transistor
*           Q2N3904             NPN bipolar transistor
*           Q2N3906             PNP bipolar transistor
*
*           Q2N6052             PNP Darlington power transistor
*           Q2N6059             NPN Darlington power transistor
*
*           CD4016B             Analog Switch
*
*           D1N750              zener diode
*           MV2201              voltage variable capacitance diode
*           D1N4002             power diode
*           D1N4148             switching diode
*           MBD101              switching diode
*		D1N914		  diode
*
*           J2N3819             N-channel Junction field effect transistor
*           J2N4393             N-channel Junction field effect transistor
*
*           IXGH40N60           N-channel Insulated Gate Bipolar Transistor
*
*           LM324               linear operational amplifier
*           LF411               linear operational amplifier
*           UA741               linear operational amplifier
*           LM111               voltage comparator
*
*           K3019PL_3C8         ferroxcube pot magnetic core
*           K502T300_3C8        ferroxcube pot magnetic core
*           K528T500_3C8        ferroxcube pot magnetic core
*           KRM8PL_3C8          ferroxcube pot magnetic core
*
*           IRF150              N-type power MOS field effect transistor
*           IRF9140             P-type power MOS field effect transistor
*
*           PAL20RP4B           Programmable Logic Device
*
*           A4N25               optocoupler
*
*           2N1595              silicon controlled rectifier
*           2N5444              Triac
*
*           555D                555 timer subcircuit
*
*           Sw_tOpen,Sw_tClose  Time Dependent Switch Models
*
*           P/L2C               Coupled, equal, lumped T-section tline
*           P/L2C_A             Coupled, unequal, lumped T-section tline
*           P/LS                Uncoupled (single), lumped tline
*           P/T2C               Coupled, equal, distributed tline
*           P/T2C_A             Coupled,unequal,distributed(asymmetrical) tline
*           P/TS                Uncoupled (single), distributed tline
*		T2COUPLED		  2 symmetric coupled lossy lines
*		T3COUPLED		  3 symmetric coupled lossy lines
*
*           ESC2_B              Pentium Mercury set IBIS I/O model
*
*           54152A              MULTIPLEXER/DATA SELECTOR 8-1 LINE
*           7400                Quadruple 2-input Positive-Nand Gates
*           7401                Quadruple 2-input Positive-Nand Gates with
*                                  Open-Collector Outputs
*           7402                Quadruple 2-input Positive-Nor Gates
*           7403                Quadruple 2-input Positive-Nand Gates with
*                                  Open-Collector Outputs
*           7404                Hex Inverters
*           7405                Hex Inverters with Open-Collector Outputs
*           7406                Hex Inverter Buffers/Drivers with
*                                  Open-Collector High-Voltage Outputs
*           7407                Hex Buffers/Drivers with Open-Collector
*                                  High-Voltage Outputs
*           7408                Quadruple 2-input Positive-And Gates
*           7409                Quadruple 2-input Positive-And Gates with
*                                  Open-Collector Outputs
*           7410                Triple 3-input Positive-Nand Gates
*           74100               8-Bit Bistable Latches
*           74107               Dual J-K Flip-Flops with Clear
*           74109               Dual J-KBar Positive-Edge-Triggered Flip-Flops
*           7411                Triple 3-input Posit ive-And Gates
*           74S11               S-series TTL Triple 3-input Positive-AND gates
*           74110               And-Gated J-K Master-Slave Flip-Flops with Data
*                                  Lockout
*           74111               Dual J-K Master-Slave Flip-Flops with Data
*                                  Lockout
*           7412                Triple 3-input Positive-Nand Gates with
*                                  Open-Collector Outputs
*           74121               Non-retriggerable Monostable Multivibrator
*                                  w/Schmitt-Trigger Inputs
*           74122               Retriggerable Monostable Multivibrator
*           74123               Retriggerable Monostable Multivibrator
*           74125               Quadruple Bus Buffer with 3-state Outputs
*           74126               Quadruple Bus Buffer with 3-state Outputs
*           74128               Line Drivers
*           7413                Dual 4-input Positive-Nand Schmitt Triggers
*           74132               Quadruple 2-input Positive-Nand Schmitt Trigger
*           74136               Quadruple 2-input Exclusive-Or Gates with
*                                  Open-Collector Outputs
*           7414                Hex Schmitt-Trigger Inverters
*           74147               PRIORITY ENCODER 10-4 LINE
*           74148               PRIORITY ENCODER 8-3 LINE
*           74151A              MULTIPLEXER/DATA SELECTOR 8-1 LINE
*           74153               DUAL 4-LINE TO 1-LINE DATA
*                                 SELECTORS/MULTIPLEXERS
*           74154               DECODER/DEMULTIPLEXER 4-16 LINE
*           74155               DECODER/DEMULTIPLEXER 2-4 LINE
*           74156               DECODER/DEMULTIPLEXER 2-4 LINE WITH
*                                 OPEN COLLECTOR OUTPUTS
*           74157               QUADRUPLE 2-LINE TO 1-LINE DATA
*                                 SELECTORS/MULTIPLEXERS
*           74159               DECODER/DEMULTIPLEXER 4-16 LINE WITH
*                                 OPEN-COLLECTOR OUTPUTS
*           7416                Hex Inverter Buffers/Drivers with
*                                 Open-Collector High-Voltage Outputs
*           74160               Synchronous 4-bit Decade Counters with
*                                 asynchronous clear
*           74161               Synchronous 4-bit Binary Counter with Direct
*                                 Clear
*           74162               Synchronous 4-bit Decade Counters with
*                                 synchronous clear
*           74163               Synchronous 4-bit Binary Counter
*           74164               8-BIT PARALLEL-OUT SERIAL SHIFT REGISTERS
*           7417                Hex Buffers/Drivers with Open-Collector
*                                 High-Voltage Outputs
*           74173               REGISTERS D-TYPE 4-BIT WITH 3-STATE OUTPUTS
*           74174               HEX D-TYPE FLIP-FLOPS WITH CLEAR
*           74175               QUADRUPLE D-TYPE FLIP-FLOPS WITH CLEAR
*           74176               35MHz Presettable Decade and Binary
*                                 Counter/Latch
*           74177               35MHz Presettable Decade and Binary
*                                  Counter/Latch
*           74178               4-BIT PARALLEL-ACCESS SHIFT REGISTER
*           74179               4-BIT PARALLEL-ACCESS SHIFT REGISTER
*           74180               PARITY GENERATOR/CHECKER ODD/EVEN 9-BIT
*           74181               ALU / FUNCTION GENERATOR
*           74182               LOOK-AHEAD CARRY GENERATOR
*           74184               BCD-TO-BINARY CONVERTERS
*           74185A              BINARY-TO-BCD CONVERTERS
*           74194               4-BIT BIDIRECTIONAL UNIVERSAL SHIFT REGISTERS
*           74195               4-BIT PARALLEL-ACCESS SHIFT REGISTERS
*           74196               4-Bit Presettable Decade Counter/Latch
*           74197               4-Bit Presettable Binary Counter/Latch
*           7420                Dual 4-input Positive-Nand Gates
*           7422                Dual 4-input Positive-Nand Gates with
*                                 Open-Collector Outputs
*           7423                Dual 4-input Nor Gates with Strobe
*           74246               DECODER/DRIVER BCD-7 SEGMENT WITH
*                                 OPEN-COLLECTOR OUTPUTS
*           74248               DECODER/DRIVER BCD-7 SEGMENT WITH INTERNAL
*                                 PULLUPS
*           74249               DECODER/DRIVER BCD-7 SEGMENT WITH
*                                 OPEN-COLLECTOR OUTPUTS
*           7425                Dual 4-input Nor Gates with Strobe
*           74251               MULTIPLEXER/DATA SELECTOR 8-1 LINE WITH
*                                 3-STATE OUTPUTS
*           74259               8-BIT ADDRESSABLE LATCHES
*           7426                High-Voltage Interface Positive-Nand Gates
*           74265               QUAD. COMPLEMENTARY-OUTPUT ELEMENTS
*           7427                Triple 3-input Positive-Nor Gates
*           74273               OCTAL D-TYPE EDGE-TRIGGERED FLIP-FLOPS WITH
*                                 CLEAR
*           74276               QUADRUPLE J-K FLIP-FLOPS
*           74278               PRIORITY REGISTERS 4-BIT CASCADABLE
*           74279               QUADRUPLE SBAR-RBAR LATCHES
*           7428                Quadruple 2-input Positive-Nor Buffers
*           74283               4-BIT BINARY FULL ADDERS WITH FAST CARRY
*           74290               COUNTER DECADE 4-BIT, ASYNCHRONOUS
*           74293               COUNTER BINARY 4-BIT, ASYNCHRONOUS
*           74298               MULTIPLEXERS QUAD 2-INPUT WITH STORAGE
*           7430                8-input Positive-Nand Gates
*           7432                Quadruple 2-input Positive-Or Gates
*           7433                Quadruple 2-input Positive-Nor Buffers
*                                 w/ Open-Collector Outputs
*           74351               DUAL DATA SELECTOR/MULTIPLEXER WITH 3-STATE
*                                 OUTPUTS
*           74365A              Hex Bus Drivers with 3-STATE Outputs
*           74366A              Hex Bus Drivers with 3-STATE Outputs
*           74367A              Hex Bus Drivers with 3-STATE Outputs
*           74368A              Hex Bus Drivers with 3-STATE Outputs
*           7437                Quadruple 2-input Positive-Nand Buffers
*           74376               Quadruple J-K Flip-Flops
*           7438                Quadruple 2-input Positive-Nand Buffers
*                                 w/ Open-Collector Outputs
*           7439                Quadruple 2-input Positive Nand Buffers with
*                                 Open-Collector Outputs
*           74390               COUNTER DECADE 4-BIT, ASYNCHRONOUS
*           74393               COUNTER BINARY 4-BIT, ASYNCHRONOUS
*           7440                Dual 4-input Positive-Nand Buffers
*           74425               Quadruple Bus Buffers with 3-STATE Outputs
*           74426               Quadruple Bus Buffers with 3-STATE Outputs
*           7442A               DECODER BCD-DECIMAL 4-10 LINE
*           7443A               DECODER EXCESS-3-DECIMAL 4-10 LINE
*           7444A               DECODER GRAY-DECIMAL 4-10 LINE
*           7445                DECODER/DRIVER BCD-DECIMAL WITH OPEN COLLECTOR
*                                 OUTPUTS
*           7446A               DECODER/DRIVER BCD-7 SEGMENT WITH
*                                 OPEN-COLLECTOR OUTPUTS
*           7448                DECODER/DRIVER BCD-7 SEGMENT WITH INTERNAL
*                                 PULLUPS
*           7449                DECODER/DRIVER BCD-7 SEGMENT WITH
*                                 OPEN-COLLECTOR OUTPUTS
*           74490               COUNTER DECADE 4-BIT, ASYNCHRONOUS
*           7450                Dual 2-wide 2-input And-Or-Invert Gates
*           7451                And-Or-Invert Gates
*           7453                Expandable 4-wide And-Or-Invert Gates
*           7454                4-wide And-Or-Invert Gates
*           7460                Dual 4-input Expanders
*           7470                And-Gated J-K Positive-Edge-Triggered
*                                 Flip-Flops with Preset & Clear
*           7472                And Gated J-K Master-Slave
*                                 Flip-Flops with Preset and Clear
*           7473                Dual J-K Flip-Flops with Clear
*           7474                Dual D-Type Positive-Edge-Triggered
*                                 Flip-Flops with Preset and Clear
*           7475                4-bit bistable latches (dual 2-bit common
*                                 clock4-bit bistable latches )
*           7476                Dual J-K Flip-Flops with Preset and Clear
*           7477                4-bit bistable latches
*           7482                2-BIT BINARY FULL ADDERS
*           7483A               4-BIT BINARY FULL ADDERS WITH FAST CARRY
*           7485                4-BIT MAGNITUDE COMPARATOR
*           7486                Quadruple 2-input Exclusive-Or Gates
*           7491A               8-BIT SHIFT REGISTERS
*           7492A               COUNTER DIVIDE-BY-12 4-BIT, ASYNCHRONOUS
*           7493A               COUNTER BINARY 4-BIT, ASYNCHRONOUS
*           7494                4-BIT SHIFT REGISTERS
*           7495A               4-BIT PARALLEL SHIFT REGISTERS
*           7496                8-BIT PARALLEL-OUT SERIAL SHIFT REGISTERS
*
*------------------------------------------------------------------
* Library of bipolar transistor model parameters
*
* This is a reduced version of OrCAD's bipolar transistor model library.
* You are welcome to make as many copies of it as you find convenient.
*
* The parameters in this model library were derived from the data sheets for
* each part.  Each part was characterized using the Parts option.
* Devices can also be characterized without Parts as follows:
*
*	NE, NC		Normally set to 4
*	BF, ISE, IKF	These are adjusted to give the nominal beta vs.
*			collector current curve.  BF controls the mid-
*			range beta.  ISE/IS controls the low-current
*			roll-off.  IKF controls the high-current rolloff.
*	ISC		Set to ISE.
*	IS, RB, RE, RC	These are adjusted to give the nominal VBE vs.
*			IC and VCE vs. IC curves in saturation.  IS
*			controls the low-current value of VBE.  RB+RE
*			controls the rise of VBE with IC.  RE+RC controls
*			the rise of VCE with IC.  RC is normally set to 0.
*	VAF		Using the voltages specified on the data sheet
*			VAF is set to give the nominal output impedance
*			(RO on the .OP printout) on the data sheet.
*	CJC, CJE	Using the voltages specified on the data sheet
*			CJC and CJE are set to give the nominal input
*			and output capacitances (CPI and CMU on the .OP
*			printout; Cibo and Cobo on the data sheet).
*	TF		Using the voltages and currents specified on the
*			data sheet for FT, TF is adjusted to produce the
*			nominal value of FT on the .OP printout.
*	TR		Using the rise and fall time circuits on the
*			data sheet, TR (and if necessary TF) are adjusted
*			to give a transient analysis which shows the
*			nominal values of the turn-on delay, rise time,
*			storage time, and fall time.
*	KF, AF		These parameters are only set if the data sheet has
*			a spec for noise.  Then, AF is set to 1 and KF
*			is set to produce a total noise at the collector
*			which is greater than the generator noise at the
*			collector by the rated number of decibels.
*
*$
.model Q2N2222  NPN(Is=14.34f Xti=3 Eg=1.11 Vaf=74.03 Bf=255.9 Ne=1.307
+		Ise=14.34f Ikf=.2847 Xtb=1.5 Br=6.092 Nc=2 Isc=0 Ikr=0 Rc=1
+		Cjc=7.306p Mjc=.3416 Vjc=.75 Fc=.5 Cje=22.01p Mje=.377 Vje=.75
+		Tr=46.91n Tf=411.1p Itf=.6 Vtf=1.7 Xtf=3 Rb=10)
*		National	pid=19		case=TO18
*		88-09-07 bam	creation
*$
.model Q2N2907A PNP(Is=650.6E-18 Xti=3 Eg=1.11 Vaf=115.7 Bf=231.7 Ne=1.829
+		Ise=54.81f Ikf=1.079 Xtb=1.5 Br=3.563 Nc=2 Isc=0 Ikr=0 Rc=.715
+		Cjc=14.76p Mjc=.5383 Vjc=.75 Fc=.5 Cje=19.82p Mje=.3357 Vje=.75
+		Tr=111.3n Tf=603.7p Itf=.65 Vtf=5 Xtf=1.7 Rb=10)
*		National	pid=63		case=TO18
*		88-09-09 bam	creation
*$
.model Q2N3904	NPN(Is=6.734f Xti=3 Eg=1.11 Vaf=74.03 Bf=416.4 Ne=1.259
+		Ise=6.734f Ikf=66.78m Xtb=1.5 Br=.7371 Nc=2 Isc=0 Ikr=0 Rc=1
+		Cjc=3.638p Mjc=.3085 Vjc=.75 Fc=.5 Cje=4.493p Mje=.2593 Vje=.75
+		Tr=239.5n Tf=301.2p Itf=.4 Vtf=4 Xtf=2 Rb=10)
*		National	pid=23		case=TO92
*		88-09-08 bam	creation
*$
.model Q2N3906	PNP(Is=1.41f Xti=3 Eg=1.11 Vaf=18.7 Bf=180.7 Ne=1.5 Ise=0
+		Ikf=80m Xtb=1.5 Br=4.977 Nc=2 Isc=0 Ikr=0 Rc=2.5 Cjc=9.728p
+		Mjc=.5776 Vjc=.75 Fc=.5 Cje=8.063p Mje=.3677 Vje=.75 Tr=33.42n
+		Tf=179.3p Itf=.4 Vtf=4 Xtf=6 Rb=10)
*		National	pid=66		case=TO92
*		88-09-09 bam	creation
*$
*-------------------------------------------------------------------------------
* Darlington power transistors
*
*
* Motorola 100 Volt 12 Amp Darlington Transistor  07/20/98
*
* connections:    Collector
*                 |  Base
*                 |  |  Emitter
*                 |  |  |
.SUBCKT Q2N6052   1  2  3
*
Q1 1 2 4 Q1model
Q2 1 4 3 Q2model .99
D1 1 3 Dmodel
R1 2 4 5.000E3
R2 4 3 50
.MODEL Dmodel D
+ IS=5.3253E-12
+ N=3.4748
+ RS=1.0000E-3
+ CJO=1.0000E-12
+ M=.3333
+ VJ=.75
+ ISR=100.00E-12
+ BV=120
+ IBV=1.00E-6
+ TT=5.0000E-9
.MODEL Q1model PNP
+  IS=1.500E-12 BF=2.997E3 NF=1 VAF=100
+  IKF=.263 ISE=6.747E-12 NE=1.413 BR=499.5
+  NR=1 VAR=100 IKR=19.98 ISC=19.59E-12
+  NC=2.997 RB=1.0845 NK=.5779
+  RE=0 RC=0.196311 EG=1.110
+  CJE=316.6E-12 VJE=.436 MJE=.2878 TF=9.781E-9
+  XTF=1 VTF=10 ITF=10.00E-3 CJC=372.5E-12
+  VJC=1.177 MJC=.2738 XCJC=.9 FC=.5
+  TR=7.561E-9
.MODEL Q2model PNP
+  IS=1.500E-12 BF=2.997E3 NF=1 VAF=100
+  IKF=.263 ISE=6.747E-12 NE=1.413 BR=499.5
+  NR=1 VAR=100 IKR=19.98 ISC=19.59E-12
+  NC=2.997 RB=1.0845 NK=.5779
+  RE=0 RC=0.196311 EG=1.110
+  CJE=316.6E-12 VJE=.436 MJE=.2878 TF=9.781E-9
+  XTF=1 VTF=10 ITF=10.00E-3 CJC=0
+  VJC=1.177 MJC=.2738 XCJC=.9 FC=.5
+  TR=7.561E-9
.ENDS
*$
* Motorola 100 Volt 12 Amp Darlington Transistor  07/20/98

*
* connections:    Collector
*                 |  Base
*                 |  |  Emitter
*                 |  |  |
.SUBCKT Q2N6059   1  2  3
*
Q1 1 2 4 Q1model
Q2 1 4 3 Q2model .9912
D1 3 1 Dmodel
R1 2 4 5.000E3
R2 4 3 50
.MODEL Dmodel D
+ IS=5.3253E-12
+ N=3.4748
+ RS=1.0000E-3
+ CJO=1.0000E-12
+ M=.3333
+ VJ=.75
+ ISR=100.00E-12
+ BV=120
+ IBV=1.00E-6
+ TT=5.0000E-9
.MODEL Q1model NPN
+  IS=1.501E-12 BF=772.1 NF=1 VAF=100
+  IKF=.1298 ISE=163.8E-12 NE=1.998 BR=499.5
+  NR=1 VAR=100 IKR=19.98 ISC=1.536E-12
+  NC=2.997 RB=1.101 NK=.5077
+  RE=0 RC=.1498 EG=1.110
+  CJE=316.6E-12 VJE=.436 MJE=.2878 TF=16.416E-9
+  XTF=1 VTF=10 ITF=10.00E-3 CJC=189.3E-12
+  VJC=.6244 MJC=.1866 XCJC=.9 FC=.5
+  TR=13.837E-9
.MODEL Q2model NPN
+  IS=1.501E-12 BF=772.1 NF=1 VAF=100
+  IKF=.1298 ISE=163.8E-12 NE=1.998 BR=499.5
+  NR=1 VAR=100 IKR=19.98 ISC=1.536E-12
+  NC=2.997 RB=1.101 NK=.5077
+  RE=0 RC=.1498 EG=1.110
+  CJE=316.6E-12 VJE=.436 MJE=.2878 TF=16.416E-9
+  XTF=1 VTF=10 ITF=10.00E-3 CJC=0
+  VJC=.6244 MJC=.1866 XCJC=.9 FC=.5
+  TR=13.837E-9
.ENDS
*$
*-------------------------------------------------------------------------------
* Library of diode model parameters
*
* This is a reduced version of OrCAD's diode model library.
* You are welcome to make as many copies of it as you find convenient.
*
* The parameters in this model library were derived from the data sheets for
* each part.  Most parts were characterized using the Parts option.
* Devices can also be characterized without Parts as follows:
*	IS		nominal leakage current
*	RS		for zener diodes: nominal small-signal impedance
*			at specified operating current
*	IB		for zener diodes: set to nominal leakage current
*	IBV		for zener diodes: at specified operating current
*			IBV is adjusted to give the rated zener voltage
*
*
*** Zener Diodes ***
*
* "A" suffix zeners have the same parameters (e.g., 1N750A has the same
* parameters as 1N750)
*
*
.model D1N750	D(Is=880.5E-18 Rs=.25 Ikf=0 N=1 Xti=3 Eg=1.11 Cjo=175p M=.5516
+		Vj=.75 Fc=.5 Isr=1.859n Nr=2 Bv=4.7 Ibv=20.245m Nbv=1.6989
+		Ibvl=1.9556m Nbvl=14.976 Tbv1=-21.277u)
*		Motorola	pid=1N750	case=DO-35
*		89-9-18 gjg
*		Vz = 4.7 @ 20mA, Zz = 300 @ 1mA, Zz = 12.5 @ 5mA, Zz =2.6  @ 20mA

*$
*** Voltage-variable capacitance diodes

* The parameters in this model library were derived from the data sheets for
* each part.  Each part was characterized using the Parts option.
*
.model MV2201   D(Is=1.365p Rs=1 Ikf=0 N=1 Xti=3 Eg=1.11 Cjo=14.93p M=.4261
+		Vj=.75 Fc=.5 Isr=16.02p Nr=2 Bv=25 Ibv=10u)
*		Motorola	pid=MV2201	case=182-03
*		88-09-22 bam	creation
*** Switching Diodes ***
*$
.model D1N4148  D(Is=2.682n N=1.836 Rs=.5664 Ikf=44.17m Xti=3 Eg=1.11 Cjo=4p
+               M=.3333 Vj=.5 Fc=.5 Isr=1.565n Nr=2 Bv=100 Ibv=100u Tt=11.54n)
*$
.model MBD101   D(Is=192.1p Rs=.1 Ikf=0 N=1 Xti=3 Eg=1.11 Cjo=893.8f M=98.29m
+		Vj=.75 Fc=.5 Isr=16.91n Nr=2 Bv=5 Ibv=10u)
*		Motorola	pid=MBD101	case=182-03
*		88-09-22 bam	creation
*$
*** Power Diode ***
.MODEL D1N4002 D (IS=14.11E-9  N=1.984  RS=33.89E-3  IKF=94.81  XTI=3
+ EG=1.110  CJO=51.17E-12  M=.2762  VJ=.3905  FC=.5  ISR=100.0E-12
+ NR=2  BV=100.1  IBV=10  TT=4.761E-6)
*$
*** General Purpose Fast Rectifier ***
.model D1N914   D(Is=168.1E-21 N=1 Rs=.1 Ikf=0 Xti=3 Eg=1.11 Cjo=4p M=.3333
+               Vj=.75 Fc=.5 Isr=100p Nr=2 Bv=100 Ibv=100u Tt=11.54n)
*$
*-------------------------------------------------------------------------------
* Library of junction field-effect transistor (JFET) model parameters

* This is a reduced version of OrCAD's JFET model library.
* You are welcome to make as many copies of it as you find convenient.

* The parameters in this model library were derived from the data sheets for
* each part.  Each part was characterized using the Parts option.
*
.model J2N3819	NJF(Beta=1.304m Betatce=-.5 Rd=1 Rs=1 Lambda=2.25m Vto=-3
+		Vtotc=-2.5m Is=33.57f Isr=322.4f N=1 Nr=2 Xti=3 Alpha=311.7u
+		Vk=243.6 Cgd=1.6p M=.3622 Pb=1 Fc=.5 Cgs=2.414p Kf=9.882E-18
+		Af=1)
*		National	pid=50		case=TO92
*		88-08-01 rmn	BVmin=25
*$
.model J2N4393	NJF(Beta=9.109m Betatce=-.5 Rd=1 Rs=1 Lambda=6m Vto=-1.422
+		Vtotc=-2.5m Is=205.2f Isr=1.988p N=1 Nr=2 Xti=3 Alpha=20.98u
+		Vk=123.7 Cgd=4.57p M=.4069 Pb=1 Fc=.5 Cgs=4.06p Kf=123E-18
+		Af=1)
*		National	pid=51		case=TO18
*		88-07-13 bam	BVmin=40
*$
*-------------------------------------------------------------------------------
* Library of insulated gate bipolar transistor (IGBT) model parameters 
*
* The parameters in this model library were derived from data sheets.  
*This part was characterized using the Parts program and the Optimizer program.
*
* created using Parts release 6.3 on 12/18/95 at 16:20
.MODEL IXGH40N60 NIGBT
+ TAU=287.56E-9
+ KP=50.034
+ AREA=37.500E-6
+ AGD=18.750E-6
+ VT=4.1822
+ KF=.36047
+ CGS=31.942E-9
+ COXD=53.188E-9
+ VTD=2.6570
*$
*-------------------------------------------------------------------------------
* Library of linear IC definitions

* This is a reduced version of OrCAD's linear subcircuit library.
* You are welcome to make as many copies of it as you find convenient.
*
* The parameters in the opamp library were derived from the data sheets for
* each part.  The macromodel used is similar to the one described in:
*
*	Macromodeling of Integrated Circuit Operational Amplifiers
*	  by Graeme Boyle, Barry Cohn, Donald Pederson, and James Solomon
*	IEEE Journal of SoliE-State Circuits, Vol. SC-9, no. 6,	Dec. 1974
*
* Differences from the reference (above) occur in the output limiting stage
* which was modified to reduce internally generated currents associated with
* output voltage limiting, as well as short-circuit current limiting.
*
* The opamps are modelled at room temperature and do not track changes with
* temperature.  This library file contains models for nominal, not worst case,
* devices.
*
*
*-----------------------------------------------------------------------------
* connections:   non-inverting input
*                | inverting input
*                | | positive power supply
*                | | | negative power supply
*                | | | | output
*                | | | | |
.subckt LM324    1 2 3 4 5
*
  c1   11 12 2.887E-12
  c2    6  7 30.00E-12
  dc    5 53 dx
  de   54  5 dx
  dlp  90 91 dx
  dln  92 90 dx
  dp    4  3 dx
  egnd 99  0 poly(2) (3,0) (4,0) 0 .5 .5
  fb    7 99 poly(5) vb vc ve vlp vln 0 21.22E6 -20E6 20E6 20E6 -20E6
  ga    6  0 11 12 188.5E-6
  gcm   0  6 10 99 59.61E-9
  iee   3 10 dc 15.09E-6
  hlim 90  0 vlim 1K
  q1   11  2 13 qx
  q2   12  1 14 qx
  r2    6  9 100.0E3
  rc1   4 11 5.305E3
  rc2   4 12 5.305E3
  re1  13 10 1.845E3
  re2  14 10 1.845E3
  ree  10 99 13.25E6
  ro1   8  5 50
  ro2   7 99 25
  rp    3  4 9.082E3
  vb    9  0 dc 0
  vc    3 53 dc 1.500
  ve   54  4 dc 0.65
  vlim  7  8 dc 0
  vlp  91  0 dc 40
  vln   0 92 dc 40
.model dx D(Is=800.0E-18 Rs=1)
.model qx PNP(Is=800.0E-18 Bf=166.7)
.ends
*$
*-----------------------------------------------------------------------------
* connections:   non-inverting input
*                |  inverting input
*                |  |  positive power supply
*                |  |  |  negative power supply
*                |  |  |  |  output
*                |  |  |  |  |
.subckt uA741    1 2 3 4 5
*
  c1   11 12 8.661E-12
  c2    6  7 30.00E-12
  dc    5 53 dx
  de   54  5 dx
  dlp  90 91 dx
  dln  92 90 dx
  dp    4  3 dx
  egnd 99  0 poly(2) (3,0) (4,0) 0 .5 .5
  fb    7 99 poly(5) vb vc ve vlp vln 0 10.61E6 -10E6 10E6 10E6 -10E6
  ga    6  0 11 12 188.5E-6
  gcm   0  6 10 99 5.961E-9
  iee  10  4 dc 15.16E-6
  hlim 90  0 vlim 1K
  q1   11  2 13 qx
  q2   12  1 14 qx
  r2    6  9 100.0E3
  rc1   3 11 5.305E3
  rc2   3 12 5.305E3
  re1  13 10 1.836E3
  re2  14 10 1.836E3
  ree  10 99 13.19E6
  ro1   8  5 50
  ro2   7 99 100
  rp    3  4 18.16E3
  vb    9  0 dc 0
  vc    3 53 dc 1
  ve   54  4 dc 1
  vlim  7  8 dc 0
  vlp  91  0 dc 40
  vln   0 92 dc 40
.model dx D(Is=800.0E-18 Rs=1)
.model qx NPN(Is=800.0E-18 Bf=93.75)
.ends
*$
*-----------------------------------------------------------------------------
* connections:   non-inverting input
*                |  inverting input
*                |  |  positive power supply
*                |  |  |  negative power supply
*                |  |  |  |  output
*                |  |  |  |  |
.subckt LF411    1  2  3  4  5
*
  c1   11 12 4.196E-12
  c2    6  7 10.00E-12
  css  10 99 1.333E-12
  dc    5 53 dx
  de   54  5 dx
  dlp  90 91 dx
  dln  92 90 dx
  dp    4  3 dx
  egnd 99  0 poly(2) (3,0) (4,0) 0 .5 .5
  fb    7 99 poly(5) vb vc ve vlp vln 0 31.83E6 -30E6 30E6 30E6 -30E6
  ga    6  0 11 12 251.4E-6
  gcm   0  6 10 99 2.514E-9
  iss  10  4 dc 170.0E-6
  hlim 90  0 vlim 1K
  j1   11  2 10 jx
  j2   12  1 10 jx
  r2    6  9 100.0E3
  rd1   3 11 3.978E3
  rd2   3 12 3.978E3
  ro1   8  5 50
  ro2   7 99 25
  rp    3  4 15.00E3
  rss  10 99 1.176E6
  vb    9  0 dc 0
  vc    3 53 dc 1.500
  ve   54  4 dc 1.500
  vlim  7  8 dc 0
  vlp  91  0 dc 25
  vln   0 92 dc 25
.model dx D(Is=800.0E-18 Rs=1m)
.model jx NJF(Is=12.50E-12 Beta=743.3E-6 Vto=-1)
.ends
*$
*-----------------------------------------------------------------------------

*** Voltage comparators

*  Copyright OrCAD, Inc. 1998 All Rights Reserved.
*
* The parameters in this comparator library were derived from data sheets for
* each parts.  The macromodel was produced by the "Parts" option to PSpice.
*
* Although we do not use it, another comparator macro model is described in:
*
*	An Integrated-Circuit Comparator Macromodel
*	  by Ian Getreu, Andreas Hadiwidjaja, and Johan Brinch
*	IEEE Journal of Solid-State Circuits, Vol. SC-11, no. 6, Dec. 1976
*
* This reference covers the considerations that go into duplicating the
* behavior of voltage comparators.
*
* The comparators are modelled at room temperature.  The macro model does not
* track changes with temperature.  This library file contains models for
* nominal, not worst case, devices.
*
*
*-----------------------------------------------------------------------------
* connections:   non-inverting input
*                |  inverting input
*                |  |  positive power supply
*                |  |  |  negative power supply
*                |  |  |  |  open collector output
*                |  |  |  |  |  output ground
*                |  |  |  |  |  |
.subckt LM111    1  2  3  4  5  6
*
  f1    9  3 v1 1
  iee   3  7 dc 100.0E-6
  vi1  21  1 dc .45
  vi2  22  2 dc .45
  q1    9 21  7 qin
  q2    8 22  7 qin
  q3    9  8  4 qmo
  q4    8  8  4 qmi
.model qin PNP(Is=800.0E-18 Bf=833.3)
.model qmi NPN(Is=800.0E-18 Bf=1002)
.model qmo NPN(Is=800.0E-18 Bf=1000 Cjc=1E-15 Tr=118.8E-9)
  e1   10  6  9  4  1
  v1   10 11 dc 0
  q5    5 11  6 qoc
.model qoc NPN(Is=800.0E-18 Bf=34.49E3 Cjc=1E-15 Tf=364.6E-12 Tr=79.34E-9)
  dp    4  3 dx
  rp    3  4 6.122E3
.model dx  D(Is=800.0E-18 Rs=1)
*
.ends
*$
*-------------------------------------------------------------------------------
* Library of magnetic core model parameters

* This is a reduced version of OrCAD's magnetic core library.
* You are welcome to make as many copies of it as you find convenient.

* The parameters in this model library were derived from the data sheets for
* each core.  The Jiles-Atherton magnetics model is described in:
*
*   Theory of Ferromagnetic Hysteresis, by D C Jiles and D L Atherton,
*   Journal of Magnetism and Magnetic Materials, vol 61 (1986) pp 48-60
*
* Model parameters for ferrite material (Ferroxcube 3C8) were obtained by
* trial simulations, using the B-H curves from the manufacturer's catalog.
* Then, the library was compiled from the data sheets for each core geometry.
* Notice that only the geometric values change once a material is
* characterized.

* Example use:  K2 L2 .99 K1409PL_3C8

* Notes:
*   1) Using a K device (formerly only for mutual coupling) with a model
*      reference changes the meaning of the L device: the inductance value
*      becomes the number of turns for the winding.
*   2) K devices can "get away" with specifying only one inductor, as in the
*      example above, to simulate power inductors.

* Example circuit file:

*+-----------------------------------------------------------------------------
*|Demonstration of power inductor B-H curve
*|
*|* To view results with Probe (B-H curve):
*|* 1) Add Trace for B(K1)
*|* 2) set X-axis variable to H(K1)
*|*
*|* Probe x-axis unit is Oersted
*|* Probe y-axis unit is Gauss
*|*
*|.tran .1 4
*|igen0 0 1 sin(0 .1amp 1Hz 0)	; Generator: starts with 0.1 amp sinewave, then
*|igen1 0 1 sin(0 .1amp 1Hz 1)	;   +0.1 amps, starting at 1 second
*|igen2 0 1 sin(0 .2amp 1Hz 2)	;   +0.2 amps, starting at 2 seconds
*|igen3 0 1 sin(0 .8amp 1Hz 3)	;   +0.4 amps, starting at 3 seconds
*|RL 1 0 1ohm			; generator source resistance
*|L1 1 0 20			; inductor with 20 turns
*|K1 L1 .9999 K528T500_3C8	; Ferroxcube torroid core
*|.model K528T500_3C8	CORE(Ms=415.2K A=44.82 C=.4112 K=25.74)
*|+			AREA=1.17 PATH=8.49)
*|.options itl5=0
*|.probe
*|.end
*+-----------------------------------------------------------------------------

*** Ferroxcube pot cores: 3C8 material
*
.model K3019PL_3C8	Core(MS=415.2K A=44.82 C=.4112 K=25.74
+			Area=1.38 Path=4.52)
*$

*** Ferroxcube square cores: 3C8 material
*
.model KRM8PL_3C8    Core(MS=415.2K A=44.82 C=.4112 K=25.74
+			Area=.630 Path=3.84)
*$

*** Ferroxcube toroid cores: 3C8 material
*
.model K502T300_3C8	Core(MS=415.2K A=44.82 C=.4112 K=25.74
+			Area=.371 Path=7.32)
*$

.model K528T500_3C8	Core(MS=415.2K A=44.82 C=.4112 K=25.74
+		   Area=1.17 Path=8.49)
*$
*-------------------------------------------------------------------------------
* Library of MOSFET model parameters (for "power" MOSFET devices)
*
* This is a reduced version of OrCAD's power MOSFET model library.
*   You are welcome to make as many copies of it as you find convenient.
*
* The parameters in this model library were derived from the data sheets for
* each part.  Each part was characterized using the Parts option.
* Device can also be characterized without Parts as follows:
*	LEVEL		Set to 3 (short-channel device).
*	TOX		Determined from gate ratings.
*	L, LD, W, WD	Assume L=2u.  Calculate from input capacitance.
*	XJ, NSUB	Assume usual technology.
*	IS, RD, RB	Determined from "source-drain diode forward voltage"
*			specification or curve (Idr vs. Vsd).
*	RS		Determine from Rds(on) specification.
*	RDS		Calculated from Idss specification or curves.
*	VTO, UO, THETA	Determined from "output characteristics" curve family
*			(Ids vs. Vds, stepped Vgs).
*	ETA, VMAX, CBS	Set for null effect.
*	CBD, PB, MJ	Determined from "capacitance vs. Vds" curves.
*	RG		Calculate from rise/fall time specification or curves.
*	CGSO, CGDO	Determined from gate-charge, turn-on/off delay and
*			rise time specifications.
*
* NOTE:	when specifying the instance of a device in your circuit file:
*
*	BE SURE to have the source and bulk nodes connected together, as this
*	is the way the real device is constructed.
*
*	DO NOT include values for L, W, AD, AS, PD, PS, NRD, or NDS.
*	The PSpice default values for these parameters are taken into account
*	in the library model statements.  Of course, you should NOT reset
*	the default values using the .OPTIONS statement, either.
*
* Example use:	M17	15 23 7 7	IRF150
*
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
* The "power" MOSFET device models benefit from relatively complete specifi-
* cation of static and dynamic characteristics by their manufacturers.  The
* following effects are modeled:
*	- DC transfer curves in forward operation,
*	- gate drive characteristics and switching delay,
*	- "on" resistance,
*	- reverse-mode "body-diode" operation.
*
* The factors not modeled include:
*	- maximum ratings (eg. high-voltage breakdown),
*	- safe operating area (eg. power dissipation),
*	- latch-up,
*	- noise.
*
* For high-current switching applications, we advise that you include
* series inductance elements, for the source and drain, in your circuit file.
* In doing so, voltage spikes due to di/dt will be modeled.  According to the
* 1985 International Rectifier databook, the following case styles have lead
* inductance values of:
*	TO-204 (modified TO-3)	source = 12.5nH		drain = 5.0nH
*	TO-220			source =  7.5nH		drain = 3.5-4.5nH
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*
.model IRF150	NMOS(Level=3 Gamma=0 Delta=0 Eta=0 Theta=0 Kappa=0 Vmax=0 Xj=0
+		Tox=100n Uo=600 Phi=.6 Rs=1.624m Kp=20.53u W=.3 L=2u Vto=2.831
+	        Rd=1.031m Rds=444.4K Cbd=3.229n Pb=.8 Mj=.5 Fc=.5 Cgso=9.027n
+		Cgdo=1.679n Rg=13.89 Is=194E-18 N=1 Tt=288n)
*		Int'l Rectifier	pid=IRFC150	case=TO3
*		88-08-25 bam	creation
*$
.model IRF9140	PMOS(Level=3 Gamma=0 Delta=0 Eta=0 Theta=0 Kappa=0 Vmax=0 Xj=0
+		Tox=100n Uo=300 Phi=.6 Rs=70.6m Kp=10.15u W=1.9 L=2u Vto=-3.67
+		Rd=60.66m Rds=444.4K Cbd=2.141n Pb=.8 Mj=.5 Fc=.5 Cgso=877.2p
+		Cgdo=369.3p Rg=.811 Is=52.23E-18 N=2 Tt=140n)
*		Int'l Rectifier  pid=IRFC9140	case=TO3
*		88-08-25 bam	creation
*$
*--------------------------------------------------------------------
* Digital Components
*
*-------------------------------------------------------------------------
*
* 7400  Quadruple 2-input Positive-Nand Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn   06/23/89	Update interface and model names

.subckt 7400  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y
+	D_00 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_00 ugate (
+	tplhty=11ns	tplhmx=22ns
+	tphlty=7ns	tphlmx=15ns
+	)
*---------
*$
* 7401  Quadruple 2-input Positive-Nand Gates with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn 	06/23/89	Update interface and model names

.subckt 7401  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y
+	D_01 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_01 ugate (
+	tplhty=35ns	tplhmx=55ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7402  Quadruple 2-input Positive-Nor Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7402  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y
+	D_02 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_02 ugate (
+	tplhty=12ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7403  Quadruple 2-input Positive-Nand Gates with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7403  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y
+	D_03 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_03 ugate (
+	tplhty=35ns	tplhmx=45ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7404  Hex Inverters
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7404  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y
+	D_04 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_04 ugate (
+	tplhty=12ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7405  Hex Inverters with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7405  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y
+	D_05 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_05 ugate (
+	tplhty=40ns	tplhmx=55ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7406  Hex Inverter Buffers/Drivers with Open-Collector High-Voltage Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7406  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y
+	D_06 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_06 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=15ns	tphlmx=23ns
+	)
*--------
*$
* 7407  Hex Buffers/Drivers with Open-Collector High-Voltage Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7407  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf DPWR DGND
+	A   Y
+	D_07 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_07 ugate (
+	tplhty=6ns	tplhmx=10ns
+	tphlty=20ns	tphlmx=30ns
+	)
*--------
*$
* 7408  Quadruple 2-input Positive-And Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7408  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(2) DPWR DGND
+	A B   Y
+	D_08 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_08 ugate (
+	tplhty=17.5ns	tplhmx=27ns
+	tphlty=12ns	tphlmx=19ns
+	)
*---------
*$
* 7409  Quadruple 2-input Positive-And Gates with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7409  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(2) DPWR DGND
+	A B   Y
+	D_09 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_09 ugate (
+	tplhty=21ns	tplhmx=32ns
+	tphlty=16ns	tphlmx=24ns
+	)
*---------
*$
* 7410  Triple 3-input Positive-Nand Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7410  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(3) DPWR DGND
+	A B C   Y
+	D_10 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_10 ugate (
+	tplhty=11ns	tplhmx=22ns
+	tphlty=7ns	tphlmx=15ns
+	)
*--------
*$
* 7411  Triple 3-input Positive-And Gates
*
* 1989 National Semiconductor
*
.subckt 7411  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(3) DPWR DGND
+	A B C   Y
+	D_11 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends
*
.model D_11 ugate (
+	tplhmx=27ns
+	tphlmx=19ns
+	)
*--------
*$
* 7412  Triple 3-input Positive-Nand Gates with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7412  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(3) DPWR DGND
+	A B C   Y
+	D_12 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_12 ugate (
+	tplhty=35ns	tplhmx=45ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7413  Dual 4-input Positive-Nand Schmitt Triggers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7413  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* Note: These devices are modeled as simple Nand gates.
*       Hysteresis is modeled in the AtoD interface

U1 nand(4) DPWR DGND
+	A B C D   Y
+	D_13 IO_STD_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_13 ugate (
+	tplhty=18ns	tplhmx=27ns
+	tphlty=15ns	tphlmx=22ns
+	)
*---------
*$
* 7414  Hex Schmitt-Trigger Inverters
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names

.subckt 7414  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* Note: These devices are modeled as simple inverters
*       Hysteresis is modeled in the AtoD interface

U1 inv DPWR DGND
+	A   Y
+	D_14 IO_STD_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_14 ugate (
+	tplhty=15ns	tplhmx=22ns
+	tphlty=15ns	tphlmx=22ns
+	)
*---------
*$
* 7416  Hex Inverter Buffers/Drivers with Open-Collector High-Voltage Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7416  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y
+	D_16 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_16 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=15ns	tphlmx=23ns
+	)
*--------
*$
* 7417  Hex Buffers/Drivers with Open-Collector High-Voltage Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7417  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf DPWR DGND
+	A   Y
+	D_17 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_17 ugate (
+	tplhty=6ns	tplhmx=10ns
+	tphlty=20ns	tphlmx=30ns
+	)
*---------
*$
* 7420  Dual 4-input Positive-Nand Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7420  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(4) DPWR DGND
+	A B C D   Y
+	D_20 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_20 ugate (
+	tplhty=12ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7422  Dual 4-input Positive-Nand Gates with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7422  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(4) DPWR DGND
+	A B C D   Y
+	D_22 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_22 ugate (
+	tplhty=35ns	tplhmx=45ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7423  Dual 4-input Nor Gates with Strobe
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7423  1A 1B 1C 1D 1G X XBAR 1Y 2A 2B 2C 2D 2G 2Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --- NOTE ---
*
* The x and xbar inputs of this gate should only come from the following
* gates:
*	'60
*
* PSpice, however, will not check that it is properly connected.

UIBUF bufa(2) DPWR DGND
+	1G 2G   1G_BUF 2G_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 inv DPWR DGND
+	XBAR   XBARC
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U11 aoi(2,5) DPWR DGND
+	1A	1G_BUF
+	1B	1G_BUF
+	1C	1G_BUF
+	1D	1G_BUF
+	X	XBARC
+	1Y
+	D_23 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U21 aoi(2,4) DPWR DGND
+	2A 2G_BUF 2B 2G_BUF 2C 2G_BUF 2D 2G_BUF   2Y
+	D_23 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_23 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7425  Dual 4-input Nor Gates with Strobe
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7425  A B C D G Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 or(4) DPWR DGND
+	A B C D   X
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2 nand(2) DPWR DGND
+	X G   Y
+	D_25 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_25 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*--------
*$
* 7426  High-Voltage Interface Positive-Nand Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7426  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y
+	D_26 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_26 ugate (
+	tplhty=16ns	tplhmx=24ns
+	tphlty=11ns	tphlmx=17ns
+	)
*---------
*$
* 7427  Triple 3-input Positive-Nor Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7427  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(3) DPWR DGND
+	A B C   Y
+	D_27 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_27 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=7ns	tphlmx=11ns
+	)
*---------
*$
* 7428  Quadruple 2-input Positive-Nor Buffers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7428  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y
+	D_28 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_28 ugate (
+	tplhty=6ns	tplhmx=9ns
+	tphlty=8ns	tphlmx=12ns
+	)
*---------
*$
* 7430  8-input Positive-Nand Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7430  A B C D E F G H Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(8) DPWR DGND
+	A B C D E F G H   Y
+	D_30 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_30 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7432  Quadruple 2-input Positive-Or Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7432  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 or(2) DPWR DGND
+	A B   Y
+	D_32 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_32 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=14ns	tphlmx=22ns
+	)
*---------
*$
* 7433  Quadruple 2-input Positive-Nor Buffers w/ Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7433  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y
+	D_33 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_33 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=12ns	tphlmx=18ns
+	)
*---------
*$
* 7437  Quadruple 2-input Positive-Nand Buffers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7437  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y
+	D_37 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_37 ugate (
+	tplhty=13ns	tphlty=8ns
+	tplhmx=22ns	tphlmx=15ns
+	)
*---------
*$
* 7438  Quadruple 2-input Positive-Nand Buffers w/ Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7438  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y
+	D_38 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_38 ugate (
+	tplhty=14ns	tplhmx=22ns
+	tphlty=11ns	tphlmx=18ns
+	)
*---------
*$
* 7439  Quadruple 2-input Positive Nand Buffers with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/10/89	Update interface and model names

.subckt 7439  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y
+	D_39 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_39 ugate (
+	tphlmx=18ns	tplhmx=22ns
+	)
*---------
*$
* 7440  Dual 4-input Positive-Nand Buffers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names

.subckt 7440  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(4) DPWR DGND
+	A B C D   Y
+	D_40 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_40 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7442A  DECODER BCD-DECIMAL 4-10 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 7442A   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U42ALOG LOGICEXP (4,14) DPWR DGND
+ A_I B_I C_I D_I
+ A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+   DBAR = { ~D }
+   Y0   = { ~(DBAR & CBAR & BBAR & ABAR ) }
+   Y1   = { ~(DBAR & CBAR & BBAR & A    ) }
+   Y2   = { ~(DBAR & CBAR & B    & ABAR ) }
+   Y3   = { ~(DBAR & CBAR & B    & A    ) }
+   Y4   = { ~(DBAR & C    & BBAR & ABAR ) }
+   Y5   = { ~(DBAR & C    & BBAR & A    ) }
+   Y6   = { ~(DBAR & C    & B    & ABAR ) }
+   Y7   = { ~(DBAR & C    & B    & A    ) }
+   Y8   = { ~(D    & CBAR & BBAR & ABAR ) }
+   Y9   = { ~(D    & CBAR & BBAR & A    ) }

U42ADLY PINDLY (10,0,4) DPWR DGND
+ Y0   Y1   Y2   Y3   Y4   Y5   Y6   Y7   Y8   Y9
+ A B C D
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ADDRA = { CHANGED(A,0) }
+   ADDRB = { CHANGED(B,0) }
+   ADDRC = { CHANGED(C,0) }
+   ADDRD = { CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O = {
+     CASE (
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,14NS,25NS)
+       )
+     }
+   Y1_O = {
+     CASE (
+       ADDRA         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y2_O = {
+     CASE (
+       ADDRB         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y3_O = {
+     CASE (
+       ADDRA | ADDRB  , DELAY(-1,17NS,30NS),
+                TRN_HL, DELAY(-1,14NS,25NS),
+                TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y4_O = {
+     CASE (
+       ADDRC         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y5_O = {
+     CASE (
+       ADDRA | ADDRC  , DELAY(-1,17NS,30NS),
+                TRN_HL, DELAY(-1,14NS,25NS),
+                TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y6_O = {
+     CASE (
+       ADDRB | ADDRC  , DELAY(-1,17NS,30NS),
+                TRN_HL, DELAY(-1,14NS,25NS),
+                TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y7_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRC, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y8_O = {
+     CASE (
+       ADDRD         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y9_O = {
+     CASE (
+       ADDRA | ADDRD, DELAY(-1,17NS,30NS),
+                TRN_HL, DELAY(-1,14NS,25NS),
+                TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }

.ENDS
*--------
*$
* 7443A  DECODER EXCESS-3-DECIMAL 4-10 LINE
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; TI, 1985
* JLS   7-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 7443A   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U43ALOG LOGICEXP (4,14) DPWR DGND
+ A_I B_I C_I D_I
+ A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+   DBAR = { ~D }
+   Y0   = { ~(DBAR & CBAR & B    & A    ) }
+   Y1   = { ~(DBAR & C    & BBAR & ABAR ) }
+   Y2   = { ~(DBAR & C    & BBAR & A    ) }
+   Y3   = { ~(DBAR & C    & B    & ABAR ) }
+   Y4   = { ~(DBAR & C    & B    & A    ) }
+   Y5   = { ~(D    & CBAR & BBAR & ABAR ) }
+   Y6   = { ~(D    & CBAR & BBAR & A    ) }
+   Y7   = { ~(D    & CBAR & B    & ABAR ) }
+   Y8   = { ~(D    & CBAR & B    & A    ) }
+   Y9   = { ~(D    & C    & BBAR & ABAR ) }

U43ADLY PINDLY (10,0,4) DPWR DGND
+ Y0   Y1   Y2   Y3   Y4   Y5   Y6   Y7   Y8   Y9
+ A B C D
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ADDRA = { CHANGED(A,0) }
+   ADDRB = { CHANGED(B,0) }
+   ADDRC = { CHANGED(C,0) }
+   ADDRD = { CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O = {
+     CASE (
+       ADDRA | ADDRB , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y1_O = {
+     CASE (
+       ADDRC         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y2_O = {
+     CASE (
+       ADDRA | ADDRC , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y3_O = {
+     CASE (
+       ADDRB | ADDRC , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y4_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRC, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y5_O = {
+     CASE (
+       ADDRD         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y6_O = {
+     CASE (
+       ADDRA | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y7_O = {
+     CASE (
+       ADDRB | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y8_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRD, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y9_O = {
+     CASE (
+       ADDRC | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }

.ENDS

*---------
*$
* 7444A  DECODER GRAY-DECIMAL 4-10 LINE
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   7-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 7444A   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U44ALOG LOGICEXP (4,14) DPWR DGND
+ A_I B_I C_I D_I
+ A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+   DBAR = { ~D }
+   Y0   = { ~(DBAR & CBAR & B    & ABAR ) }
+   Y1   = { ~(DBAR & C    & B    & ABAR ) }
+   Y2   = { ~(DBAR & C    & B    & A    ) }
+   Y3   = { ~(DBAR & C    & BBAR & A    ) }
+   Y4   = { ~(DBAR & C    & BBAR & ABAR ) }
+   Y5   = { ~(D    & C    & BBAR & ABAR ) }
+   Y6   = { ~(D    & C    & BBAR & A    ) }
+   Y7   = { ~(D    & C    & B    & A    ) }
+   Y8   = { ~(D    & C    & B    & ABAR ) }
+   Y9   = { ~(D    & CBAR & B    & ABAR ) }

U44ADLY PINDLY (10,0,4) DPWR DGND
+ Y0   Y1   Y2   Y3   Y4   Y5   Y6   Y7   Y8   Y9
+ A B C D
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ADDRA = { CHANGED(A,0) }
+   ADDRB = { CHANGED(B,0) }
+   ADDRC = { CHANGED(C,0) }
+   ADDRD = { CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O = {
+     CASE (
+       ADDRB         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y1_O = {
+     CASE (
+       ADDRB | ADDRC , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y2_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRC, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y3_O = {
+     CASE (
+       ADDRA | ADDRC , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y4_O = {
+     CASE (
+       ADDRC         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y5_O = {
+     CASE (
+       ADDRC | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y6_O = {
+     CASE (
+       ADDRA | ADDRC | ADDRD, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y7_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRC | ADDRD, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y8_O = {
+     CASE (
+       ADDRB | ADDRC | ADDRD, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y9_O = {
+     CASE (
+       ADDRB | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }

.ENDS

*---------
*$
* 7445  DECODER/DRIVER BCD-DECIMAL WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-25-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 7445   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

X1   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O   DPWR DGND   74145
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.ENDS

*--------
*$
* 7446A  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN-COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 7446A   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

X1   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O   DPWR DGND   7447A
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.ENDS

*---------
*$
* 7447A  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 7447A   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}

U47ALOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { (BBI & DBI) | (ALT & CBI) | (ABI & BLT & CLT & DLT) }
+   OUTB   = { (BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI) }
+   OUTC   = { (CBI & DBI) | (ALT & BBI & CLT) }
+   OUTD   = { (ABI & BLT & CLT) | (ALT & BLT & CBI) | (ABI & BBI & CBI) }
+   OUTE   = {  ABI | (BLT & CBI) }
+   OUTF   = { (ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT) }
+   OUTG   = { (ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR) }

U47ADLY_OC PINDLY (7,0,0) DPWR DGND
+ OUTA   OUTB   OUTC   OUTD   OUTE   OUTF   OUTG
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }

.ENDS

*---------
*$
* 7448  DECODER/DRIVER BCD-7 SEGMENT WITH INTERNAL PULLUPS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 7448   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}

U48LOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { ~((BBI & DBI) | (ALT & CBI) | (ABI & BLT & CLT & DLT)) }
+   OUTB   = { ~((BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI)) }
+   OUTC   = { ~((CBI & DBI) | (ALT & BBI & CLT)) }
+   OUTD   = { ~((ABI & BLT & CLT) | (ALT & BLT & CBI) | (ABI & BBI & CBI)) }
+   OUTE   = { ~( ABI | (BLT & CBI)) }
+   OUTF   = { ~((ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT)) }
+   OUTG   = { ~((ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR)) }

U48DLY PINDLY (7,0,0) DPWR DGND
+ OUTA   OUTB   OUTC   OUTD   OUTE   OUTF   OUTG
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }

.ENDS

*---------
*$
* 7449  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN-COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 7449   INA_I INB_I INC_I IND_I BIBAR_I
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U49LOG LOGICEXP (5,7) DPWR DGND
+ INA_I INB_I INC_I IND_I BIBAR_I
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA   = { INA_I }
+   INB   = { INB_I }
+   INC   = { INC_I }
+   IND   = { IND_I }
+   BIBAR = { BIBAR_I }
+
+   ABAR  = { ~INA }
+   BBAR  = { ~INB }
+   CBAR  = { ~INC }
+   DBAR  = { ~IND }
+   ABI   = { ~(ABAR & BIBAR) }
+   BBI   = { ~(BBAR & BIBAR) }
+   CBI   = { ~(CBAR & BIBAR) }
+   DBI   = { ~(DBAR & BIBAR) }
+
+   OUTA  = { ~((BBI & DBI) | (ABAR & CBI) | (ABI & BBAR & CBAR & DBAR)) }
+   OUTB  = { ~((BBI & DBI) | (ABI & BBAR & CBI) | (ABAR & BBI & CBI)) }
+   OUTC  = { ~((CBI & DBI) | (ABAR & BBI & CBAR)) }
+   OUTD  = { ~((ABI & BBAR & CBAR) | (ABAR & BBAR & CBI) |
+               (ABI & BBI & CBI)) }
+   OUTE  = { ~( ABI | (BBAR & CBI)) }
+   OUTF  = { ~((ABI & BBI) | (BBI & CBAR) | (ABI & CBAR & DBAR)) }
+   OUTG  = { ~((ABI & BBI & CBI) | (BBAR & CBAR & DBAR)) }

U49DLY_OC PINDLY (7,0,0) DPWR DGND
+ OUTA   OUTB   OUTC   OUTD   OUTE   OUTF   OUTG
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }

.ENDS

*---------
*$
* 7450 	Dual 2-wide 2-input And-Or-Invert Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/27/89	Update interface and model names

.subckt 7450  1A 1B 1C 1D X XBAR 1Y 2A 2B 2C 2D 2Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --- NOTE ---
* The x and xbar inputs of gate 1 of this chip can only come from the
* following gates:
*	'50
*	'60
* PSpice, however, will not check that these are properly connected.

U1V inv DPWR DGND
+	XBAR   XBARC
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 aoi(2,3) DPWR DGND
+	1A 1B 1C 1D X XBARC   1Y
+	D_50_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U2 aoi(2,2) DPWR DGND
+	2A 2B 2C 2D   2Y
+	D_50_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_50_1 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7451  And-Or-Invert Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/27/89	Update interface and model names

.subckt 7451  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 aoi(2,2) DPWR DGND
+	A B C D   Y
+	D_51 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_51 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7453  Expandable 4-wide And-Or-Invert Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/27/89	Update interface and model names

.subckt 7453  A B C D E F G H X XBAR Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --- NOTE ---
* The x and xbar inputs of this gate should only come from the following
* chips:
*	'60
*	'62
* PSpice, however, will not check that these are properly connected.

U1 inv DPWR DGND
+	XBAR   XBARC
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2 aoi(2,5) DPWR DGND
+	A	B
+	C	D
+	E	F
+	G	H
+	X	XBARC
+	Y
+	D_53 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_53 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7454  4-wide And-Or-Invert Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/27/89	Update interface and model names

.subckt 7454  A B C D E F G H Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 aoi(2,4) DPWR DGND
+	A B C D E F G H   Y
+	D_54 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_54 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*---------
*$
* 7460  Dual 4-input Expanders
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names

.subckt 7460  A B C D X XBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --- NOTE ---
* this gate should only be connected to the following expandable gates:
*	'23
*	'50
*	'53
* connected by both x and xbar connections
* PSpice, however, will not check that these are correctly connected.
* ALSO  this gate has no propagation delay.
* There is a total propagation delay in the last level NOR gate in the
* above chips, so when properly connected, the expanded combination will
* work correctly.

U1 and(4) DPWR DGND
+	A B C D   X
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2 inv DPWR DGND
+	X   XBAR
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
.ends

*---------
*$
* 7470  And-Gated J-K Positive-Edge-Triggered Flip-Flops with Preset & Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names

.subckt 7470  CLK PREBAR CLRBAR J1 J2 JBAR K1 K2 KBAR Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1V inva(3) DPWR DGND
+	CLK JBAR KBAR   CLKBAR J3 K3
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2A anda(3,2) DPWR DGND
+	J3 J1 J2 K3 K1 K2   J K
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U3 jkff(1) DPWR DGND
+	PREBAR CLRBAR CLKBAR   J K   Q QBAR
+	D_70 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_70 ueff (
+	tppcqlhmx=50ns	tppcqhlmx=50ns
+	tpclkqlhty=27ns	tpclkqlhmx=50ns
+	tpclkqhlty=18ns	tpclkqhlmx=50ns
+	twclkhmx=20ns	twclkhty=20ns
+	twclklmx=30ns	twclklty=30ns
+	twpclmx=25ns	twpclty=25ns
+	tsudclkmx=20ns	tsudclkmn=20ns
+	thdclkmx=5ns	thdclkmn=5ns
+	)
*--------
*$
* 7472  And Gated J-K Master-Slave Flip-Flops with Preset and Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/11/89	Update interface and model names

.subckt 7472  PREBAR CLRBAR CLK J1 J2 J3 K1 K2 K3 Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(2) DPWR DGND
+	PREBAR CLRBAR   PREB CLRB
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2 buf DPWR DGND
+	CLK   CLK_BUF
+	D_72_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U3 anda(3,2) DPWR DGND
+	J1 J2 J3 K1 K2 K3   J K
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U4 inva(3) DPWR DGND
+	J K CLK_BUF   JB KB CLKB
+	D0_GATE IO_STD
UF1 srff(1) DPWR DGND
+	PREB CLRB CLK_BUF   W1 W2   Y YB
+	D_72_2 IO_STD MNTYMXDLY={MNTYMXDLY}
UF2 srff(1) DPWR DGND
+	PREB CLRB CLKB   Y YB   Q1 QB1
+	D_72_3 IO_STD MNTYMXDLY={MNTYMXDLY}
U5 ao(3,2) DPWR DGND
+	J K QBD J KB $D_HI   W1
+	D_72_4 IO_STD
U6 ao(3,2) DPWR DGND
+	J K QD JB K $D_HI   W2
+	D_72_4 IO_STD
U7 bufa(4) DPWR DGND
+	Q1 Q1 QB1 QB1   Q QD QBAR QBD
+	D_72_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_72_1 ugate (
+	tplhty=6ns	tplhmx=6ns
+	)
.model D_72_2 ugff (
+	twghmn=20ns	twpclmn=25ns
+	)
.model D_72_3 ugff (
+	twghmn=47ns	twpclmn=25ns
+	tppcqhlty=19ns	tppcqhlmx=34ns
+	tppcqlhty=10ns	tppcqlhmx=19ns
+	tpgqlhty=10ns	tpgqlhmx=19ns
+	tpgqhlty=19ns	tpgqhlmx=34ns
+	)
.model D_72_4 ugate (
+	tphlty=6ns	tphlmx=6ns
+	tplhty=6ns	tplhmx=6ns
+	)
*---------
*$
* 7473  Dual J-K Flip-Flops with Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names

.subckt 7473  CLK CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(3) DPWR DGND
+	CLRBAR J K   CLRBAR_BUF J_BUF K_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2BUF buf DPWR DGND
+	CLK   CLK_BUF
+	D_73_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U1 inva(3) DPWR DGND
+	CLK_BUF J_BUF K_BUF   CLKBAR JB KB
+	D0_GATE IO_STD
U2A ao(3,2) DPWR DGND
+	J_BUF QBAR_BUFD K_BUF J_BUF KB $D_HI   W1
+	D_73_3 IO_STD MNTYMXDLY={MNTYMXDLY}
U2B ao(3,2) DPWR DGND
+	J_BUF K_BUF Q_BUFD $D_HI JB K_BUF   W2
+	D_73_3 IO_STD MNTYMXDLY={MNTYMXDLY}
U3 srff(1) DPWR DGND
+	$D_HI CLRBAR_BUF CLK_BUF   W1 W2   Y YB
+	D_73_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U4 srff(1) DPWR DGND
+	$D_HI CLRBAR_BUF CLKBAR   Y YB   QBUF QBAR_BUF
+	D_73_2 IO_STD MNTYMXDLY={MNTYMXDLY}
UOBUF bufa(2) DPWR DGND
+	QBUF QBAR_BUF   Q QBAR
+	D_73_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
UBUF bufa(2) DPWR DGND
+	QBUF QBAR_BUF   Q_BUFD QBAR_BUFD
+	D_73_3 IO_STD MNTYMXDLY={MNTYMXDLY}
.ends

.model D_73_1 ugff (
+	twghmx=14ns	twghty=14ns
+	twpclmx=25ns	twpclty=25ns
+	)
.model D_73_2 ugff (
+	tppcqlhty=10ns	tppcqlhmx=19ns
+	tppcqhlty=19ns	tppcqhlmx=34ns
+	tpgqlhty=10ns	tpgqlhmx=19ns
+	tpgqhlty=19ns	tpgqhlmx=34ns
+	twghmx=47ns	twghty=47ns
+	twpclmx=25ns	twpclty=25ns
+	)
.model D_73_3 ugate (
+	tplhty=6ns	tplhmx=6ns
+	tphlty=6ns	tphlmx=6ns
+	)
.model D_73_4 ugate (
+	tplhmn=6ns	tplhmx=6ns
+	)
*---------
*$
* 7474  Dual D-Type Positive-Edge-Triggered Flip-Flops with Preset and Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names

.subckt 7474  1CLRBAR 1D 1CLK 1PREBAR 1Q 1QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UFF1 dff(1) DPWR DGND
+	1PREBAR 1CLRBAR 1CLK   1D   1Q 1QBAR
+	D_74 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_74 ueff (
+	twpclmn=30ns	twclklmn=37ns
+	twclkhmn=30ns	tsudclkmn=20ns
+	thdclkmn=5ns	tppcqlhmx=25ns
+	tppcqhlmx=40ns	tpclkqlhty=14ns
+	tpclkqlhmx=25ns	tpclkqhlty=20ns
+	tpclkqhlmx=40ns
+	)
*---------
*$
* 7475  4-bit bistable latches (dual 2-bit common clock4-bit bistable latches )
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names

.subckt 7475  1D 2D C 1Q 1QBAR 2Q 2QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(3) DPWR DGND
+	1D 2D C   1D_BUF 2D_BUF C_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U12 dltch(2) DPWR DGND
+	$D_HI $D_HI C_BUF   1D_BUF 2D_BUF   1Q 2Q $D_NC $D_NC
+	D_75_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U12B dltch(2) DPWR DGND
+	$D_HI $D_HI C_BUF   1D_BUF 2D_BUF   $D_NC $D_NC 1QBAR 2QBAR
+	D_75_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_75_1 ugff (
+	twghmx=20ns	tsudgmx=20ns
+	thdgmx=5ns	tpgqlhty=16ns
+	tpgqlhmx=30ns	tpgqhlty=7ns
+	tpgqhlmx=15ns	tpdqlhty=16ns
+	tpdqlhmx=30ns	tpdqhlty=14ns
+	tpdqhlmx=25ns
+	)
.model D_75_2 ugff (
+	twghmx=20ns	tsudgmx=20ns
+	thdgmx=5ns	tpgqlhty=16ns
+	tpgqlhmx=30ns	tpgqhlty=7ns
+	tpgqhlmx=15ns	tpdqlhty=24ns
+	tpdqlhmx=40ns	tpdqhlty=7ns
+	tpdqhlmx=15ns
+	)
*---------
*$
* 7476  Dual J-K Flip-Flops with Preset and Clear    
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names
* jgt 09/09/96 Changed to use JKFF's rather than SRFF's, and
*              added constraint checking.
.subckt 7476  CLK PREBAR CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --NOTE--
* The standard Flip-Flops are pulse triggered
*
*
UIBUF bufa(7) DPWR DGND
+	PREBAR CLRBAR J K CLK Q2 QB2 
+  PREBAR_BUF CLRBAR_BUF J_BUF K_BUF CLK_BUF Q QBAR 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
UE1 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLK_BAR   J_BUF K_BUF   Y YB 
+	D_76_0 IO_STD MNTYMXDLY={MNTYMXDLY} 
UE2 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLK_BUF   Y YB   Q2 QB2 
+	D_76_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2BUF inv DPWR DGND
+	CLK_BUF   CLK_BAR
+	D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 

U116CON CONSTRAINT(5) DPWR DGND
+ CLK PREBAR CLRBAR J K
+ IO_STD
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 18NS
+   MIN_HI = 18NS
+
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 47NS
+   MIN_HI = 20NS
+
+ WIDTH:
+   NODE = PREBAR
+   MIN_LO = 25NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 25NS
+
+ GENERAL:
+   WHEN      = { CLK=='1 & (CHANGED(J,0NS) | CHANGED(K,0NS)) }
+   MESSAGE   = "J AND K INPUTS MUST BE STABLE WHEN CLK IS HIGH"
*
.ends
*
.model D_76_0 ueff ()

.model D_76_1 ueff (
+	tppcqlhty=16ns	tppcqlhmx=25ns
+	tppcqhlty=25ns	tppcqhlmx=40ns
+	tpclkqlhty=16ns	tpclkqlhmx=25ns
+	tpclkqhlty=25ns	tpclkqhlmx=40ns
+	)
*---------
*$
* 7477  4-bit bistable latches
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names

.subckt 7477  1D 2D C 1Q 2Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* There are actually 2 2-bit latches(per 1 control) in the real IC.  The model
* here for the IC contains only 1 2-bit latches.  If 4-bit latches is needed,
* please use the SUBCKT twice.

UIBUF buf DPWR DGND
+	C   C_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 dltch(2) DPWR DGND
+	$D_HI $D_HI C_BUF   1D 2D   1Q 2Q $D_NC $D_NC
+	D_77 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_77 ugff (
+	twghmx=20ns	tsudgmx=20ns
+	thdgmx=5ns	tpgqlhty=16ns
+	tpgqlhmx=30ns	tpgqhlty=7ns
+	tpgqhlmx=15ns	tpdqlhty=16ns
+	tpdqlhmx=30ns	tpdqhlty=14ns
+	tpdqhlmx=25ns
+	)
*---------
*$
* 7482 2-BIT BINARY FULL ADDERS
*
* THE TTL DATA BOOK, VOL 2, STANDARD, S, LS, TTL, 1985, TI
* NH 8/25/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*   SINCE THE PROP DELAY FROM A1/B1 TO SUM1 IS NOT GIVEN, THE PROP  DELAY
*   FROM B2 TO SUM2 WILL BE USED AS THE PROP DELAY FROM Ai/Bi TO SUMi & C2

.SUBCKT 7482 C0_I A1_I B1_I A2_I B2_I SUM1_O SUM2_O C2_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:   MNTYMXDLY=0  IO_LEVEL=0

U82LOG LOGICEXP(5,8) DPWR DGND
+ C0_I A1_I B1_I A2_I B2_I
+ C0   A1   B1   A2   B2   SUM1 SUM2 C2
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   C0 = { C0_I }
+   A1 = { A1_I }
+   B1 = { B1_I }
+   A2 = { A2_I }
+   B2 = { B2_I }
+   A2BAR = { ~A2 }
+   B2BAR = { ~B2 }
+
+   C0A1B1 = { ~( (C0 & A1) | (C0 & B1) | (A1 & B1) ) }
+   SUM1 = { (C0 & C0A1B1) | (A1 & C0A1B1) | (B1 & C0A1B1) | (C0 & A1 & B1) }
+   C2 = { ~( ( C0A1B1 & A2BAR) | (C0A1B1 & B2BAR) | (A2BAR & B2BAR) ) }
+   SUM2 = { ~( (C0A1B1 & C2) | (C2 & A2BAR) | (C2 & B2BAR) |
+               (A2BAR & B2BAR & C0A1B1) ) }

U82DLY PINDLY(3,0,5) DPWR DGND
+ SUM1 SUM2 C2
+ C0 A1 B1 A2 B2
+ SUM1_O SUM2_O C2_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+  ANY_CH_AB = { CHANGED(A2,0) | CHANGED(B2,0) | CHANGED(A1,0) | CHANGED(B1,0) }
+
+ PINDLY:
+   SUM1_O = {
+     CASE(
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,-1,40NS),
+       ANY_CH_AB & TRN_LH, DELAY(-1,-1,40NS),
+       ANY_CH_AB & TRN_HL, DELAY(-1,-1,35NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,-1,34NS),
+       DELAY(-1,-1,41NS)                       ;DEFAULT
+       )
+     }
+   SUM2_O = {
+     CASE(
+       ANY_CH_AB & TRN_LH, DELAY(-1,-1,40NS),
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,-1,42NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,-1,38NS),
+       ANY_CH_AB & TRN_HL, DELAY(-1,-1,35NS),
+       DELAY(-1,-1,43NS)                       ;DEFAULT
+       )
+     }
+   C2_O = {
+     CASE(
+       ANY_CH_AB & TRN_LH, DELAY(-1,-1,40NS),
+       ANY_CH_AB & TRN_HL, DELAY(-1,-1,35NS),
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,17NS,27NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,12NS,19NS),
+       DELAY(-1,18NS,41NS)                     ;DEFAULT
+       )
+     }

.ENDS

*---------
*$
* 7483A 4-BIT BINARY FULL ADDERS WITH FAST CARRY
*
* TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTTKY DATA BOOK, 1988, TI
* NH 8/25/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 7483A C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I C4_O
+             SUM1_O SUM2_O SUM3_O SUM4_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0  IO_LEVEL = 0

U83ALOG LOGICEXP(9,14) DPWR DGND
+ C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I
+ C0 A1 A2 A3 A4 B1 B2 B3 B4 C4 SUM1 SUM2 SUM3 SUM4
+ D0_GATE IO_STD IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   C0 = { C0_I }
+   A1 = { A1_I }
+   A2 = { A2_I }
+   A3 = { A3_I }
+   A4 = { A4_I }
+   B1 = { B1_I }
+   B2 = { B2_I }
+   B3 = { B3_I }
+   B4 = { B4_I }
+
+   NAND4 = { ~(A4 & B4) }
+   NAND3 = { ~(A3 & B3) }
+   NAND2 = { ~(A2 & B2) }
+   NAND1 = { ~(A1 & B1) }
+   NOR4 = { ~(A4 | B4) }
+   NOR3 = { ~(A3 | B3) }
+   NOR2 = { ~(A2 | B2) }
+   NOR1 = { ~(A1 | B1) }
+   C0BAR = { ~C0 }
+
+   SUM1 = { (NAND1 & ~NOR1) ^ C0 }
+   SUM2 = { (NAND2 & ~NOR2) ^ (~(NOR1 | (NAND1 & C0BAR))) }
+   SUM3 = { (NAND3 & ~NOR3) ^ (~(NOR2 | (NOR1 & NAND2) |
+            (NAND2 & NAND1 & C0BAR))) }
+   SUM4 = { (NAND4 & ~NOR4) ^ (~(NOR3 | (NOR2 & NAND3) |
+            (NOR1 & NAND3 & NAND2) | (NAND3 & NAND2 & NAND1 & C0BAR))) }
+   C4 = { ~( NOR4 | (NOR3 & NAND4) | (NOR2 & NAND4 & NAND3) |
+             (NOR1 & NAND4 & NAND3 & NAND2) |
+             (NAND4 & NAND3 & NAND2 & NAND1 & C0BAR) ) }

U83ADLY PINDLY(5,0,9) DPWR DGND
+ SUM1 SUM2 SUM3 SUM4 C4
+ C0 A1 A2 A3 A4 B1 B2 B3 B4
+ SUM1_O SUM2_O SUM3_O SUM4_O C4_O
+ IO_STD MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_AB = { CHANGED(A1,0) | CHANGED(B1,0) | CHANGED(A2,0) |
+                 CHANGED(B2,0) | CHANGED(A3,0) | CHANGED(B3,0) |
+                 CHANGED(A4,0) | CHANGED(B4,0) }
+
+
+ PINDLY:
+   SUM1_O SUM2_O SUM3_O SUM4_O = {
+     CASE(
+       ANY_CH_AB, DELAY(-1,16NS,24NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,14NS,21NS),
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,12NS,21NS),
+       DELAY(-1,17NS,25NS)                       ;DEFAULT
+       )
+     }
+   C4_O = {
+     CASE(
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,11NS,16NS),
+       ANY_CH_AB & TRN_HL, DELAY(-1,11NS,16NS),
+       (ANY_CH_AB | CHANGED(C0,0)) & TRN_LH, DELAY(-1,9NS,14NS),
+       DELAY(-1,12NS,17NS)                     ;DEFAULT
+       )
+     }

.ENDS

*---------
*$
* 7485 4-BIT MAGNITUDE COMPARATOR
*
* NOTE : THE SPECS FOR 1,2,AND 3 GATE LEVELS PROP DELAYS ARE GIVEN; HOWEVER,
*        ONLY PROP DELAY FOR 3 GATE LEVELS IS USED IN THIS LIBRARY.
*
* THE TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTTKY DATABOOK, 1988, TI
* KN   8-20-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 7485 A3_I A2_I A1_I A0_I B3_I B2_I B1_I B0_I
+ AGBIN_I AEBIN_I ALBIN_I AGBOUT_O AEBOUT_O ALBOUT_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U85LOG LOGICEXP(11,14) DPWR DGND
+ A3_I A2_I A1_I A0_I B3_I B2_I B1_I B0_I AGBIN_I AEBIN_I ALBIN_I
+ A3   A2   A1   A0   B3   B2   B1   B0   AGBIN   AEBIN   ALBIN
+ AGBOUT AEBOUT ALBOUT
+ D0_GATE
+ IO_STD IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*   BUFFER:
+   A3     = { A3_I }
+   A2     = { A2_I }
+   A1     = { A1_I }
+   A0     = { A0_I }
+   B3     = { B3_I }
+   B2     = { B2_I }
+   B1     = { B1_I }
+   B0     = { B0_I }
+   AGBIN  = { AGBIN_I }
+   AEBIN  = { AEBIN_I }
+   ALBIN  = { ALBIN_I }
+
*   INTERMEDIATE TERMS:
+   C3     = { ~(A3 & B3) }
+   C2     = { ~(A2 & B2) }
+   C1     = { ~(A1 & B1) }
+   C0     = { ~(A0 & B0) }
+   A3C3    = { A3 & C3 }
+   A2C2    = { A2 & C2 }
+   A1C1    = { A1 & C1 }
+   A0C0    = { A0 & C0 }
+   B3C3    = { B3 & C3 }
+   B2C2    = { B2 & C2 }
+   B1C1    = { B1 & C1 }
+   B0C0    = { B0 & C0 }
+   D3      = { ~(A3C3 | B3C3) }
+   D2      = { ~(A2C2 | B2C2) }
+   D1      = { ~(A1C1 | B1C1) }
+   D0      = { ~(A0C0 | B0C0) }
+   D32     = { D3 & D2 }
+   D31     = { D32 & D1 }
+   D30     = { D31 & D0 }
+
*   OUTPUT ASSIGNMENTS:
+   AGBOUT  = { ~B3C3 & ~(B2C2 & D3) & ~(B1C1 & D32) & ~(B0C0 & D31) &
+               ~(ALBIN & D30) & ~(AEBIN & D30) }
+   AEBOUT  = { D30 & AEBIN }
+   ALBOUT  = { ~(AEBIN & D30) & ~(AGBIN & D30) & ~(A0C0 & D31) &
+               ~(A1C1 & D32)  & ~(A2C2 & D3)   & ~A3C3 }

U85DLY PINDLY(3,0,11) DPWR DGND
+ AGBOUT AEBOUT ALBOUT
+ A3 A2 A1 A0 B3 B2 B1 B0 AGBIN AEBIN ALBIN
+ AGBOUT_O AEBOUT_O ALBOUT_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+  DATA_CHANGE = { CHANGED(A3,0) | CHANGED(A2,0) | CHANGED(A1,0) | CHANGED(A0,0)
+              | CHANGED(B3,0) | CHANGED(B2,0) | CHANGED(B1,0) | CHANGED(B0,0) }
+  AEBIN_CHANGE = { CHANGED(AEBIN,0) }
+  ABIN_CHANGE  = { AEBIN_CHANGE | CHANGED(ALBIN,0) | CHANGED(AGBIN,0) }
+
+ PINDLY:
+   AGBOUT_O ALBOUT_O = { ;AGBOUT & ALBOUT HAS THE SAME DELAY SO CAN BE GROUPPED
+     CASE(
+       DATA_CHANGE & TRN_LH,  DELAY(-1,17NS,26NS),
+       DATA_CHANGE & TRN_HL,  DELAY(-1,20NS,30NS),
+       ABIN_CHANGE  & TRN_LH, DELAY(-1,7NS,11NS),
+       ABIN_CHANGE  & TRN_HL, DELAY(-1,11NS,17NS),
+                              DELAY(-1,21NS,31NS)  ;DEFAULT
+     )
+   }
+   AEBOUT_O = {
+     CASE(
+       DATA_CHANGE  & TRN_LH, DELAY(-1,23NS,35NS),
+       DATA_CHANGE  & TRN_HL, DELAY(-1,20NS,30NS),
+       AEBIN_CHANGE & TRN_LH, DELAY(-1,13NS,20NS),
+       AEBIN_CHANGE & TRN_HL, DELAY(-1,11NS,17NS),
+                              DELAY(-1,24NS,36NS)  ;DEFAULT
+     )
+   }

.ENDS

*--------
*$
* 7486  Quadruple 2-input Exclusive-Or Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/29/89	Update interface and model names

.subckt 7486  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	A B   A_BUF B_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 or(2) DPWR DGND
+	A_BUF B_BUF   C
+	D_86_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U2 nand(2) DPWR DGND
+	A_BUF B_BUF   D
+	D_86_2 IO_STD MNTYMXDLY={MNTYMXDLY}
U3 and(2) DPWR DGND
+	C D   Y
+	D_86_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_86_1 ugate (
+	tplhty=9ns	tplhmx=17ns
+	tphlty=5ns	tphlmx=11ns
+	)
.model D_86_2 ugate (
+	tplhty=12ns	tplhmx=24ns
+	tphlty=7ns	tphlmx=16ns
+	)
.model D_86_3 ugate (
+	tplhty=6ns	tplhmx=6ns
+	tphlty=6ns	tphlmx=6ns
+	)
*---------
*$
* 7490A  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-2-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 7490A   R91_I R92_I CKA_I CKB_I R01_I R02_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CKA     $D_HI $D_HI   QA $D_NC
+ D0_EFF IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 CKB     QDBAR $D_HI   QB $D_NC
+ D0_EFF IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 QB      $D_HI $D_HI   QC $D_NC
+ D0_EFF IO_STD
U4 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CKB     J4    QD      QD QDBAR
+ D0_EFF IO_STD
U90ALOG LOGICEXP (8,10) DPWR DGND
+ R91_I R92_I CKA_I CKB_I R01_I R02_I   QB QC
+ R91   R92   CKA   CKB   R01   R02     J4     SET9BAR  CLRBAR  CLRBAR23
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   R91      = { R91_I }
+   R92      = { R92_I }
+   CKA      = { CKA_I }
+   CKB      = { CKB_I }
+   R01      = { R01_I }
+   R02      = { R02_I }
+   SET9BAR  = { ~(R91 & R92) }
+   CLRBAR   = { ~(R01 & R02) }
+   CLRBAR23 = { CLRBAR & SET9BAR }
+   J4       = { QB & QC }

U90ADLY PINDLY (4,0,4) DPWR DGND
+ QA   QB   QC   QD
+ CKA CKB CLRBAR SET9BAR
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLOCKEDB = { CHANGED_HL(CKB,0) }
+   SETNINE  = { CHANGED_HL(SET9BAR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKEDA & TRN_LH, DELAY(-1,10NS,16NS),
+       CLOCKEDA & TRN_HL, DELAY(-1,12NS,18NS),
+                 SETNINE, DELAY(-1,20NS,30NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QB_O = {
+     CASE (
+       CLOCKEDB & TRN_LH, DELAY(-1,10NS,16NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,14NS,21NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       CLOCKEDB & TRN_LH, DELAY(-1,21NS,32NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,23NS,35NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QD_O = {
+     CASE (
+                 SETNINE, DELAY(-1,20NS,30NS),
+                  TRN_LH, DELAY(-1,21NS,32NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,23NS,35NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }

U90ACON CONSTRAINT (8) DPWR DGND
+ CKA CKB CLRBAR SET9BAR R01 R02 R91 R92
+ IO_STD
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 32MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 16MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 15NS
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 30NS
+   MIN_HI         = 30NS
+ WIDTH:
+   NODE           = R01
+   MIN_LO         = 15NS
+   WHEN           = { SET9BAR!='0 }
+ WIDTH:
+   NODE           = R02
+   MIN_LO         = 15NS
+   WHEN           = { SET9BAR!='0 }
+ WIDTH:
+   NODE           = R91
+   MIN_LO         = 15NS
+ WIDTH:
+   NODE           = R92
+   MIN_LO         = 15NS
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKA
+   RELEASETIME_LH = 25NS
+   WHEN           = { SET9BAR!='0 & CHANGED(CLRBAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKB
+   RELEASETIME_LH = 25NS
+   WHEN           = { SET9BAR!='0 & CHANGED(CLRBAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R91 R92
+   CLOCK HL       = CKA
+   RELEASETIME_LH = 25NS
+   WHEN           = { CHANGED(SET9BAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R91 R92
+   CLOCK HL       = CKB
+   RELEASETIME_LH = 25NS
+   WHEN           = { CHANGED(SET9BAR,25NS) }

.ENDS

*---------
*$
* 7491A 8-BIT SHIFT REGISTERS
*
* THE TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTKKY DATA BOOK, 1988, TI
* NH 7/13/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 7491A CLK_I A_I B_I QH_O QHBAR_O
+ OPTIONAL:  DPWR=$G_DPWR   DGND=$G_DGND
+ PARAMS:    MNTYMXDLY=0    IO_LEVEL=0

U1 BUFA(3) DPWR DGND CLK_I A_I B_I CLK A B
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}

U2 NAND(2) DPWR DGND A B KA
+ D0_GATE   IO_STD

U3 INVA(2) DPWR DGND CLK KA CLKBAR JA
+ D0_GATE   IO_STD

U5 JKFF(8) DPWR DGND $D_HI $D_HI CLKBAR
+ JA QA QB QC QD QE QF QG KA QABAR QBBAR QCBAR QDBAR QEBAR QFBAR QGBAR
+ QA QB QC QD QE QF QG QH QABAR QBBAR QCBAR QDBAR QEBAR QFBAR QGBAR QHBAR
+ D0_EFF  IO_STD

U91DLY PINDLY(2,0,1) DPWR DGND
+ QH QHBAR
+ CLK
+ QH_O QHBAR_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}  IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QH_O QHBAR_O = {
+     CASE(
+       CHANGED_LH(CLK,0) & TRN_LH, DELAY(-1,24NS,40NS),
+       CHANGED_LH(CLK,0) & TRN_HL, DELAY(-1,27NS,40NS),
+       DELAY(-1,28NS,41NS)         ;DEFAULT
+       )
+     }

U91CON CONSTRAINT(3) DPWR DGND
+ CLK A B
+ IO_STD
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 10MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 25NS
+   MIN_LO = 25NS
+
+ SETUP_HOLD:
+   DATA(2) A B
+   CLOCK LH = CLK
+   SETUPTIME = 25NS

.ENDS

*---------
*$
* 7492A  COUNTER DIVIDE-BY-12 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-3-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE -- THE CKA TO QD PIN DELAY IS NOT INCLUDED IN THIS MODEL SINCE
*           THE DIV2 AND DIV8 SECTIONS OF THE COUNTER ACT INDEPENDENTLY.

.SUBCKT 7492A   CKA_I CKB_I R01_I R02_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKA   $D_HI $D_HI   QA $D_NC
+ D0_EFF  IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKB   QCBAR $D_HI   QB $D_NC
+ D0_EFF  IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKB   QB    $D_HI   QC QCBAR
+ D0_EFF  IO_STD
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC    $D_HI $D_HI   QD $D_NC
+ D0_EFF  IO_STD
U5 BUFA(4) DPWR DGND
+ CKA_I CKB_I R01_I R02_I   CKA CKB R01 R02
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U6 NAND(2) DPWR DGND
+ R01 R02   CLRBAR
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}

U92ADLY PINDLY (4,0,3) DPWR DGND
+ QA   QB   QC   QD
+ CKA CKB CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLOCKEDB = { CHANGED_HL(CKB,0) }
+   CLEARED  = { CHANGED_HL(CLRBAR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+                  TRN_LH, DELAY(-1,10NS,16NS),
+       CLOCKEDA & TRN_HL, DELAY(-1,12NS,18NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QB_O QC_O = {
+     CASE (
+                  TRN_LH, DELAY(-1,10NS,16NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,14NS,21NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QD_O = {
+     CASE (
+                  TRN_LH, DELAY(-1,21NS,32NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,23NS,35NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }

U92ACON CONSTRAINT (5) DPWR DGND
+ CKA CKB CLRBAR R01 R02
+ IO_STD
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 32MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 16MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 15NS
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 30NS
+   MIN_HI         = 30NS
+ WIDTH:
+   NODE           = R01
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = R02
+   MIN_HI         = 15NS
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKA
+   RELEASETIME_HL = 25NS
+   WHEN           = { CHANGED(CLRBAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKB
+   RELEASETIME_HL = 25NS
+   WHEN           = { CHANGED(CLRBAR,25NS) }

.ENDS

*---------
*$
* 7493A  COUNTER BINARY 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   6-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE -- THE CKA TO QD PIN DELAY IS NOT INCLUDED IN THIS MODEL SINCE
*           THE DIV2 AND DIV8 SECTIONS OF THE COUNTER ACT INDEPENDENTLY.

.SUBCKT 7493A   CKA_I CKB_I R01_I R02_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKA   $D_HI $D_HI     QA $D_NC
+ D0_EFF  IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKB   $D_HI $D_HI     QB $D_NC
+ D0_EFF  IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB    $D_HI $D_HI     QC $D_NC
+ D0_EFF  IO_STD
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC    $D_HI $D_HI     QD $D_NC
+ D0_EFF  IO_STD
U5 BUFA(4) DPWR DGND
+ CKA_I CKB_I R01_I R02_I   CKA CKB R01 R02
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U6 NAND(2) DPWR DGND
+ R01 R02   CLRBAR
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}

U93ADLY PINDLY (4,0,3) DPWR DGND
+ QA   QB   QC   QD
+ CKA CKB CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLOCKEDB = { CHANGED_HL(CKB,0) }
+   CLEARED  = { CHANGED_HL(CLRBAR,0) }
+
+ PINDLY:
+ QA_O = {
+   CASE (
+                TRN_LH, DELAY(-1,10NS,16NS),
+     CLOCKEDA & TRN_HL, DELAY(-1,12NS,18NS),
+     DELAY(-1,26NS,40NS)
+     )
+   }
+ QB_O = {
+   CASE (
+                TRN_LH, DELAY(-1,10NS,16NS),
+     CLOCKEDB & TRN_HL, DELAY(-1,14NS,21NS),
+     DELAY(-1,26NS,40NS)
+     )
+   }
+ QC_O = {
+   CASE (
+                TRN_LH, DELAY(-1,21NS,32NS),
+     CLOCKEDB & TRN_HL, DELAY(-1,23NS,35NS),
+     DELAY(-1,26NS,40NS)
+     )
+   }
+ QD_O = {
+   CASE (
+     CLEARED,  DELAY(-1,26NS,40NS),
+     DELAY(-1,34NS,51NS)
+     )
+   }

U93ACON CONSTRAINT (5) DPWR DGND
+ CKA CKB CLRBAR R01 R02
+ IO_STD
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 32MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 16MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 15NS
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 30NS
+   MIN_HI         = 30NS
+ WIDTH:
+   NODE           = R01
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = R02
+   MIN_HI         = 15NS
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKA
+   RELEASETIME_HL = 25NS
+   WHEN           = { CHANGED(CLRBAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKB
+   RELEASETIME_HL = 25NS
+   WHEN           = { CHANGED(CLRBAR,25NS) }

.ENDS

*---------
*$
* 7494  4-BIT SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1988, TI
* NH 7/1/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 7494 CLR_I CLK_I SER_I PE1_I P1A_I P1B_I P1C_I P1D_I
+ PE2_I P2A_I P2B_I P2C_I P2D_I QD_O
+ OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0    IO_LEVEL = 0

U94LOG LOGICEXP(13,20) DPWR  DGND
+ CLR_I CLK_I SER_I PE1_I P1A_I P1B_I P1C_I P1D_I PE2_I P2A_I P2B_I P2C_I P2D_I
+ CLR CLK SER PE1 P1A P1B P1C P1D PE2 P2A P2B P2C P2D SERBAR CLKBAR CLRBAR
+  PRESETA PRESETB PRESETC PRESETD
+ D0_GATE   IO_STD   IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*
* OUTPUT ASSIGNMENT
*
+   CLR = { CLR_I }
+   CLK = { CLK_I }
+   SER = { SER_I }
+   PE1 = { PE1_I }
+   P1A = { P1A_I }
+   P1B = { P1B_I }
+   P1C = { P1C_I }
+   P1D = { P1D_I }
+   PE2 = { PE2_I }
+   P2A = { P2A_I }
+   P2B = { P2B_I }
+   P2C = { P2C_I }
+   P2D = { P2D_I }
*
+   PRESETA = { ~( (PE1 & P1A) | (PE2 & P2A) ) }
+   PRESETB = { ~( (PE1 & P1B) | (PE2 & P2B) ) }
+   PRESETC = { ~( (PE1 & P1C) | (PE2 & P2C) ) }
+   PRESETD = { ~( (PE1 & P1D) | (PE2 & P2D) ) }
+   SERBAR = { ~SER }
+   CLKBAR = { ~CLK }
+   CLRBAR = { ~CLR }

U1 JKFF(1) DPWR DGND PRESETA CLRBAR CLKBAR SER SERBAR QA QABAR
+ D0_EFF IO_STD

U2 JKFF(1) DPWR DGND PRESETB CLRBAR CLKBAR QA QABAR QB QBBAR
+ D0_EFF IO_STD

U3 JKFF(1) DPWR DGND PRESETC CLRBAR CLKBAR QB QBBAR QC QCBAR
+ D0_EFF IO_STD

U4 JKFF(1) DPWR DGND PRESETD CLRBAR CLKBAR QC QCBAR LQD QDBAR
+ D0_EFF IO_STD

U94DLY PINDLY(1,0,6) DPWR DGND
+ LQD
+ CLK CLR PE1 P1D PE2 P2D
+ QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   PRESET = { (PE1!='0 & P1D!='0) | (PE2!='0 & P2D!='0) }
+
+ PINDLY:
+   QD_O = {
+     CASE(
+        PRESET, DELAY(-1,-1,35NS),
+        CHANGED_LH(CLR,0) & TRN_HL, DELAY(-1,-1,40NS),
+        CHANGED_LH(CLK,0), DELAY(-1,25NS,40NS),
+        DELAY(11NS,26NS,41NS)           ;DEFAULT
+        )
+      }

U94CON CONSTRAINT(17) DPWR DGND
+ CLK CLR SER PE1 PE2 P1A P1B P1C P1D P2A P2B P2C P2D PRESETA PRESETB PRESETC
+  PRESETD
+ IO_STD
+
+ BOOLEAN:
+   PE1_EN = { PE1!='0 }
+   PE2_EN = { PE2!='0 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 10MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 35NS
+   MIN_LO = 35NS
+
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 30NS
+
+ WIDTH:
+   NODE = P1A
+   MIN_HI = 30NS
+   WHEN = { PE1_EN }
+
+ WIDTH:
+   NODE = P2A
+   MIN_HI = 30NS
+   WHEN = { PE2_EN }
+
+ WIDTH:
+   NODE = P1B
+   MIN_HI = 30NS
+   WHEN = { PE1_EN }
+
+ WIDTH:
+   NODE = P2B
+   MIN_HI = 30NS
+   WHEN = { PE2_EN  }
+
+ WIDTH:
+   NODE = P1C
+   MIN_HI = 30NS
+   WHEN = { PE1_EN }
+
+ WIDTH:
+   NODE = P2C
+   MIN_HI = 30NS
+   WHEN = { PE2_EN }
+
+ WIDTH:
+   NODE = P1D
+   MIN_HI = 30NS
+   WHEN = { PE1_EN }
+
+ WIDTH:
+   NODE = P2D
+   MIN_HI = 30NS
+   WHEN = { PE2_EN }
+
+ SETUP_HOLD:
+   DATA(1) SER
+   CLOCK LH = CLK
+   SETUPTIME_HI = 35NS
+   SETUPTIME_LO = 25NS
+   WHEN = { CLR!='1 & PRESETA!='0 & PRESETB!='0 & PRESETC!='0 & PRESETD!='0 }

.ENDS

*---------
*$
* 7495A  4-BIT PARALLEL SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1985, TI
* KN   7-29-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 7495A MODE_I CLK1_I CLK2_I SER_I A_I B_I C_I D_I QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR   DGND=$G_DGND
+ PARAMS:   MNTYMXDLY=0    IO_LEVEL=0

U95ALOG LOGICEXP(11,17) DPWR DGND
+ MODE_I CLK1_I CLK2_I SER_I A_I B_I C_I D_I QA QB QC
+ MODE CLK1 CLK2 SER A B C D CLK JA JB JC JD KA KB KC KD
+ D0_GATE  IO_STD
+ IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = { MODE_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   SER = { SER_I }
+   A   = { A_I }
+   B   = { B_I }
+   C   = { C_I }
+   D   = { D_I }
+
* INTERMEDIATE TERM
+   MODEBAR = { ~MODE }
+
+   CLK = { ((MODEBAR  & CLK1) | (MODE  & CLK2)) }
+   JA  = { (MODEBAR  & SER)   | (MODE  & A) }
+   JB  = { (MODEBAR  & QA) | (MODE  & B) }
+   JC  = { (MODEBAR  & QB) | (MODE  & C) }
+   JD  = { (MODEBAR  & QC) | (MODE  & D) }
+   KA = { ~JA }
+   KB = { ~JB }
+   KC = { ~JC }
+   KD = { ~JD }

U1 JKFF(4) DPWR DGND $D_HI $D_HI CLK
+ JA JB JC JD KA KB KC KD QA QB QC QD $D_NC  $D_NC $D_NC $D_NC
+ D0_EFF IO_STD

U95ADLY PINDLY(4,0,2) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2
+ QA_O QB_O QC_O QD_O
+ IO_STD  MNTYMXDLY={MNTYMXDLY}  IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+    CLK = { CHANGED_HL(CLK1,0) | CHANGED_HL(CLK2,0) }
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLK & TRN_LH,  DELAY(-1,18NS,27NS),
+       CLK & TRN_HL,  DELAY(-1,21NS,32NS),
+                      DELAY(-1,22NS,33NS)  ;DEFAULT
+       )
+      }

U95ACON CONSTRAINT(8) DPWR DGND
+ MODE CLK1 CLK2 SER A B C D
+ IO_STD
+
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 25MEG
+
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK1
+   MIN_HI = 20NS
+
+ WIDTH:
+   NODE = CLK2
+   MIN_HI = 20NS
+
+ SETUP_HOLD:
+   DATA(4) A  B  C  D
+   CLOCK HL = CLK2
+   SETUPTIME = 15NS
+   WHEN = { MODE != '0 }
+
+ SETUP_HOLD:
+   DATA(1) SER
+   CLOCK HL = CLK1
+   SETUPTIME = 15NS
+   WHEN = { MODE != '1 }
+
+ SETUP_HOLD:          ; T_ENABLE1
+   DATA(1) MODE
+   CLOCK HL = CLK1
+   SETUPTIME_LO = 15NS
+   MESSAGE = "TENABLE1 IS NOT MET"
+
+ SETUP_HOLD:          ; T_ENABLE2
+   DATA(1) MODE
+   CLOCK HL = CLK2
+   SETUPTIME_HI = 15NS
+   MESSAGE = "TENABLE2 IS NOT MET"
+
+ SETUP_HOLD:          ; T_INHIBIT1
+   DATA(1) MODE
+   CLOCK LH = CLK1
+   SETUPTIME_HI = 5NS
+   MESSAGE = "TINHIBIT1 IS NOT MET"
+
+ SETUP_HOLD:          ; T_INHIBIT2
+   DATA(1) MODE
+   CLOCK LH = CLK2
+   SETUPTIME_LO = 5NS
+   MESSAGE = "TINHIBIT2 IS NOT MET"

.ENDS


*--------
*$
* 7496  8-BIT PARALLEL-OUT SERIAL SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1985, TI
* KN   7-1-92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 7496  CLRBAR_I CLK_I SER_I PRE_I A_I B_I C_I D_I E_I
+ QA_O QB_O QC_O QD_O QE_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 BUFA(9) DPWR DGND
+ CLRBAR_I CLK_I SER_I PRE_I A_I B_I C_I D_I E_I
+ CLRBAR  CLK  SER  PRE  A  B  C  D  E
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}

U2 NANDA(2,5) DPWR DGND
+ PRE A  PRE B  PRE C  PRE D  PRE E
+ OUT_A  OUT_B  OUT_C  OUT_D  OUT_E
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+ OUT_A  CLRBAR  CLK
+ SER
+ QA
+ $D_NC
+ D0_EFF IO_STD

U4 DFF(1) DPWR DGND
+ OUT_B  CLRBAR  CLK
+ QA
+ QB
+ $D_NC
+ D0_EFF IO_STD

U5 DFF(1) DPWR DGND
+ OUT_C  CLRBAR  CLK
+ QB
+ QC
+ $D_NC
+ D0_EFF IO_STD

U6 DFF(1) DPWR DGND
+ OUT_D  CLRBAR  CLK
+ QC
+ QD
+ $D_NC
+ D0_EFF IO_STD

U7 DFF(1) DPWR DGND
+ OUT_E  CLRBAR  CLK
+ QD
+ QE
+ $D_NC
+ D0_EFF IO_STD

USTD96DLY PINDLY(5,0,3) DPWR DGND
+ QA QB QC QD QE
+ CLRBAR PRE CLK
+ QA_O QB_O QC_O QD_O QE_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA_O QB_O QC_O QD_O QE_O = {
+     CASE(
+       CHANGED_LH(PRE,0),    DELAY(-1,28NS,35NS),
+       CHANGED_LH(CLK,0),    DELAY(-1,25NS,40NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,-1,55NS),
+                             DELAY(-1,-1,56NS)  ;DEFAULT
+       )
+     }

USTD96CON CONSTRAINT(4) DPWR DGND
+ CLRBAR CLK SER PRE
+ IO_STD
+
+ FREQ:
+   NODE    = CLK
+   MAXFREQ = 10MEG
+
+ WIDTH:
+   NODE   = CLK
+   MIN_HI = 35NS
+   MIN_LO = 35NS
+
+ WIDTH:
+   NODE   = CLRBAR
+   MIN_LO = 30NS
+
+ WIDTH:
+   NODE   = PRE
+   MIN_HI = 30NS
+
+ SETUP_HOLD:
+   DATA(1)   = SER    ; NOR SETTING
+   CLOCK LH  = CLK    ; CHECK SERIAL INPUT SETUPTIME WHEN NOT CLEARING
+   SETUPTIME = 30NS
+   WHEN = { (CLRBAR != '0) & (PRE != '1) }

.ENDS


*---------
*$
* 74100  8-Bit Bistable Latches
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/17/89	Update interface and model names

.subckt 74100  1C 1D1 1D2 1D3 1D4 1Q1 1Q2 1Q3 1Q4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* There are 2 4-bit latches in the real 74100 IC.  However, the model here is
* designed with only 1 4-bit latch. In case of 8-bit latches needed, please use
* the SUBCKT twice.

U1 dltch(4) DPWR DGND
+	$D_HI	$D_HI	1C
+	1D1	1D2	1D3	1D4
+	1Q1	1Q2	1Q3	1Q4	$D_NC	$D_NC	$D_NC	$D_NC
+	D_100 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_100 ugff (
+	twghmn=20ns	tsudgmn=20ns
+	thdgmn=5ns	tpgqlhty=16ns
+	tpgqlhmx=30ns	tpgqhlty=7ns
+	tpgqhlmx=15ns	tpdqlhty=16ns
+	tpdqlhmx=30ns	tpdqhlty=14ns
+	tpdqhlmx=25ns
+	)
*--------
*$
* 74107  Dual J-K Flip-Flops with Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/29/89	Update interface and model names
* jgt  04/20/95      Changed to use jkff's
*
.subckt 74107  CLK CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(3) DPWR DGND
+	CLRBAR J K   CLRBAR_BUF J_BUF K_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2BUF buf DPWR DGND
+	CLK   CLK_BUF 
+	D_107_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U1 JKff(1) DPWR DGND
+	$D_HI CLRBAR_BUF CLKBAR   W1 W2   Y YB
+	D_107_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2 JKff(1) DPWR DGND
+	$D_HI CLRBAR_BUF CLK_BUF   Y YB   QBUF QBAR_BUF 
+	D_107_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
U3 inva(3) DPWR DGND
+	CLK_BUF J_BUF K_BUF   CLKBAR JB KB 
+	D0_GATE IO_STD 
U4 ao(3,2) DPWR DGND
+	J_BUF K_BUF QBAR_BUFD J_BUF KB $D_HI   W1 
+	D_107_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
U5 ao(3,2) DPWR DGND
+	J_BUF K_BUF QBUFD JB K_BUF $D_HI   W2 
+	D_107_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
UBUF bufa(4) DPWR DGND
+	QBUF QBAR_BUF QBUF QBAR_BUF   Q QBAR QBUFD QBAR_BUFD 
+	D_107_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_107_1 ueff (
+	tppcqlhty=10ns	tppcqlhmx=15ns
+	tppcqhlty=10ns	tppcqhlmx=15ns
+	tpclkqlhty=10ns	tpclkqlhmx=16ns
+	tpclkqhlty=18ns	tpclkqhlmx=28ns
+	twclkhmx=20ns	twclklmx=20ns
+	twclkhty=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=10ns	tsudclkty=20ns
+	thdclkmx=6ns	thdclkty=6ns
+	)
.model D_107_2 ueff (
+	tppcqlhty=10ns	tppcqlhmx=19ns
+	tppcqhlty=19ns	tppcqhlmx=34ns
+	tpclkqlhty=10ns	tpclkqlhmx=19ns
+	tpclkqhlty=19ns	tpclkqhlmx=34ns
+	twclkhmx=20ns	twclklmx=20ns
+	twclkhty=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=10ns	tsudclkty=20ns
+	thdclkmx=6ns	thdclkty=6ns
+	)
.model D_107_3 ugate (
+	tplhty=6ns	tplhmx=6ns
+	tphlty=6ns	tphlmx=6ns
+	)
.model D_107_4 ugate (
+	tplhmn=6ns	tplhmx=6ns
+	)
*---------
*$
* 74109  Dual J-KBar Positive-Edge-Triggered Flip-Flops w/ Preset & Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/30/89	Update interface and model names

.subckt 74109  CLK PREBAR CLRBAR J KBAR Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(3) DPWR DGND
+	PREBAR CLRBAR J   PREBAR_BUF CLRBAR_BUF J_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   J_BUF K   $D_NC QBAR
+	D_109_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U2 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   J_BUF K   Q $D_NC
+	D_109_2 IO_STD MNTYMXDLY={MNTYMXDLY}
U3 inva(2) DPWR DGND
+	CLK KBAR   CLKBAR K
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
.ends

.model D_109_1 ueff (
+	tppcqlhty=10ns	tppcqlhmx=15ns
+	tppcqhlty=10ns	tppcqhlmx=15ns
+	tpclkqlhty=10ns	tpclkqlhmx=16ns
+	tpclkqhlty=18ns	tpclkqhlmx=28ns
+	twclkhmx=20ns	twclklmx=20ns
+	twclkhty=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=10ns	tsudclkty=20ns
+	thdclkmx=6ns	thdclkty=6ns
+	)
.model D_109_2 ueff (
+	tppcqlhty=23ns	tppcqlhmx=35ns
+	tppcqhlty=17ns	tppcqhlmx=25ns
+	tpclkqlhty=10ns	tpclkqlhmx=16ns
+	tpclkqhlty=18ns	tpclkqhlmx=28ns
+	twclkhmx=20ns	twclklmx=20ns
+	twclkhty=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=10ns	tsudclkty=20ns
+	thdclkmx=6ns	thdclkty=6ns
+	)
*---------
*$
* 74110  And-Gated J-K Master-Slave Flip-Flops with Data Lockout
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/18/89	Update interface and model names

.subckt 74110  CLK PREBAR CLRBAR J1 J2 J3 K1 K2 K3 Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	PREBAR CLRBAR   PREBAR_BUF CLRBAR_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 inv DPWR DGND
+	CLK   CLKBAR
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2 anda(3,2) DPWR DGND
+	J1 J2 J3 K1 K2 K3   J K
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U3 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   J K   QI $D_NC
+	D_110_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U4 dff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   QI   Q QBAR
+	D_110_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_110_1 ueff (
+	tsudclkmn=20ns	thdclkmn=5ns
+	twclkhmn=25ns	twclklmn=25ns
+	twpclmn=25ns
+	)
.model D_110_2 ueff (
+	tppcqlhty=12ns	tppcqlhmx=20ns
+	tsudclkmn=20ns	thdclkmn=5ns
+	tppcqhlty=18ns	tppcqhlmx=25ns
+	tpclkqlhty=20ns	tpclkqlhmx=30ns
+	tpclkqhlty=13ns	tpclkqhlmx=20ns
+	twclkhmn=25ns	twpclmn=25ns
+	)
*--------
*$
* 74111  Dual J-K Master-Slave Flip-Flops with Data Lockout
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/30/89	Update interface and model names

.subckt 74111  CLK PREBAR CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	PREBAR CLRBAR   PREBAR_BUF CLRBAR_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
UA inv DPWR DGND
+	CLK   CLKBAR
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   J K   QI $D_NC
+	D_111_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U2 dltch(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLK   QI   Q QBAR
+	D_111_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_111_1 ueff (
+	thdclkty=30ns	thdclkmx=30ns
+	twclkhty=25ns	twclkhmx=25ns
+	twclklty=25ns	twclklmx=25ns
+	twpclty=25ns	twpclmx=25ns
+	)
.model D_111_2 ugff (
+	tppcqlhty=12ns	tppcqlhmx=18ns
+	tppcqhlty=21ns	tppcqhlmx=30ns
+	tpgqlhty=12ns	tpgqlhmx=17ns
+	tpgqhlty=20ns	tpgqhlmx=30ns
+	twghmx=25ns	twghty=25ns
+	twpclmx=25ns	twpclty=25ns
+	)
*--------
*$
* 74121  Non-retriggerable Monostable Multivibrator w/Schmitt-Trigger Inputs
*
* The TTL Data Book, Vol 2, 1985, TI
* rbh 06/14/91 Created
* rbh 06/02/92 Added dummy R/C pins
*
* Notes:
* 1. The RINT, CEXT, and REXT/CEXT pins are not functional.  The output
*    pulse width, tw(out), is controlled with the PULSE subcircuit
*    parameter.  Note that this means that the pulse width is FIXED for
*    the duration of the simulation.  You can specify this value in the
*    subcircuit call, e.g. X1 ... 74121 PARAMS: PULSE=1us
* 2. Instead of a fixed minimum input pulse width (50ns), this model requires
*    the input pulse to be at least as long as the propagation delay through
*    the device.  Input pulses which are shorter than this value produce
*    an X which is tw(out) in duration.

.subckt 74121 A1 A2 B RINT CEXT REXT/CEXT Q Qbar
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: PULSE=30ns IO_LEVEL=0 MNTYMXDLY=0
*
R1 RINT 0 100MEG
R2 RINT 0 100MEG
R3 CEXT 0 100MEG
R4 CEXT 0 100MEG
R5 REXT/CEXT 0 100MEG
R6 REXT/CEXT 0 100MEG
*
UA nand(2) DPWR DGND
+ 	A1 A2  A
+	D0_GATE IO_STD_ST IO_LEVEL={IO_LEVEL}
UAdly dlyline DPWR DGND
+	A A_dly
+	D_121_A_dly IO_STD MNTYMXDLY={MNTYMXDLY}
UTrigger nand(2) DPWR DGND
+	A_dly B  Trigger
+	D0_GATE IO_STD_ST IO_LEVEL={IO_LEVEL}
UStart stim(1,1) DPWR DGND
+	Clear
+	IO_STM
+	0S	0
+	1NS	Z
*
UOutputs jkff(1) DPWR DGND
+	$D_HI Clear Trigger $D_HI $D_LO Q_ Q_Bar
+	D_121_Outputs  IO_STD MNTYMXDLY={MNTYMXDLY}
*
UQ_Buf buf DPWR DGND
+	Q_ Q_Buf
+	D0_GATE IO_STD
UQx isx(1) DPWR DGND
+	q_   q_x
+	D0_GATE IO_STD
UQ0 is0(1) DPWR DGND
+	q_   q_0
+	D0_GATE IO_STD
UQ0_Bar inv DPWR DGND
+	q_0 q0_bar
+	D0_GATE IO_STD

UQ_Rise or(2) DPWR DGND
+	Q_Buf q_x  q_rise
+	D0_GATE IO_STD
UTrigdly dlyline DPWR DGND
+	Trigger trigdly
+	D_121_trigdly IO_STD MNTYMXDLY={MNTYMXDLY}
UTrigx isx(1) DPWR DGND
+	trigdly trigx
+	D0_GATE IO_STD
UTrigx_bar inv DPWR DGND
+	trigx trigx_fall
+	D0_GATE IO_STD

UReset0 nand(2) DPWR DGND
+	q_rise trigx_fall reset0
+	D0_GATE IO_STD
UClear jkff(1) dpwr dgnd
+	q0_bar $d_hi reset0 $d_lo $d_hi Clear $d_nc
+	D_121_pulse IO_STD MNTYMXDLY={MNTYMXDLY}
*
* Output buffers
*
UQ inv DPWR DGND
+	q_bar Q
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
UQBar buf DPWR DGND
+	q_bar QBAR
+	D_121_Qbar IO_STD IO_LEVEL={IO_LEVEL} MNTYMXDLY={MNTYMXDLY}
*
* Local timing model
*
.model D_121_pulse ueff(
+	tpclkqhlmn={pulse} tpclkqhlty={pulse} tpclkqhlmx={pulse}
+	)
.ends 74121

.model D_121_Outputs ueff (
+	twclklty=35ns	twclklmx=55ns
+	tpclkqlhty=35ns	tpclkqlhmx=55ns
+	tpclkqhlty=35ns	tpclkqhlmx=55ns
+	)
.model D_121_A_dly udly (
+	dlyty=10ns	dlymx=15ns
+	)
.model D_121_trigdly udly (
+	dlyty=35ns	dlymx=55ns
+	)
.model D_121_Qbar ugate (
+	tplhty=5ns	tplhmx=10ns
+	tphlty=5ns	tphlmx=10ns
+	)
*--------
*$
* 74122  Retriggerable Monostable Multivibrator
*
* The TTL Data Book, Vol 2, 1985, TI
* rbh 06/14/91 Created
* rbh 06/02/92 Added dummy R/C pins
*
* Notes:
* 1. The RINT, CEXT, and REXT/CEXT pins are not functional.  The output
*    pulse width, tw(out), is controlled with the PULSE subcircuit
*    parameter.  Note that this means that the pulse width is FIXED for
*    the duration of the simulation.  You can specify this value in the
*    subcircuit call, e.g. X1 ... 74122 PARAMS: PULSE=1us
* 2. Instead of a fixed minimum input pulse width (40ns), this model requires
*    the input pulse to be at least as long as the propagation delay through
*    the device.  Input pulses which are shorter than this value produce
*    an X which is tw(out) in duration.
* 3. Some prop delays are off by a few nanoseconds.

.subckt 74122 CLRBAR A1 A2 B1 B2 RINT CEXT REXT/CEXT Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: PULSE=45ns IO_LEVEL=0 MNTYMXDLY=0
*
R1 RINT 0 100MEG
R2 RINT 0 100MEG
R3 CEXT 0 100MEG
R4 CEXT 0 100MEG
R5 REXT/CEXT 0 100MEG
R6 REXT/CEXT 0 100MEG
*
UA nand(2) DPWR DGND
+ 	A1 A2  A
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
UAdly dlyline DPWR DGND
+	A A_dly
+	D_122_A_dly IO_STD MNTYMXDLY={MNTYMXDLY}
*
UTrigger and(3) DPWR DGND
+	A_dly B1 B2 Trigger
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
*
UTrigBar inv DPWR DGND
+	Trigger Trig_Bar
+	D0_GATE IO_STD

UStart stim(1,1) DPWR DGND
+	Clear
+	IO_STM
+	0ns	0
+	1ns	Z

UClear and(2) DPWR DGND
+	CLRBAR Reset Clear
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}

UOutputs jkff(1) DPWR DGND
+	$D_HI Clear Trig_Bar $D_HI $D_LO Q QBAR
+	D_122_Outputs  IO_STD IO_LEVEL={IO_LEVEL} MNTYMXDLY={MNTYMXDLY}
*
UTrigdly dlyline DPWR DGND
+	Trigger trigdly
+	D_122_trigdly IO_STD MNTYMXDLY={MNTYMXDLY}
UTrigx isx(1) DPWR DGND
+	trigdly trigx
+	D0_GATE IO_STD

UTrigx_bar inv DPWR DGND
+	trigx trigx_bar
+	D0_GATE IO_STD
UTrigx_barbar inv DPWR DGND
+	trigx_bar trigx_barbar
+	D_122_tedge IO_STD MNTYMXDLY={MNTYMXDLY}
UTrigx_fall and(2) DPWR DGND
+	trigx_barbar trigx_bar trigx_fall
+	D0_GATE IO_STD

UReset0 nor(2) DPWR DGND
+	trigdly trigx_fall reset0
+	D0_GATE IO_STD

UTrig0 is0(1) DPWR DGND
+	Trigger Trig_0
+	D0_GATE IO_STD
UTrig0_Bar inv DPWR DGND
+	Trig_0 Trig0_Bar
+	D_122_edge IO_STD MNTYMXDLY={MNTYMXDLY}
UTrigPreset or(2) DPWR DGND
+	Trig_0 Trig0_Bar TrigPreset
+	D0_GATE IO_STD

UReset jkff(1)  DPWR DGND
+	TrigPreset $d_hi reset0 $d_lo $d_hi reset $d_nc
+	D_122_pulse IO_STD MNTYMXDLY={MNTYMXDLY}
*
* Local timing model
*
.model D_122_pulse ueff(
+	tpclkqhlmn={pulse-1ns+1ns}
+	tpclkqhlty={pulse-1ns+1ns}	;-1 for trigdly, +1=tp(trig)-tp(reset)
+	tpclkqhlmx={pulse-1ns+1ns}
+	)
.ends 74122

.model D_122_A_dly udly (
+	dlyty=3ns	dlymx=5ns
+	)
.model D_122_Outputs ueff (
+	twclklty=19ns	twclklmx=28ns
+	tpclkqlhty=19ns	tpclkqlhmx=28ns
+	tpclkqhlty=27ns	tpclkqhlmx=36ns
+	tppcqhlty=18ns	tppcqhlmx=27ns
+	tppcqlhty=26ns	tppcqlhmx=35ns
+	)
.model D_122_trigdly udly (
+	dlymn=1ns	dlyty=1ns	dlymx=1ns
+	)
.model D_122_edge ugate(
+	tplhmn=1ns	tplhty=1ns	tplhmx=1ns
+	)
.model D_122_tedge ugate(
+	tphlmn=1ns	tphlty=1ns	tphlmx=1ns
+	)
*--------
*$
* 74123  Retriggerable Monostable Multivibrator
*
* The TTL Data Book, Vol 2, 1985, TI
* rbh 06/14/91 Created
* rbh 06/02/92 Added dummy R/C pins
*
* Notes:
* 1. The CEXT and REXT/CEXT pins are not functional.  The output
*    pulse width, tw(out), is controlled with the PULSE subcircuit
*    parameter.  Note that this means that the pulse width is FIXED for
*    the duration of the simulation.  You can specify this value in the
*    subcircuit call, e.g. X1 ... 74123 PARAMS: PULSE=1us
* 2. Instead of a fixed minimum input pulse width (40ns), this model requires
*    the input pulse to be at least as long as the propagation delay through
*    the device.  Input pulses which are shorter than this value produce
*    an X which is tw(out) in duration.
* 3. Some prop delays are off by a few nanoseconds.

.subckt 74123 CLRBAR A B CEXT REXT/CEXT Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: PULSE=45ns IO_LEVEL=0 MNTYMXDLY=0
*
R1 CEXT 0 100MEG
R2 CEXT 0 100MEG
R3 REXT/CEXT 0 100MEG
R4 REXT/CEXT 0 100MEG
*
UABar inv DPWR DGND
+	A ABar
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
UAdly dlyline DPWR DGND
+	ABar A_dly
+	D_123_A_dly IO_STD MNTYMXDLY={MNTYMXDLY}
UTrigger and(2) DPWR DGND
+	A_dly B  Trigger
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
*
UTrigBar inv DPWR DGND
+	Trigger Trig_Bar
+	D0_GATE IO_STD

UStart stim(1,1) DPWR DGND
+	Clear
+	IO_STM
+	0ns	0
+	1ns	Z

UClear and(2) DPWR DGND
+	CLRBAR Reset Clear
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}

UOutputs jkff(1) DPWR DGND
+	$D_HI Clear Trig_Bar $D_HI $D_LO Q QBAR
+	D_123_Outputs  IO_STD IO_LEVEL={IO_LEVEL} MNTYMXDLY={MNTYMXDLY}
*
UTrigdly dlyline DPWR DGND
+	Trigger trigdly
+	D_123_trigdly IO_STD MNTYMXDLY={MNTYMXDLY}
UTrigx isx(1) DPWR DGND
+	trigdly trigx
+	D0_GATE IO_STD

UTrigx_bar inv DPWR DGND
+	trigx trigx_bar
+	D0_GATE IO_STD
UTrigx_barbar inv DPWR DGND
+	trigx_bar trigx_barbar
+	D_123_tedge IO_STD MNTYMXDLY={MNTYMXDLY}
UTrigx_fall and(2) DPWR DGND
+	trigx_barbar trigx_bar trigx_fall
+	D0_GATE IO_STD

UReset0 nor(2) DPWR DGND
+	trigdly trigx_fall reset0
+	D0_GATE IO_STD

UTrig0 is0(1) DPWR DGND
+	Trigger Trig_0
+	D0_GATE IO_STD
UTrig0_Bar inv DPWR DGND
+	Trig_0 Trig0_Bar
+	D_123_edge IO_STD MNTYMXDLY={MNTYMXDLY}
UTrigPreset or(2) DPWR DGND
+	Trig_0 Trig0_Bar TrigPreset
+	D0_GATE IO_STD

UReset jkff(1)  DPWR DGND
+	TrigPreset $d_hi reset0 $d_lo $d_hi reset $d_nc
+	D_123_pulse IO_STD MNTYMXDLY={MNTYMXDLY}
*
* Local timing model
*
.model D_123_pulse ueff(
+	tpclkqhlmn={pulse-1ns+1ns}
+	tpclkqhlty={pulse-1ns+1ns}	;-1 for trigdly, +1=tp(trig)-tp(reset)
+	tpclkqhlmx={pulse-1ns+1ns}
+	)
+	)
.ends 74123

.model D_123_A_dly udly (
+	dlyty=3ns	dlymx=5ns
+	)
.model D_123_Outputs ueff (
+	twclklty=19ns	twclklmx=28ns
+	tpclkqlhty=19ns	tpclkqlhmx=28ns
+	tpclkqhlty=27ns	tpclkqhlmx=36ns
+	tppcqhlty=18ns	tppcqhlmx=27ns
+	tppcqlhty=26ns	tppcqlhmx=35ns
+	)
.model D_123_trigdly udly (
+	dlymn=1ns	dlyty=1ns	dlymx=1ns
+	)
.model D_123_edge ugate(
+	tplhmn=1ns	tplhty=1ns	tplhmx=1ns
+	)
.model D_123_tedge ugate(
+	tphlmn=1ns	tphlty=1ns	tphlmx=1ns
+	)
*---------
*$
* 74125  Quadruple Bus Buffer with 3-state Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names

.subckt 74125  A GBAR Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf3 DPWR DGND
+	A   G   Y
+	D_125 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U2 inv DPWR DGND
+	GBAR   G
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
.ends

.model D_125 utgate (
+	tplhty=8ns	tplhmx=13ns
+	tphlty=12ns	tphlmx=18ns
+	tpzhty=11ns	tpzhmx=17ns
+	tpzlty=16ns	tpzlmx=25ns
+	tphzty=5ns	tphzmx=8ns
+	tplzty=7ns	tplzmx=12ns
+	)
*---------
*$
* 74126  Quadruple Bus Buffer with 3-state Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names

.subckt 74126  A G Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf3 DPWR DGND
+	A   G   Y
+	D_126 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_126 utgate (
+	tplhty=8ns	tplhmx=13ns
+	tphlty=12ns	tphlmx=18ns
+	tpzhty=11ns	tpzhmx=18ns
+	tpzlty=16ns	tpzlmx=25ns
+	tphzty=10ns	tphzmx=16ns
+	tplzty=12ns	tplzmx=18ns
+	)
*---------
*$
* 74128  Line Drivers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names

.subckt 74128  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y
+	D_128 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_128 ugate (
+	tplhty=6ns	tplhmx=9ns
+	tphlty=8ns	tphlmx=12ns
+	)
*--------
*$
* 74132  Quadruple 2-input Positive-Nand Schmitt Triggers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names

.subckt 74132  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* Note: These devices are modeled as simple Nand gates.
*       Hysteresis is modeled by the AtoD interface.

U1 nand(2) DPWR DGND
+	A B   Y
+	D_132 IO_STD_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_132 ugate (
+	tplhty=15ns	tplhmx=22ns
+	tphlty=15ns	tphlmx=22ns
+	)
*---------
*$
* 74136  Quadruple 2-input Exclusive-Or Gates with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names

.subckt 74136  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	A B   A_BUF B_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 or(2) DPWR DGND
+	A_BUF B_BUF   C
+	D_136_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U2 nand(2) DPWR DGND
+	A_BUF B_BUF   D
+	D_136_2 IO_STD MNTYMXDLY={MNTYMXDLY}
U3 and(2) DPWR DGND
+	C D   Y
+	D_136_3 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends 74136

.model D_136_1 ugate (
+	tplhty=12ns	tplhmx=18ns
+	)
.model D_136_2 ugate (
+	tplhty=14ns	tplhmx=22ns
+	tphlty=3ns	tphlmx=5ns
+	)
.model D_136_3 ugate (
+	tphlty=39ns	tphlmx=50ns
+	)
*---------
*$
* 74145  DECODER/DRIVER BCD-DECIMAL WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-25-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74145   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U145LOG LOGICEXP (4,10) DPWR DGND
+ A_I B_I C_I D_I
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+   DBAR = { ~D }
+   Y0   = { ~(DBAR & CBAR & BBAR & ABAR ) }
+   Y1   = { ~(DBAR & CBAR & BBAR & A    ) }
+   Y2   = { ~(DBAR & CBAR & B    & ABAR ) }
+   Y3   = { ~(DBAR & CBAR & B    & A    ) }
+   Y4   = { ~(DBAR & C    & BBAR & ABAR ) }
+   Y5   = { ~(DBAR & C    & BBAR & A    ) }
+   Y6   = { ~(DBAR & C    & B    & ABAR ) }
+   Y7   = { ~(DBAR & C    & B    & A    ) }
+   Y8   = { ~(D    & CBAR & BBAR & ABAR ) }
+   Y9   = { ~(D    & CBAR & BBAR & A    ) }

U145DLY PINDLY (10,0,0) DPWR DGND
+ Y0   Y1   Y2   Y3   Y4   Y5   Y6   Y7   Y8   Y9
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O =
+     { DELAY(-1,-1,50NS) }

.ENDS

*---------
*$
* 74147  PRIORITY ENCODER 10-4 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-31-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74147   IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I IN8_I IN9_I
+ A_O B_O C_O D_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U147LOG LOGICEXP (9,13) DPWR DGND
+ IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I IN8_I IN9_I
+ IN1   IN2   IN3   IN4   IN5   IN6   IN7   IN8   IN9
+ A B C D
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+ IN1    = { IN1_I }
+ IN2    = { IN2_I }
+ IN3    = { IN3_I }
+ IN4    = { IN4_I }
+ IN5    = { IN5_I }
+ IN6    = { IN6_I }
+ IN7    = { IN7_I }
+ IN8    = { IN8_I }
+ IN9    = { IN9_I }
+ IN1BAR = { ~IN1 }
+ IN2BAR = { ~IN2 }
+ IN3BAR = { ~IN3 }
+ IN4BAR = { ~IN4 }
+ IN5BAR = { ~IN5 }
+ IN6BAR = { ~IN6 }
+ IN7BAR = { ~IN7 }
+ IN8BAR = { ~IN8 }
+ IN9BAR = { ~IN9 }
+
+ D      = { IN8 & IN9 }
+ C      = { ~(D & (IN4BAR | IN5BAR | IN6BAR | IN7BAR)) }
+ B      = { ~(D & ((IN2BAR & IN4 & IN5) |
+             (IN3BAR & IN4 & IN5) | IN6BAR | IN7BAR)) }
+ A      = { ~(IN9BAR | D & ((IN1BAR & IN2 & IN4 & IN6) |
+             (IN3BAR & IN4 & IN6) | (IN5BAR & IN6) | IN7BAR)) }

U147DLY PINDLY (4,0,9) DPWR DGND
+ A   B   C   D
+ IN1 IN2 IN3 IN4 IN5 IN6 IN7 IN8 IN9
+ A_O B_O C_O D_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATAHI   = { IN9=='1 & IN8=='1 & IN7=='1 & IN6=='1 & IN5=='1 &
+                IN4=='1 & IN3=='1 & IN2=='1 & IN1=='1 }
+
+ PINDLY:
+   A_O B_O C_O D_O = {
+     CASE (
+       DATAHI, DELAY(-1, 9NS,14NS),
+       TRN_HL, DELAY(-1, 7NS,11NS),
+       TRN_LH, DELAY(-1,13NS,19NS),
+       DELAY(-1,13NS,19NS)
+       )
+     }

.ENDS

*---------
*$
* 74148  PRIORITY ENCODER 8-3 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74148   IN0_I IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I EI_I
+ A0_O A1_O A2_O GS_O EO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U148LOG LOGICEXP (9,14) DPWR DGND
+ IN0_I IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I EI_I
+ IN0   IN1   IN2   IN3   IN4   IN5   IN6   IN7   EI
+ A0 A1 A2 GS EO
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+ IN0    = { IN0_I }
+ IN1    = { IN1_I }
+ IN2    = { IN2_I }
+ IN3    = { IN3_I }
+ IN4    = { IN4_I }
+ IN5    = { IN5_I }
+ IN6    = { IN6_I }
+ IN7    = { IN7_I }
+ EI     = { EI_I }
+ IN0BAR = { ~IN0 }
+ IN1BAR = { ~IN1 }
+ IN2BAR = { ~IN2 }
+ IN3BAR = { ~IN3 }
+ IN4BAR = { ~IN4 }
+ IN5BAR = { ~IN5 }
+ IN6BAR = { ~IN6 }
+ IN7BAR = { ~IN7 }
+ EIBAR  = { ~EI }
+
+ A0     = { ~(EIBAR & ((IN1BAR & IN2 & IN4 & IN6) |
+                       (IN3BAR & IN4 & IN6) | (IN5BAR & IN6) | IN7BAR)) }
+ A1     = { ~(EIBAR & ((IN2BAR & IN4 & IN5) |
+                       (IN3BAR & IN4 & IN5) | IN6BAR | IN7BAR)) }
+ A2     = { ~(EIBAR & (IN4BAR | IN5BAR | IN6BAR | IN7BAR)) }
+ EO     = { ~(IN0 & IN1 & IN2 & IN3 & IN4 & IN5 & IN6 & IN7 & EIBAR) }
+ GS     = { ~(EO & EIBAR) }

U148DLY PINDLY (5,0,9) DPWR DGND
+ A0   A1   A2   GS   EO
+ IN0 IN1 IN2 IN3 IN4 IN5 IN6 IN7 EI
+ A0_O A1_O A2_O GS_O EO_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATAHI   = { IN7=='1 & IN6=='1 & IN5=='1 & IN4=='1 &
+                IN3=='1 & IN2=='1 & IN1=='1 & IN0=='1 }
+   ENABLE   = { CHANGED(EI,0) }
+
+ PINDLY:
+   A2_O A1_O A0_O= {
+     CASE (
+       ENABLE, DELAY(-1,10NS,15NS),
+       DATAHI, DELAY(-1,10NS,15NS),
+       TRN_HL, DELAY(-1, 9NS,14NS),
+       TRN_LH, DELAY(-1,13NS,19NS),
+       DELAY(-1,13NS,19NS)
+       )
+     }
+   GS_O = {
+     CASE (
+       ENABLE   & TRN_LH, DELAY(-1, 8NS,12NS),
+       ENABLE   & TRN_HL, DELAY(-1,10NS,15NS),
+                  TRN_LH, DELAY(-1,18NS,30NS),
+                  TRN_HL, DELAY(-1,14NS,25NS),
+       DELAY(-1,18NS,30NS)
+       )
+     }
+   EO_O = {
+     CASE (
+       ENABLE   & TRN_LH, DELAY(-1,10NS,15NS),
+       ENABLE   & TRN_HL, DELAY(-1,17NS,30NS),
+                  TRN_LH, DELAY(-1, 6NS,10NS),
+                  TRN_HL, DELAY(-1,14NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }

.ENDS

*---------
*$
* 74151A  MULTIPLEXER/DATA SELECTOR 8-1 LINE
*
* THE TTL DATA BOOK, 1988, TI
* TC  08/20/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES

.SUBCKT 74151A GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ Y_O W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U151ALOG LOGICEXP(12,14) DPWR DGND
+ GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ GBAR A B C D0 D1 D2 D3 D4 D5 D6 D7 W Y
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D0 = { D0_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   D3 = { D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   IG = { ~GBAR }
+   ID0 = { D0 & IA & IB & IC & IG }
+   ID1 = { D1 & A & IB & IC & IG }
+   ID2 = { D2 & IA & B & IC & IG }
+   ID3 = { D3 & A & B & IC & IG }
+   ID4 = { D4 & IA & IB & C & IG }
+   ID5 = { D5 & A & IB & C & IG }
+   ID6 = { D6 & IA & B & C & IG }
+   ID7 = { D7 & A & B & C & IG }
+   W = { ~(ID0 | ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7) }
+   Y = { ~W }

U151ADLY PINDLY(2,0,12) DPWR DGND
+ W Y
+ GBAR A B C D0 D1 D2 D3 D4 D5 D6 D7
+ W_O Y_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+     CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+   ENABLE = { CHANGED(GBAR,0) }
+ PINDLY:
+   Y_O = {
+     CASE(
+       SELECT, DELAY(-1,25NS,38NS),
+       ENABLE & TRN_LH, DELAY(-1,21NS,33NS),
+       ENABLE & TRN_HL, DELAY(-1,22NS,33NS),
+       DATA & TRN_LH, DELAY(-1,13NS,20NS),
+       DATA & TRN_HL, DELAY(-1,18NS,27NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }
+   W_O = {
+     CASE(
+       SELECT & TRN_HL, DELAY(-1,19NS,30NS),
+       SELECT & TRN_LH, DELAY(-1,17NS,26NS),
+       ENABLE & TRN_HL, DELAY(-1,15NS,23NS),
+       ENABLE & TRN_LH, DELAY(-1,14NS,21NS),
+       DATA, DELAY(-1,8NS,14NS),
+       DELAY(-1,20NS,31NS)
+       )
+     }

.ENDS

*---------
*$
* 54152A  MULTIPLEXER/DATA SELECTOR 8-1 LINE
*
* THE TTL DATA BOOK, VOL 2, STANDARD, S, LS, TTL,1985, TI
* TC  08/24/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES

.SUBCKT 54152A A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U152ALOG LOGICEXP(11,12) DPWR DGND
+ A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ A B C D0 D1 D2 D3 D4 D5 D6 D7 W
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D0 = { D0_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   D3 = { D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   ID0 = { D0 & IA & IB & IC }
+   ID1 = { D1 & A & IB & IC }
+   ID2 = { D2 & IA & B & IC }
+   ID3 = { D3 & A & B & IC }
+   ID4 = { D4 & IA & IB & C }
+   ID5 = { D5 & A & IB & C }
+   ID6 = { D6 & IA & B & C }
+   ID7 = { D7 & A & B & C }
+   W = { ~(ID0 | ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7) }

U152ADLY PINDLY(1,0,11) DPWR DGND
+ W
+ A B C D0 D1 D2 D3 D4 D5 D6 D7
+ W_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+     CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+ PINDLY:
+   W_O = {
+     CASE(
+       SELECT & TRN_HL, DELAY(-1,19NS,30NS),
+       SELECT & TRN_LH, DELAY(-1,17NS,26NS),
+       DATA, DELAY(-1,8NS,14NS),
+       DELAY(-1,20NS,31NS)
+       )
+     }

.ENDS

*---------
*$
* 74153  DUAL 4-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*
* The TTL Data Book, 1988, TI
* JSW   8/12/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices

.SUBCKT 74153 G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I 1C3_I
+ 2C0_I 2C1_I 2C2_I 2C3_I Y1_O Y2_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U153LOG LOGICEXP(12,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I 1C3_I 2C0_I 2C1_I 2C2_I 2C3_I
+ G1BAR G2BAR A B 1C0 1C1 1C2  1C3 2C0 2C1 2C2 2C3 Y1 Y2
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   G1BAR = { G1BAR_I }
+   G2BAR = { G2BAR_I }
+   A = { A_I }
+   B = { B_I }
+   1C0 = { 1C0_I }
+   1C1 = { 1C1_I }
+   1C2 = { 1C2_I }
+   1C3 = { 1C3_I }
+   2C0 = { 2C0_I }
+   2C1 = { 2C1_I }
+   2C2 = { 2C2_I }
+   2C3 = { 2C3_I }
+   G1 = { ~G1BAR }
+   G2 = { ~G2BAR }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   I0 = { G1 & BBAR & ABAR & 1C0 }
+   I1 = { G1 & BBAR & A    & 1C1 }
+   I2 = { G1 & B    & ABAR & 1C2 }
+   I3 = { G1 & B    & A    & 1C3 }
+   I4 = { G2 & BBAR & ABAR & 2C0 }
+   I5 = { G2 & BBAR & A    & 2C1 }
+   I6 = { G2 & B    & ABAR & 2C2 }
+   I7 = { G2 & B    & A    & 2C3 }
+   Y1 = { I0 | I1 | I2 | I3 }
+   Y2 = { I4 | I5 | I6 | I7 }

U153DLY PINDLY(2,0,12) DPWR DGND
+ Y1 Y2
+ G1BAR G2BAR A B 1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+ Y1_O Y2_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA1 = { (CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) |
+     CHANGED(1C3,0)) }
+   DATA2 = { (CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) |
+     CHANGED(2C3,0)) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) }
+ PINDLY:
+   Y1_O = {
+     CASE(
+       SELECT, DELAY(-1,22NS,34NS),
+       CHANGED(G1BAR,0) & TRN_LH, DELAY(-1,19NS,30NS),
+       CHANGED(G1BAR,0) & TRN_HL, DELAY(-1,15NS,23NS),
+       DATA1 & TRN_HL, DELAY(-1,15NS,23NS),
+       DATA1 & TRN_LH, DELAY(-1,12NS,18NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }
+   Y2_O = {
+     CASE(
+       SELECT, DELAY(-1,22NS,34NS),
+       CHANGED(G2BAR,0) & TRN_LH, DELAY(-1,19NS,30NS),
+       CHANGED(G2BAR,0) & TRN_HL, DELAY(-1,15NS,23NS),
+       DATA2 & TRN_HL, DELAY(-1,15NS,23NS),
+       DATA2 & TRN_LH, DELAY(-1,12NS,18NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }

.ENDS

*---------
*$
* 74154  DECODER/DEMULTIPLEXER 4-16 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, 1988, TI
* JLS   8-6-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74154   G1BAR_I G2BAR_I A_I B_I C_I D_I
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U154LOG LOGICEXP (6,21) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C_I D_I
+ ENABLE          A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR  = { G1BAR_I }
+   G2BAR  = { G2BAR_I }
+   ENABLE = { ~(G1BAR | G2BAR) }
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   D      = { D_I }
+   ABAR   = { ~A }
+   BBAR   = { ~B }
+   CBAR   = { ~C }
+   DBAR   = { ~D }
+   Y0     = { ~(ENABLE & DBAR & CBAR & BBAR & ABAR) }
+   Y1     = { ~(ENABLE & DBAR & CBAR & BBAR & A   ) }
+   Y2     = { ~(ENABLE & DBAR & CBAR & B    & ABAR) }
+   Y3     = { ~(ENABLE & DBAR & CBAR & B    & A   ) }
+   Y4     = { ~(ENABLE & DBAR & C    & BBAR & ABAR) }
+   Y5     = { ~(ENABLE & DBAR & C    & BBAR & A   ) }
+   Y6     = { ~(ENABLE & DBAR & C    & B    & ABAR) }
+   Y7     = { ~(ENABLE & DBAR & C    & B    & A   ) }
+   Y8     = { ~(ENABLE & D    & CBAR & BBAR & ABAR) }
+   Y9     = { ~(ENABLE & D    & CBAR & BBAR & A   ) }
+   Y10    = { ~(ENABLE & D    & CBAR & B    & ABAR) }
+   Y11    = { ~(ENABLE & D    & CBAR & B    & A   ) }
+   Y12    = { ~(ENABLE & D    & C    & BBAR & ABAR) }
+   Y13    = { ~(ENABLE & D    & C    & BBAR & A   ) }
+   Y14    = { ~(ENABLE & D    & C    & B    & ABAR) }
+   Y15    = { ~(ENABLE & D    & C    & B    & A   ) }

U154DLY PINDLY (16,0,5) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ ENABLE A B C D
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE = { CHANGED(ENABLE,0) }
+   ADDR = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+   Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O = {
+     CASE (
+       ABLE & TRN_HL, DELAY(-1,18NS,27NS),
+       ABLE & TRN_LH, DELAY(-1,20NS,30NS),
+       ADDR & TRN_HL, DELAY(-1,22NS,33NS),
+       ADDR & TRN_LH, DELAY(-1,24NS,36NS),
+       DELAY(-1,24NS,36NS)
+       )
+     }

.ENDS

*---------
*$
* 74155  DECODER/DEMULTIPLEXER 2-4 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-29-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74155   G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U155LOG LOGICEXP (6,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+ G1BAR           A   B   C1         ENABLE1 ENABLE2
+ 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR   = { G1BAR_I }
+   G2BAR   = { G2BAR_I }
+   A       = { A_I }
+   B       = { B_I }
+   C1      = { C1_I }
+   C2BAR   = { C2BAR_I }
+   ABAR    = { ~A }
+   BBAR    = { ~B }
+   ENABLE1 = { ~G1BAR &  C1 }
+   ENABLE2 = { ~G2BAR & ~C2BAR }
+
+   1Y0     = { ~(ENABLE1 & BBAR & ABAR) }
+   1Y1     = { ~(ENABLE1 & BBAR & A   ) }
+   1Y2     = { ~(ENABLE1 & B    & ABAR) }
+   1Y3     = { ~(ENABLE1 & B    & A   ) }
+
+   2Y0     = { ~(ENABLE2 & BBAR & ABAR) }
+   2Y1     = { ~(ENABLE2 & BBAR & A   ) }
+   2Y2     = { ~(ENABLE2 & B    & ABAR) }
+   2Y3     = { ~(ENABLE2 & B    & A   ) }

U155DLY PINDLY (8,0,6) DPWR DGND
+ 1Y0   1Y1   1Y2   1Y3   2Y0   2Y1   2Y2   2Y3
+ G1BAR A B C1 ENABLE1 ENABLE2
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE   = { (CHANGED(G1BAR,0) & CHANGED(ENABLE1,0))
+             | CHANGED(ENABLE2,0) }
+   ADDR   = { CHANGED(A,0) | CHANGED(B,0) }
+   ADDRA  = { CHANGED(A,0) }
+   ADDRB  = { CHANGED(B,0) }
+   ADDRC1 = { CHANGED(C1,0) & CHANGED(ENABLE1,0) }
+
+ PINDLY:
+   1Y0_O 2Y0_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,13NS,20NS),
+       ABLE   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDR   & TRN_LH, DELAY(-1,13NS,20NS),
+       ADDR   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_LH, DELAY(-1,16NS,24NS),
+       ADDRC1 & TRN_HL, DELAY(-1,20NS,30NS),
+       DELAY(-1,20NS,30NS)
+       )
+     }
+   1Y1_O 2Y1_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,13NS,20NS),
+       ABLE   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_LH, DELAY(-1,16NS,24NS),
+       ADDRC1 & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRA          , DELAY(-1,21NS,32NS),
+       ADDRB  & TRN_LH, DELAY(-1,13NS,20NS),
+       ADDRB  & TRN_HL, DELAY(-1,18NS,27NS),
+       DELAY(-1,21NS,32NS)
+       )
+     }
+   1Y2_O 2Y2_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,13NS,20NS),
+       ABLE   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_LH, DELAY(-1,16NS,24NS),
+       ADDRC1 & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRB          , DELAY(-1,21NS,32NS),
+       ADDRA  & TRN_LH, DELAY(-1,13NS,20NS),
+       ADDRA  & TRN_HL, DELAY(-1,18NS,27NS),
+       DELAY(-1,21NS,32NS)
+       )
+     }
+   1Y3_O 2Y3_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,13NS,20NS),
+       ABLE   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_LH, DELAY(-1,16NS,24NS),
+       ADDRC1 & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDR           , DELAY(-1,21NS,32NS),
+       DELAY(-1,21NS,32NS)
+       )
+     }

.ENDS

*---------
*$
* 74156  DECODER/DEMULTIPLEXER 2-4 LINE WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74156   G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U156LOG LOGICEXP (6,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+ G1BAR           A   B   C1           ENABLE1 ENABLE2
+ 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR   = { G1BAR_I }
+   G2BAR   = { G2BAR_I }
+   A       = { A_I }
+   B       = { B_I }
+   C1      = { C1_I }
+   C2BAR   = { C2BAR_I }
+   ABAR    = { ~A }
+   BBAR    = { ~B }
+   ENABLE1 = { ~G1BAR &  C1 }
+   ENABLE2 = { ~G2BAR & ~C2BAR }
+
+   1Y0     = { ~(ENABLE1 & BBAR & ABAR) }
+   1Y1     = { ~(ENABLE1 & BBAR & A   ) }
+   1Y2     = { ~(ENABLE1 & B    & ABAR) }
+   1Y3     = { ~(ENABLE1 & B    & A   ) }
+
+   2Y0     = { ~(ENABLE2 & BBAR & ABAR) }
+   2Y1     = { ~(ENABLE2 & BBAR & A   ) }
+   2Y2     = { ~(ENABLE2 & B    & ABAR) }
+   2Y3     = { ~(ENABLE2 & B    & A   ) }

U156DLY PINDLY (8,0,6) DPWR DGND
+ 1Y0   1Y1   1Y2   1Y3   2Y0   2Y1   2Y2   2Y3
+ G1BAR A B C1 ENABLE1 ENABLE2
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE   = { (CHANGED(G1BAR,0) & CHANGED(ENABLE1,0))
+             | CHANGED(ENABLE2,0) }
+   ADDR   = { CHANGED(A,0) | CHANGED(B,0) }
+   ADDRA  = { CHANGED(A,0) }
+   ADDRB  = { CHANGED(B,0) }
+   ADDRC1 = { CHANGED(C1,0) & CHANGED(ENABLE1,0) }
+
+ PINDLY:
+   1Y0_O 2Y0_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,15NS,23NS),
+       ABLE   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDR   & TRN_LH, DELAY(-1,15NS,23NS),
+       ADDR   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRC1 & TRN_LH, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_HL, DELAY(-1,22NS,33NS),
+       DELAY(-1,22NS,33NS)
+       )
+     }
+   1Y1_O 2Y1_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,15NS,23NS),
+       ABLE   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRC1 & TRN_LH, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_HL, DELAY(-1,22NS,33NS),
+       ADDRA          , DELAY(-1,23NS,34NS),
+       ADDRB  & TRN_LH, DELAY(-1,15NS,23NS),
+       ADDRB  & TRN_HL, DELAY(-1,20NS,30NS),
+       DELAY(-1,23NS,34NS)
+       )
+     }
+   1Y2_O 2Y2_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,15NS,23NS),
+       ABLE   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRC1 & TRN_LH, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_HL, DELAY(-1,22NS,33NS),
+       ADDRB          , DELAY(-1,23NS,34NS),
+       ADDRA  & TRN_LH, DELAY(-1,15NS,23NS),
+       ADDRA  & TRN_HL, DELAY(-1,20NS,30NS),
+       DELAY(-1,23NS,34NS)
+       )
+     }
+   1Y3_O 2Y3_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,15NS,23NS),
+       ABLE   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRC1 & TRN_LH, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_HL, DELAY(-1,22NS,33NS),
+       ADDR           , DELAY(-1,23NS,34NS),
+       DELAY(-1,23NS,34NS)
+       )
+     }

.ENDS

*---------
*$
* 74157  QUADRUPLE 2-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*
* The TTL Data Book, 1988, TI
* JSW   8/25/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices

.SUBCKT 74157 GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ Y1_O Y2_O Y3_O Y4_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U157LOG LOGICEXP(10,14) DPWR DGND
+ GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL Y1 Y2 Y3 Y4
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   1A = { 1A_I }
+   1B = { 1B_I }
+   2A = { 2A_I }
+   2B = { 2B_I }
+   3A = { 3A_I }
+   3B = { 3B_I }
+   4A = { 4A_I }
+   4B = { 4B_I }
+   SEL = { SEL_I }
+   SELBAR = { ~SEL }
+   G = { ~GBAR }
+   Y1 = { (1A & SELBAR & G) | (1B & SEL & G) }
+   Y2 = { (2A & SELBAR & G) | (2B & SEL & G) }
+   Y3 = { (3A & SELBAR & G) | (3B & SEL & G) }
+   Y4 = { (4A & SELBAR & G) | (4B & SEL & G) }

U157DLY PINDLY(4,0,10) DPWR DGND
+ Y1 Y2 Y3 Y4
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL
+ Y1_O Y2_O Y3_O Y4_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+     CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+   SELECT = { CHANGED(SEL,0) }
+   ENABLE = { CHANGED(GBAR,0) }
+ PINDLY:
+   Y1_O Y2_O Y3_O Y4_O = {
+     CASE(
+       SELECT & TRN_HL, DELAY(-1,18NS,27NS),
+       SELECT & TRN_LH, DELAY(-1,15NS,23NS),
+       ENABLE & TRN_HL, DELAY(-1,14NS,21NS),
+       ENABLE & TRN_LH, DELAY(-1,13NS,20NS),
+       DATA, DELAY(-1,9NS,14NS),
+       DELAY(-1,19NS,28NS)
+       )
+     }

.ENDS

*---------
*$
* 74159  DECODER/DEMULTIPLEXER 4-16 LINE WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-24-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74159   G1BAR_I G2BAR_I A_I B_I C_I D_I
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U159LOG LOGICEXP (6,21) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C_I D_I
+ ENABLE          A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR  = { G1BAR_I }
+   G2BAR  = { G2BAR_I }
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   D      = { D_I }
+
+   ENABLE = { ~(G1BAR | G2BAR) }
+   ABAR   = { ~A }
+   BBAR   = { ~B }
+   CBAR   = { ~C }
+   DBAR   = { ~D }
+   Y0     = { ~(ENABLE & DBAR & CBAR & BBAR & ABAR) }
+   Y1     = { ~(ENABLE & DBAR & CBAR & BBAR & A   ) }
+   Y2     = { ~(ENABLE & DBAR & CBAR & B    & ABAR) }
+   Y3     = { ~(ENABLE & DBAR & CBAR & B    & A   ) }
+   Y4     = { ~(ENABLE & DBAR & C    & BBAR & ABAR) }
+   Y5     = { ~(ENABLE & DBAR & C    & BBAR & A   ) }
+   Y6     = { ~(ENABLE & DBAR & C    & B    & ABAR) }
+   Y7     = { ~(ENABLE & DBAR & C    & B    & A   ) }
+   Y8     = { ~(ENABLE & D    & CBAR & BBAR & ABAR) }
+   Y9     = { ~(ENABLE & D    & CBAR & BBAR & A   ) }
+   Y10    = { ~(ENABLE & D    & CBAR & B    & ABAR) }
+   Y11    = { ~(ENABLE & D    & CBAR & B    & A   ) }
+   Y12    = { ~(ENABLE & D    & C    & BBAR & ABAR) }
+   Y13    = { ~(ENABLE & D    & C    & BBAR & A   ) }
+   Y14    = { ~(ENABLE & D    & C    & B    & ABAR) }
+   Y15    = { ~(ENABLE & D    & C    & B    & A   ) }

U159DLY PINDLY (16,0,5) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ ENABLE A B C D
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE = { CHANGED(ENABLE,0) }
+   ADDR = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+   Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O = {
+     CASE (
+       ABLE & TRN_LH, DELAY(-1,15NS,25NS),
+       ABLE & TRN_HL, DELAY(-1,22NS,36NS),
+       ADDR & TRN_LH, DELAY(-1,23NS,36NS),
+       ADDR & TRN_HL, DELAY(-1,24NS,36NS),
+       DELAY(-1,24NS,36NS)
+       )
+     }

.ENDS

*--------
*$
* 74160  Synchronous 4-bit Decade Counters with asynchronous clear
*
* The TTL Data Book, 1986, TI
* JSW   7/1/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices

.SUBCKT 74160 CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U160LOG LOGICEXP(14,20) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QDBAR QA QB QC QD
+ CLK ENP ENT CLRBAR LOADBAR A B C D
+ CLKBAR RCO JA JB JC JD KA KB KC KD EN
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }                     ;Buffering
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   CLKBAR = { ~CLK }                ;Logic expressions
+   LOAD = { ~LOADBAR }
+   EN = { ENP & ENT }
+   I1A = { LOAD | EN }
+   I2A = { ~(LOAD & A) }
+   JA = { I1A & ~(LOAD & I2A) }
+   KA = { I1A & I2A }
+   I1B = { (QA & EN & QDBAR) | LOAD }
+   I2B = { ~(LOAD & B) }
+   JB = { I1B & ~(LOAD & I2B) }
+   KB = { I1B & I2B }
+   I1C = { (QA & EN & QB) | LOAD }
+   I2C = { ~(LOAD & C) }
+   JC = { I1C & ~(LOAD & I2C) }
+   KC = { I1C & I2C }
+   I1D = { ((QC & QB & QA & EN) | (EN & QA & QD)) | LOAD }
+   I2D = { ~(LOAD & D) }
+   JD = { I1D & ~(LOAD & I2D) }
+   KD = { I1D & I2D }
+   RCO = { QD & QA & ENT }

UJKFF JKFF(4) DPWR DGND $D_HI CLRBAR CLKBAR JA JB JC JD KA KB KC KD
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR D0_EFF IO_STD

U160DLY PINDLY(5,0,4) DPWR DGND
+ RCO QA QB QC QD
+ CLK LOADBAR ENT CLRBAR
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+   CNTENT = { CHANGED(ENT,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK & LOADBAR=='1 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK & LOADBAR=='1 & TRN_HL, DELAY(-1,15NS,23NS),
+       CLOCK & LOADBAR=='0 & TRN_LH, DELAY(-1,17NS,25NS),
+       CLOCK & LOADBAR=='0 & TRN_HL, DELAY(-1,19NS,29NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,26NS,38NS),
+       DELAY(-1,26NS,38NS)
+   	)
+     }
+   RCO_O = {
+     CASE(
+       CNTENT, DELAY(-1,11NS,16NS),
+       CLOCK, DELAY(-1,23NS,35NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }

U160CON CONSTRAINT(10) DPWR DGND
+ CLK ENP ENT CLRBAR LOADBAR A B C D EN
+ IO_STD
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { CLRBAR!='0 & (LOADBAR!='0 ^ CHANGED(LOADBAR,0))
+     & CHANGED(EN,20NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 20NS

.ENDS

*---------
*$
* 74161  Synchronous 4-bit Binary Counter with Direct Clear
*
* THE TTL LOGIC DATA BOOK, 1988, TI
* tc  06/30/92  Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices

.SUBCKT 74161 CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 JKFF(4) DPWR DGND $D_HI CLRBAR MCLK
+ JA JB JC JD KA KB KC KD
+ QA QB QC QD $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_STD

U161LOG LOGICEXP(13,20) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD
+ MCLK RCO JA JB JC JD KA KB KC KD CLK ENP ENT CLRBAR LOADBAR A B C D IEN
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   ILD = { ~LOADBAR }
+   IEN = { ENP & ENT }
+   IA1 = { IEN | ILD }
+   IA2 = { ~(A & ILD) }
+   IB1 = { (QA & IEN) | ILD }
+   IB2 = { ~(B & ILD) }
+   IC1 = { (QB & QA & IEN) | ILD }
+   IC2 = { ~(C & ILD) }
+   ID1 = { (QC & QB & QA & IEN) | ILD }
+   ID2 = { ~(D & ILD) }
+   MCLK = { ~CLK }
+   RCO = { QD & QC & QB & QA & ENT }
+   JA = { ~(ILD & IA2) & IA1 }
+   KA = { IA1 & IA2 }
+   JB = { ~(ILD & IB2) & IB1 }
+   KB = { IB1 & IB2 }
+   JC = { ~(ILD & IC2) & IC1 }
+   KC = { IC1 & IC2 }
+   JD = { ~(ILD & ID2) & ID1 }
+   KD = { ID1 & ID2 }

U161DLY PINDLY(5,0,4) DPWR DGND
+ RCO QA QB QC QD
+ CLK LOADBAR ENT CLRBAR
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK & LOADBAR!='0 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK & LOADBAR!='0 & TRN_HL, DELAY(-1,15NS,23NS),
+       CLOCK & LOADBAR!='1 & TRN_LH, DELAY(-1,17NS,25NS),
+       CLOCK & LOADBAR!='1 & TRN_HL, DELAY(-1,19NS,29NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,26NS,38NS),
+       DELAY(-1,26NS,38NS)
+       )
+     }
+   RCO_O = {
+     CASE(
+       CHANGED(ENT,0), DELAY(-1,11NS,16NS),
+       CLOCK, DELAY(-1,23NS,35NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }

U161CON CONSTRAINT(10) DPWR DGND
+ CLK ENP ENT CLRBAR LOADBAR A B C D IEN
+ IO_STD
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & CLRBAR!='0 &
+     CHANGED(IEN,20NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { CLRBAR!='0 }

.ENDS

*---------
*$
* 74162  Synchronous 4-bit Decade Counters with synchronous clear
*
* The TTL Data Book, 1986, TI
* JSW   7/1/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices

.SUBCKT 74162  CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U162LOG LOGICEXP(14,20) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QDBAR QA QB QC QD
+ CLK ENP ENT CLRBAR LOADBAR A B C D
+ CLKBAR RCO JA JB JC JD KA KB KC KD EN
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }                     ;Buffering
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   CLKBAR = { ~CLK_I }                ;Logic expressions
+   LOAD = { ~LOADBAR | ~CLRBAR }
+   EN = { ENP & ENT }
+   I1A = { LOAD | EN }
+   I2A = { ~(LOAD & A & CLRBAR) }
+   JA = { I1A & ~(LOAD & I2A) }
+   KA = { I1A & I2A }
+   I1B = { (QA & EN & QDBAR) | LOAD }
+   I2B = { ~(LOAD & B & CLRBAR) }
+   JB = { I1B & ~(LOAD & I2B) }
+   KB = { I1B & I2B }
+   I1C = { (QA & EN & QB) | LOAD }
+   I2C = { ~(LOAD & C & CLRBAR) }
+   JC = { I1C & ~(LOAD & I2C) }
+   KC = { I1C & I2C }
+   I1D = { ((QC & QB & QA & EN) | (EN & QA & QD)) | LOAD }
+   I2D = { ~(LOAD & D & CLRBAR) }
+   JD = { I1D & ~(LOAD & I2D) }
+   KD = { I1D & I2D }
+   RCO = { QD & QA & ENT }

UJKFF JKFF(4) DPWR DGND $D_HI $D_HI CLKBAR JA JB JC JD KA KB KC KD
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR D0_EFF IO_STD

U162DLY PINDLY(5,0,3) DPWR DGND
+ RCO QA QB QC QD
+ CLK LOADBAR ENT
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+   CNTENT = { CHANGED(ENT,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK & LOADBAR=='1 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK & LOADBAR=='1 & TRN_HL, DELAY(-1,15NS,23NS),
+       CLOCK & LOADBAR=='0 & TRN_LH, DELAY(-1,17NS,25NS),
+       CLOCK & LOADBAR=='0 & TRN_HL, DELAY(-1,19NS,29NS),
+       DELAY(-1,19NS,29NS)
+   	)
+     }
+   RCO_O = {
+     CASE(
+       CNTENT, DELAY(-1,11NS,16NS),
+       CLOCK, DELAY(-1,23NS,35NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }

U162CON CONSTRAINT(10) DPWR DGND
+ CLK ENP ENT EN CLRBAR LOADBAR A B C D
+ IO_STD
+ BOOLEAN:
+   NOTCLEAR = { CLRBAR!='0 ^ CHANGED(CLRBAR,0) }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & NOTCLEAR }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOTCLEAR & (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & CHANGED(EN,20NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { NOTCLEAR }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS

.ENDS

*---------
*$
* 74163  Synchronous 4-bit Binary Counter
*
* THE TTL LOGIC DATA BOOK, 1988, TI
* tc  07/08/92  Remodeled using LOGICEXP, PINDLY, & CONSTRAINT Devices

.SUBCKT 74163 CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 JKFF(4) DPWR DGND $D_HI $D_HI MCLK JA JB JC JD KA KB KC KD QA QB QC QD
+ $D_NC $D_NC $D_NC $D_NC D0_EFF IO_STD

U163LOG LOGICEXP(13,20) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD
+ MCLK RCO JA JB JC JD KA KB KC KD CLK ENP ENT CLRBAR LOADBAR IEN
+  A B C D
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   ILD = { ~(LOADBAR & CLRBAR) }
+   IEN = { ENP & ENT }
+   IA1 = { IEN | ILD }
+   IA2 = { ~(A & CLRBAR & ILD) }
+   IB1 = { (QA & IEN) | ILD }
+   IB2 = { ~(B & CLRBAR & ILD) }
+   IC1 = { (QB & QA & IEN) | ILD }
+   IC2 = { ~(C & CLRBAR & ILD) }
+   ID1 = { (QC & QB & QA & IEN) | ILD }
+   ID2 = { ~(D & CLRBAR & ILD) }
+   MCLK = { ~CLK }
+   RCO = { QD & QC & QB & QA & ENT }
+   JA = { ~(ILD & IA2) & IA1 }
+   KA = { IA1 & IA2 }
+   JB = { ~(ILD & IB2) & IB1 }
+   KB = { IB1 & IB2 }
+   JC = { ~(ILD & IC2) & IC1 }
+   KC = { IC1 & IC2 }
+   JD = { ~(ILD & ID2) & ID1 }
+   KD = { ID1 & ID2 }

U163DLY PINDLY(5,0,3) DPWR DGND
+ RCO QA QB QC QD
+ CLK LOADBAR ENT
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK & LOADBAR=='1 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK & LOADBAR=='1 & TRN_HL, DELAY(-1,15NS,23NS),
+       CLOCK & LOADBAR=='0 & TRN_LH, DELAY(-1,17NS,25NS),
+       CLOCK & LOADBAR=='0 & TRN_HL, DELAY(-1,19NS,29NS),
+       DELAY(-1,26NS,38NS)
+       )
+     }
+   RCO_O = {
+     CASE(
+       CHANGED(ENT,0), DELAY(-1,11NS,16NS),
+       CLOCK, DELAY(-1,23NS,35NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }

U163CON CONSTRAINT(10) DPWR DGND
+ CLK ENP ENT CLRBAR LOADBAR A B C D IEN
+ IO_STD
+ BOOLEAN:
+   NOTCLEAR = { CLRBAR!='0 ^ CHANGED(CLRBAR,0) }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & NOTCLEAR }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & NOTCLEAR & CHANGED(IEN,20NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { NOTCLEAR }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS

.ENDS

*---------
*$
* 74164  8-BIT PARALLEL-OUT SERIAL SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1985, TI
* KN   6-30-92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*

.SUBCKT 74164  CLRBAR_I CLK_I A_I B_I QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 BUFA(4) DPWR DGND
+ CLRBAR_I CLK_I A_I B_I   CLRBAR CLK A B
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}

U2 AND(2) DPWR DGND
+ A B   IN
+ D0_GATE IO_STD

U3 DFF(8) DPWR DGND
+ $D_HI   CLRBAR  CLK
+ IN   QA  QB  QC  QD  QE  QF  QG
+ QA   QB  QC  QD  QE  QF  QG  QH
+ $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC
+ D0_EFF IO_STD

U164DLY PINDLY(8,0,2) DPWR DGND
+ QA QB QC QD QE QF QG QH
+ CLRBAR CLK
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O = {
+     CASE(
+       CHANGED_LH(CLK,0) & TRN_LH, DELAY(8NS,17NS,27NS),
+       CHANGED_LH(CLK,0) & TRN_HL, DELAY(10NS,21NS,32NS),
+       CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,24NS,36NS),
+       DELAY(11NS,25NS,37NS)  ;DEFAULT
+       )
+     }

U164CON CONSTRAINT(4) DPWR DGND
+ CLRBAR CLK A B
+ IO_STD
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HIGH = 20NS
+   MIN_LOW = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LOW = 20NS
+
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(2) A B
+   SETUPTIME = 15NS
+   HOLDTIME = 5NS
+   WHEN = { CLRBAR != '0 }
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 20NS

.ENDS

*---------
*$
* 74173  REGISTERS D-TYPE 4-BIT WITH 3-STATE OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-9-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74173   CLR_I CLK_I G1BAR_I G2BAR_I M_I N_I 1D_I 2D_I 3D_I 4D_I
+ 1Q_O 2Q_O 3Q_O 4Q_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ DFF1  DFF2  DFF3  DFF4
+ 1Q    2Q    3Q    4Q
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF  IO_STD

U173LOG LOGICEXP (14,13) DPWR DGND
+ CLR_I CLK_I G1BAR_I G2BAR_I M_I N_I 1D_I 2D_I 3D_I 4D_I 1Q 2Q 3Q 4Q
+ CLR CLRBAR CLK DATEN OE 1D 2D 3D 4D
+ DFF1 DFF2 DFF3 DFF4
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLR      = { CLR_I }
+   CLRBAR   = { ~CLR }
+   CLK      = { CLK_I }
+   G1BAR    = { G1BAR_I }
+   G2BAR    = { G2BAR_I }
+   M        = { M_I }
+   N        = { N_I }
+   1D       = { 1D_I }
+   2D       = { 2D_I }
+   3D       = { 3D_I }
+   4D       = { 4D_I }
+
+   DATENBAR = { G1BAR | G2BAR }
+   DATEN    = { ~DATENBAR }
+   OE       = { ~(M | N) }
+   DFF1     = { (1D & DATEN) | (1Q & DATENBAR) }
+   DFF2     = { (2D & DATEN) | (2Q & DATENBAR) }
+   DFF3     = { (3D & DATEN) | (3Q & DATENBAR) }
+   DFF4     = { (4D & DATEN) | (4Q & DATENBAR) }

U173DLY PINDLY (4,1,2) DPWR DGND
+ 1Q   2Q   3Q   4Q
+ OE
+ CLR CLK
+ 1Q_O 2Q_O 3Q_O 4Q_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLEARED = { CHANGED_LH(CLR,0) }
+
+ TRISTATE:
+   ENABLE HI OE
+   1Q_O 2Q_O 3Q_O 4Q_O = {
+     CASE (
+       TRN_ZH,  DELAY(7NS,16NS,30NS),
+       TRN_ZL,  DELAY(7NS,21NS,30NS),
+       TRN_HZ,  DELAY(3NS,05NS,14NS),
+       TRN_LZ,  DELAY(3NS,11NS,20NS),
+       CLEARED, DELAY( -1,18NS,27NS),
+       TRN_HL,  DELAY( -1,19NS,31NS),
+       DELAY(-1,28NS,43NS)
+       )
+     }

U173CON CONSTRAINT (7) DPWR DGND
+ CLR CLK DATEN 1D 2D 3D 4D
+ IO_STD
+
+ FREQ:
+   NODE           = CLK
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = CLK
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK LH       = CLK
+   RELEASETIME_HL = 10NS
+ SETUP_HOLD:
+   DATA(1)        = DATEN
+   CLOCK LH       = CLK
+   SETUPTIME      = 17NS
+   HOLDTIME       =  2NS
+   WHEN           = { CLR!='1 }
+ SETUP_HOLD:
+   DATA(4)        = 1D 2D 3D 4D
+   CLOCK LH       = CLK
+   SETUPTIME      = 10NS
+   HOLDTIME       = 10NS
+   WHEN           = { CLR!='1 & (DATEN!='0 ^ CHANGED(DATEN,0)) }

.ENDS

*---------
*$
* 74174  HEX D-TYPE FLIP-FLOPS WITH CLEAR
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	06/27/89	Update interface and model names

.subckt 74174  CLRBAR CLK D1 D2 D3 D4 D5 D6 Q1 Q2 Q3 Q4 Q5 Q6
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UD dff(6) DPWR DGND
+	$D_HI	CLRBAR	CLK
+	D1	D2	D3	D4	D5	D6
+	Q1	Q2	Q3	Q4	Q5	Q6
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_174 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_174 ueff (
+	TWCLKLMN=20NS	TWCLKHMN=20NS
+	TWPCLMN=20NS	TSUDCLKMN=20NS
+	TSUPCCLKHMN=25NS	THDCLKMN=5NS
+	TPPCQHLTY=23NS	TPPCQHLMX=35NS
+	TPCLKQLHTY=20NS	TPCLKQLHMX=30NS
+	TPCLKQHLTY=24NS	TPCLKQHLMX=35NS
+	)
*---------
*$
* 74175  QUADRUPLE D-TYPE FLIP-FLOPS WITH CLEAR
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	06/27/89	Update interface and model names

.subckt 74175  CLRBAR CLK D1 D2 D3 D4 Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UD dff(4) DPWR DGND
+	$D_HI	CLRBAR	CLK
+	D1	D2	D3	D4
+	Q1	Q2	Q3	Q4	Q1BAR	Q2BAR	Q3BAR	Q4BAR
+	D_175 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_175 ueff (
+	TWCLKLMN=20NS	TWCLKHMN=20NS
+	TWPCLMN=20NS	TSUDCLKMN=20NS
+	TSUPCCLKHMN=25NS	THDCLKMN=5NS
+	TPPCQLHTY=16NS	TPPCQLHMX=25NS
+	TPPCQHLTY=23NS	TPPCQHLMX=35NS
+	TPCLKQLHTY=20NS	TPCLKQLHMX=30NS
+	TPCLKQHLTY=24NS	TPCLKQHLMX=35NS
+	)
*---------
*$
* 74176  35MHz Presettable Decade and Binary Counter/Latch
*
* The TTL Data Book, 1988, TI
* JSW   7/31/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices

.SUBCKT 74176 LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U176LOG LOGICEXP(10,17) DPWR DGND
+ LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I QB QC
+ LOADBAR CLRBAR CLK1 CLK2 A B C D JD SA SB SC SD RA RB RC RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LOADBAR = { LOADBAR_I }
+   CLRBAR = { CLRBAR_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~CLRBAR | ~LOADBAR }
+   SA = { ~(A & LOAD & CLRBAR) }
+   SB = { ~(B & LOAD & CLRBAR) }
+   SC = { ~(C & LOAD & CLRBAR) }
+   SD = { ~(D & LOAD & CLRBAR) }
+   RA = { ~(SA & LOAD) }
+   RB = { ~(SB & LOAD) }
+   RC = { ~(SC & LOAD) }
+   RD = { ~(SD & LOAD) }
+   JD = { QB & QC }

UJK1 JKFF(1) DPWR DGND SA RA CLK1 $D_HI $D_HI QA $D_NC D0_EFF IO_STD
UJK2 JKFF(1) DPWR DGND SB RB CLK2 QDBAR QDBAR QB $D_NC	D0_EFF IO_STD
UJK3 JKFF(1) DPWR DGND SC RC QB $D_HI $D_HI QC $D_NC D0_EFF IO_STD
UJK4 JKFF(1) DPWR DGND SD RD CLK2 JD QD QD QDBAR	D0_EFF IO_STD

U176DLY PINDLY(4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 A B C D LOADBAR CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = { CHANGED(CLRBAR,0) }
+   LOAD = { CHANGED(LOADBAR,0) }
+   CLOCK1 = { CHANGED_HL(CLK1,0) }
+   CLOCK2 = { CHANGED_HL(CLK2,0) }
+ PINDLY:
+   QA_O = {
+     CASE(
+       CLOCK1 & TRN_LH, DELAY(-1,8NS,13NS),
+       CLOCK1 & TRN_HL, DELAY(-1,11NS,17NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QB_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,11NS,17NS),
+       CLOCK2 & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QC_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,27NS,41NS),
+       CLOCK2 & TRN_HL, DELAY(-1,34NS,51NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QD_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK2 & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }

U176CON CONSTRAINT(8) DPWR DGND
+ CLK1 CLK2 LOADBAR CLRBAR A B C D
+ IO_STD
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 35MEG
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 17.5MEG
+ WIDTH:
+   NODE = CLK1
+   MIN_HI = 14NS
+ WIDTH:
+   NODE = CLK2
+   MIN_HI = 28NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 25NS
+   WHEN = { CLRBAR!='0 }
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 25NS
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 25NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK HL = LOADBAR
+   SETUPTIME_HI = 15NS
+   SETUPTIME_LO = 20NS
+   HOLDTIME = 25NS
+ GENERAL:
+   WHEN = { LOADBAR=='0 & (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0)
+     | CHANGED(D,0)) }
+   MESSAGE = "Invalid hold time of DATA with respect to LOADBAR."

.ENDS

*---------
*$
* 74177  35MHz Presettable Decade and Binary Counter/Latch
*
* The TTL Data Book, 1988, TI
* JSW   7/31/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices

.SUBCKT 74177 LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U177LOG LOGICEXP(8,16) DPWR DGND
+ LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I
+ LOADBAR CLRBAR CLK1 CLK2 A B C D SA SB SC SD RA RB RC RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LOADBAR = { LOADBAR_I }
+   CLRBAR = { CLRBAR_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~CLRBAR | ~LOADBAR }
+   SA = { ~(A & LOAD & CLRBAR) }
+   SB = { ~(B & LOAD & CLRBAR) }
+   SC = { ~(C & LOAD & CLRBAR) }
+   SD = { ~(D & LOAD & CLRBAR) }
+   RA = { ~(SA & LOAD) }
+   RB = { ~(SB & LOAD) }
+   RC = { ~(SC & LOAD) }
+   RD = { ~(SD & LOAD) }

UJK1 JKFF(1) DPWR DGND SA RA CLK1 $D_HI $D_HI QA $D_NC D0_EFF IO_STD
UJK2 JKFF(1) DPWR DGND SB RB CLK2 $D_HI $D_HI QB $D_NC	D0_EFF IO_STD
UJK3 JKFF(1) DPWR DGND SC RC QB $D_HI $D_HI QC $D_NC D0_EFF IO_STD
UJK4 JKFF(1) DPWR DGND SD RD QC $D_HI $D_HI QD $D_NC	D0_EFF IO_STD

U177DLY PINDLY(4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 A B C D LOADBAR CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = { CHANGED(CLRBAR,0) }
+   LOAD = { CHANGED(LOADBAR,0) }
+   CLOCK1 = { CHANGED_HL(CLK1,0) }
+   CLOCK2 = { CHANGED_HL(CLK2,0) }
+ PINDLY:
+   QA_O = {
+     CASE(
+       CLOCK1 & TRN_LH, DELAY(-1,8NS,13NS),
+       CLOCK1 & TRN_HL, DELAY(-1,11NS,17NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QB_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,11NS,17NS),
+       CLOCK2 & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QC_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,27NS,41NS),
+       CLOCK2 & TRN_HL, DELAY(-1,34NS,51NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QD_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,44NS,66NS),
+       CLOCK2 & TRN_HL, DELAY(-1,50NS,75NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }

U177CON CONSTRAINT(8) DPWR DGND
+ CLK1 CLK2 LOADBAR CLRBAR A B C D
+ IO_STD
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 35MEG
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 17.5MEG
+ WIDTH:
+   NODE = CLK1
+   MIN_HI = 14NS
+ WIDTH:
+   NODE = CLK2
+   MIN_HI = 28NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 25NS
+   WHEN = { CLRBAR!='0 }
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 25NS
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 25NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK HL = LOADBAR
+   SETUPTIME_HI = 15NS
+   SETUPTIME_LO = 20NS
+   HOLDTIME = 25NS
+ GENERAL:
+   WHEN = { LOADBAR=='0 & (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0)
+     | CHANGED(D,0)) }
+   MESSAGE = "Invalid hold time of DATA with respect to LOADBAR."

.ENDS

*--------
*$
* 74178 4-BIT PARALLEL-ACCESS SHIFT REGISTER
*
* THE TTL DATA BOOK, VOL 2, 1988, TI
* NH 6/30/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 74178 SHIFT_I LOAD_I CLK_I SER_I A_I B_I C_I D_I QA_O QB_O QC_O QD_O
+       OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+       PARAMS:   MNTYMXDLY = 0    IO_LEVEL = 0

U178LOG LOGICEXP(12,16) DPWR DGND
+ SHIFT_I LOAD_I CLK_I SER_I A_I B_I C_I D_I QA QB QC QD
+ SHIFT LOAD CLK SER A B C D KA KB KC KD JA JB JC JD
+ D0_GATE IO_STD IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
*
* INTERMEDIATE TERMS:
*
+   LOAD_MODE = { ~SHIFT_I & LOAD_I }
+   HOLD_MODE = { ~SHIFT_I & ~LOAD_I }
*
* OUTPUT ASSIGNMENT
*
+   SHIFT = { SHIFT_I }
+   LOAD = { LOAD_I }
+   CLK = { CLK_I }
+   SER = { SER_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
+   KA = { ~( (SER & SHIFT) | (LOAD_MODE & A) | (HOLD_MODE & QA) ) }
+   KB = { ~( (QA & SHIFT) | (LOAD_MODE & B) | (HOLD_MODE & QB) ) }
+   KC = { ~( (QB & SHIFT) | (LOAD_MODE & C) | (HOLD_MODE & QC) ) }
+   KD = { ~( (QC & SHIFT) | (LOAD_MODE & D) | (HOLD_MODE & QD) ) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }

U1 JKFF(4) DPWR DGND $D_HI $D_HI CLK JA JB JC JD KA KB KC KD
+ QA QB QC QD $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_STD

U178DLY PINDLY(4,0,1) DPWR DGND
+ QA QB QC QD
+ CLK
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY}   IO_LEVEL = {IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+      CASE(
+        CHANGED_HL(CLK,0) & TRN_LH, DELAY(-1,17NS,26NS),
+        CHANGED_HL(CLK,0) & TRN_HL, DELAY(-1,23NS,35NS),
+        DELAY(-1,24NS,36NS)         ;DEFAULT
+        )
+      }

U178CON CONSTRAINT(8) DPWR DGND
+ SHIFT LOAD SER CLK A B C D
+ IO_STD
+
+ BOOLEAN:
+   LOAD_MODE = { SHIFT!='1 ^ CHANGED(SHIFT,0) }
+   SHIFT_MODE = { (SHIFT!='0 ^ CHANGED(SHIFT,0)) }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+
+ SETUP_HOLD:
+   DATA(1) SHIFT
+   CLOCK HL = CLK
+   SETUPTIME = 35NS
+   HOLDTIME = 5NS
+
+ SETUP_HOLD:
+   DATA(1) LOAD
+   CLOCK HL = CLK
+   SETUPTIME = 35NS
+   HOLDTIME = 5NS
+   WHEN = { LOAD_MODE }
+
+ SETUP_HOLD:                          ;IN LOAD MODE
+   DATA(4) A B C D
+   CLOCK HL = CLK
+   SETUPTIME = 30NS
+   HOLDTIME = 5NS
+   WHEN = { LOAD_MODE & (LOAD!='0 ^ CHANGED(LOAD,0)) }
+
+ SETUP_HOLD:                          ;IN SHIFT MODE
+   DATA(1) SER
+   CLOCK HL = CLK
+   SETUPTIME = 30NS
+   HOLDTIME = 5NS
+   WHEN = { SHIFT_MODE }

.ENDS

*--------
*$
* 74179 4-BIT PARALLEL-ACCESS SHIFT REGISTER
*
* THE TTL DATA BOOK, VOL 2, 1985, TI
* NH 7/1/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 74179 CLRBAR_I SHIFT_I LOAD_I CLK_I SER_I A_I B_I C_I D_I
+  QA_O QB_O QC_O QD_O QDBAR_O
+  OPTIONAL: DPWR=$G_DPWR   DGND=$G_DGND
+  PARAMS:   MNTYMXDLY=0    IO_LEVEL=0

U179LOG LOGICEXP(13,17) DPWR DGND
+ CLRBAR_I SHIFT_I LOAD_I CLK_I SER_I A_I B_I C_I D_I QA QB QC QD
+ CLRBAR SHIFT LOAD CLK SER A B C D KA KB KC KD JA JB JC JD
+ D0_GATE  IO_STD  IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*
* INTERMEDIATE TERMS
*
+   LOAD_MODE = { ~SHIFT_I & LOAD_I }
+   HOLD_MODE = { ~SHIFT_I & ~LOAD_I }
*
* OUTPUT ASSIGNMENT
*
+   CLRBAR = { CLRBAR_I }
+   SHIFT = { SHIFT_I }
+   LOAD = { LOAD_I }
+   CLK = { CLK_I }
+   SER = { SER_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
+   KA = { ~((SER & SHIFT) | (LOAD_MODE & A) | (HOLD_MODE & QA)) }
+   KB = { ~((QA & SHIFT) | (LOAD_MODE & B) | (HOLD_MODE & QB)) }
+   KC = { ~((QB & SHIFT) | (LOAD_MODE & C) | (HOLD_MODE & QC)) }
+   KD = { ~((QC & SHIFT) | (LOAD_MODE & D) | (HOLD_MODE & QD)) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }

U1 JKFF(4) DPWR DGND $D_HI CLRBAR CLK JA JB JC JD KA KB KC KD
+ QA QB QC QD $D_NC $D_NC $D_NC QDBAR
+ D0_EFF IO_STD

U179DLY PINDLY(5,0,2) DPWR DGND
+ QA QB QC QD QDBAR
+ CLK CLRBAR
+ QA_O QB_O QC_O QD_O QDBAR_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+      CASE(
+        CHANGED_HL(CLK,0) & TRN_LH, DELAY(-1,17NS,26NS),
+        CHANGED_HL(CLK,0) & TRN_HL, DELAY(-1,23NS,35NS),
+        CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,24NS,36NS),
+        DELAY(-1,25NS,37NS)         ;DEFAULT
+        )
+      }
+
+   QDBAR_O = {
+      CASE(
+        CHANGED_HL(CLRBAR,0) & TRN_LH, DELAY(-1,15NS,23NS),
+        CHANGED_HL(CLK,0) & TRN_LH, DELAY(-1,17NS,26NS),
+        CHANGED_HL(CLK,0) & TRN_HL, DELAY(-1,23NS,35NS),
+        DELAY(-1,24NS,36NS)         ;DEFAULT
+        )
+      }

U179CON CONSTRAINT(9) DPWR PDGND
+ CLRBAR SHIFT LOAD SER CLK A B C D
+ IO_STD
+
+ BOOLEAN:
+   NOT_CLEAR = {CLRBAR!='0}
+   LOAD_MODE = { (SHIFT!='1 ^ CHANGED(SHIFT,0)) }
+   SHIFT_MODE = { (SHIFT!='0 ^ CHANGED(SHIFT,0)) }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK HL = CLK
+   RELEASETIME_LH = 15NS
+
+ SETUP_HOLD:
+   DATA(1) SHIFT
+   CLOCK HL= CLK
+   SETUPTIME = 35NS
+   HOLDTIME = 5NS
+   WHEN = { NOT_CLEAR }
+
+ SETUP_HOLD:
+   DATA(1) LOAD
+   CLOCK HL = CLK
+   SETUPTIME = 35NS
+   HOLDTIME = 5NS
+   WHEN = { NOT_CLEAR & LOAD_MODE }
+
+ SETUP_HOLD:
+   DATA(4) A B C D
+   CLOCK HL = CLK
+   SETUPTIME = 30NS
+   HOLDTIME = 5NS
+   WHEN = { NOT_CLEAR & LOAD_MODE & (LOAD!='0  ^ CHANGED(LOAD,0)) }
+
+ SETUP_HOLD:
+    DATA(1) SER
+    CLOCK HL = CLK
+    SETUPTIME = 30NS
+    HOLDTIME = 5NS
+    WHEN = { NOT_CLEAR & SHIFT_MODE }

.ENDS

*--------
*$
* 74180  PARITY GENERATOR/CHECKER ODD/EVEN 9-BIT
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-17-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74180   A_I B_I C_I D_I E_I F_I G_I H_I EIN_I OIN_I
+ EOUT_O OOUT_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U180LOG LOGICEXP (10,12) DPWR DGND
+ A_I B_I C_I D_I E_I F_I G_I H_I EIN_I OIN_I
+ A   B   C   D   E   F   G   H   EIN   OIN   EOUT OOUT
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   D      = { D_I }
+   E      = { E_I }
+   F      = { F_I }
+   G      = { G_I }
+   H      = { H_I }
+   EIN    = { EIN_I }
+   OIN    = { OIN_I }
+
+   PARITY = { A ^ B ^ C ^ D ^ E ^ F ^ G ^ H }
+   EOUT   = { ~((~PARITY & OIN) | (PARITY & EIN)) }
+   OOUT   = { ~((~PARITY & EIN) | (PARITY & OIN)) }

U180DLY PINDLY (2,0,10) DPWR DGND
+ EOUT   OOUT
+ A B C D E F G H EIN OIN
+ EOUT_O OOUT_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+
+   ADDR    = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) |
+               CHANGED(D,0) | CHANGED(E,0) | CHANGED(F,0) |
+               CHANGED(G,0) | CHANGED(H,0) }
+   ODDGND  = { ADDR & OIN=='0 }
+   EVENGND = { ADDR & EIN=='0 }
+   POLAR   = { CHANGED(EIN,0) | CHANGED(OIN,0) }
+
+ PINDLY:
+   EOUT_O = {
+     CASE (
+       POLAR   & TRN_LH, DELAY(-1,13NS,20NS),
+       POLAR   & TRN_HL, DELAY(-1, 7NS,10NS),
+       EVENGND & TRN_LH, DELAY(-1,32NS,48NS),
+       EVENGND & TRN_HL, DELAY(-1,25NS,38NS),
+       ODDGND  & TRN_LH, DELAY(-1,40NS,60NS),
+       ODDGND  & TRN_HL, DELAY(-1,45NS,68NS),
+       DELAY(-1,45NS,68NS)
+       )
+     }
+
+   OOUT_O = {
+     CASE (
+       POLAR   & TRN_LH, DELAY(-1,13NS,20NS),
+       POLAR   & TRN_HL, DELAY(-1, 7NS,10NS),
+       ODDGND  & TRN_LH, DELAY(-1,32NS,48NS),
+       ODDGND  & TRN_HL, DELAY(-1,25NS,38NS),
+       EVENGND & TRN_LH, DELAY(-1,40NS,60NS),
+       EVENGND & TRN_HL, DELAY(-1,45NS,68NS),
+       DELAY(-1,45NS,68NS)
+       )
+     }

.ENDS

*---------
*$
* 74181  ALU / FUNCTION GENERATOR
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   9-4-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74181   A0BAR_I A1BAR_I A2BAR_I A3BAR_I B0BAR_I B1BAR_I B2BAR_I
+ B3BAR_I S0_I S1_I S2_I S3_I M_I CN_I F0BAR_O F1BAR_O F2BAR_O F3BAR_O
+ AEQUALB_O PBAR_O GBAR_O CN+4_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U181LOG LOGICEXP (14,22) DPWR DGND
+ A0BAR_I A1BAR_I A2BAR_I A3BAR_I B0BAR_I B1BAR_I B2BAR_I B3BAR_I
+ S0_I S1_I S2_I S3_I M_I CN_I
+ A0BAR   A1BAR   A2BAR   A3BAR   B0BAR   B1BAR   B2BAR   B3BAR
+ S0   S1   S2   S3   M   CN
+ F0BAR   F1BAR   F2BAR   F3BAR   AEQUALB PBAR    GBAR    CN+4
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A0BAR   = { A0BAR_I }
+   A1BAR   = { A1BAR_I }
+   A2BAR   = { A2BAR_I }
+   A3BAR   = { A3BAR_I }
+   B0BAR   = { B0BAR_I }
+   B1BAR   = { B1BAR_I }
+   B2BAR   = { B2BAR_I }
+   B3BAR   = { B3BAR_I }
+   S0      = { S0_I }
+   S1      = { S1_I }
+   S2      = { S2_I }
+   S3      = { S3_I }
+   M       = { M_I }
+   CN      = { CN_I }
+
+   TOP3    = { ~( (A3BAR & B3BAR & S3) | (A3BAR & ~B3BAR & S2) ) }
+   BOT3    = { ~(        (~B3BAR & S1) |  A3BAR | (B3BAR & S0) ) }
+   TOP2    = { ~( (A2BAR & B2BAR & S3) | (A2BAR & ~B2BAR & S2) ) }
+   BOT2    = { ~(        (~B2BAR & S1) |  A2BAR | (B2BAR & S0) ) }
+   TOP1    = { ~( (A1BAR & B1BAR & S3) | (A1BAR & ~B1BAR & S2) ) }
+   BOT1    = { ~(        (~B1BAR & S1) |  A1BAR | (B1BAR & S0) ) }
+   TOP0    = { ~( (A0BAR & B0BAR & S3) | (A0BAR & ~B0BAR & S2) ) }
+   BOT0    = { ~(        (~B0BAR & S1) |  A0BAR | (B0BAR & S0) ) }
+   MBAR    = { ~M }
+
+   F3BAR   = { (TOP3 ^ BOT3) ^ ~( (  CN & MBAR & TOP2 & TOP1 & TOP0) |
+                                  (BOT0 & MBAR & TOP2 & TOP1) |
+                                  (BOT1 & MBAR & TOP2) |
+                                  (BOT2 & MBAR) ) }
+   F2BAR   = { (TOP2 ^ BOT2) ^ ~( (  CN & MBAR & TOP1 & TOP0) |
+                                  (BOT0 & MBAR & TOP1) |
+                                  (BOT1 & MBAR) ) }
+   F1BAR   = { (TOP1 ^ BOT1) ^ ~( (  CN & MBAR & TOP0) |
+                                  (BOT0 & MBAR) ) }
+   F0BAR   = { (TOP0 ^ BOT0) ^ ~(    CN & MBAR) }
+   AEQUALB = { F3BAR & F2BAR & F1BAR & F0BAR }
+   PBAR    = { ~(         TOP3 & TOP2 & TOP1 & TOP0) }
+   GBAR    = { ~( (BOT0 & TOP3 & TOP2 & TOP1) |
+                  (BOT1 & TOP3 & TOP2) |
+                  (BOT2 & TOP3) |
+                   BOT3 ) }
+   CN+4    = { ~GBAR | (~PBAR & CN) }

U181DLY PINDLY (7,0,14) DPWR DGND
+ F0BAR   F1BAR   F2BAR   F3BAR   PBAR   GBAR   CN+4
+ A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 M CN
+ F0BAR_O F1BAR_O F2BAR_O F3BAR_O PBAR_O GBAR_O CN+4_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CARRY = { CHANGED(CN,0) }
+   OPER  = { CHANGED(A3BAR,0) | CHANGED(B3BAR,0) |
+             CHANGED(A2BAR,0) | CHANGED(B2BAR,0) |
+             CHANGED(A1BAR,0) | CHANGED(B1BAR,0) |
+             CHANGED(A0BAR,0) | CHANGED(B0BAR,0) }
+   NOTM  = { M=='0 }
+   SUM   = { OPER & NOTM & S0=='1 & S1=='0 & S2=='0 & S3=='1 }
+   DIF   = { OPER & NOTM & S0=='0 & S1=='1 & S2=='1 & S3=='0 }
+
+ PINDLY:
+   F0BAR_O F1BAR_O F2BAR_O F3BAR_O = {
+     CASE (
+       NOTM & CARRY & TRN_LH, DELAY(-1,13NS,19NS),
+       NOTM & CARRY & TRN_HL, DELAY(-1,12NS,18NS),
+       SUM          & TRN_LH, DELAY(-1,28NS,42NS),
+       SUM          & TRN_HL, DELAY(-1,21NS,32NS),
+                      TRN_LH, DELAY(-1,32NS,48NS),
+                      TRN_HL, DELAY(-1,23NS,34NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   PBAR_O = {
+     CASE (
+       SUM & TRN_LH, DELAY(-1,13NS,19NS),
+       DELAY(-1,17NS,25NS)
+       )
+     }
+   GBAR_O = {
+     CASE (
+       SUM , DELAY(-1,13NS,19NS),
+       DELAY(-1,17NS,25NS)
+       )
+     }
+   CN+4_O = {
+     CASE (
+       CARRY & TRN_LH, DELAY(-1,12NS,18NS),
+       CARRY & TRN_HL, DELAY(-1,13NS,19NS),
+       SUM   & TRN_LH, DELAY(-1,28NS,43NS),
+       SUM   & TRN_HL, DELAY(-1,27NS,41NS),
+       DIF   & TRN_LH, DELAY(-1,35NS,50NS),
+       DIF   & TRN_HL, DELAY(-1,33NS,50NS),
+       DELAY(-1,35NS,50NS)
+       )
+     }

U181DLY_OC PINDLY (1,0,13) DPWR DGND
+ AEQUALB
+ A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 M
+ AEQUALB_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   OPER = { CHANGED(A3BAR,0) | CHANGED(B3BAR,0) |
+            CHANGED(A2BAR,0) | CHANGED(B2BAR,0) |
+            CHANGED(A1BAR,0) | CHANGED(B1BAR,0) |
+            CHANGED(A0BAR,0) | CHANGED(B0BAR,0) }
+   NOTM = { M=='0 }
+   DIF  = { OPER & NOTM & S0=='0 & S1=='1 & S2=='1 & S3=='0 }
+
+ PINDLY:
+   AEQUALB_O = {
+     CASE (
+       DIF  & TRN_HL, DELAY(-1,32NS,48NS),
+       DELAY(-1,35NS,50NS)
+       )
+     }

.ENDS

*---------
*$
* 74182  LOOK-AHEAD CARRY GENERATOR
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   9-17-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74182   G3BAR_I G2BAR_I G1BAR_I G0BAR_I
+ P3BAR_I P2BAR_I P1BAR_I P0BAR_I CN_I GBAR_O PBAR_O CN+X_O CN+Y_O CN+Z_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U182LOG LOGICEXP (9,5) DPWR DGND
+ G3BAR_I G2BAR_I G1BAR_I G0BAR_I P3BAR_I P2BAR_I P1BAR_I P0BAR_I CN_I
+ GBAR PBAR CN+X CN+Y CN+Z
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G3BAR = { G3BAR_I }
+   G2BAR = { G2BAR_I }
+   G1BAR = { G1BAR_I }
+   G0BAR = { G0BAR_I }
+   P3BAR = { P3BAR_I }
+   P2BAR = { P2BAR_I }
+   P1BAR = { P1BAR_I }
+   P0BAR = { P0BAR_I }
+   CN    = { CN_I }
+   CNBAR = { ~CN }
+   PBAR  = { P0BAR | P1BAR | P2BAR | P3BAR }
+   GBAR  = {    (        G0BAR & G1BAR & G2BAR & G3BAR) |
+                (P1BAR         & G1BAR & G2BAR & G3BAR) |
+                (P2BAR                 & G2BAR & G3BAR) |
+                (P3BAR                         & G3BAR) }
+   CN+Z  = { ~( (CNBAR & G0BAR & G1BAR & G2BAR) |
+                (P0BAR & G0BAR & G1BAR & G2BAR) |
+                (P1BAR         & G1BAR & G2BAR) |
+                (P2BAR                 & G2BAR) ) }
+   CN+Y  = { ~( (CNBAR & G0BAR & G1BAR) |
+                (P0BAR & G0BAR & G1BAR) |
+                (P1BAR         & G1BAR) ) }
+   CN+X  = { ~( (CNBAR & G0BAR) |
+                (P0BAR & G0BAR) ) }

U182DLY PINDLY (5,0,0) DPWR DGND
+ GBAR   PBAR   CN+X   CN+Y   CN+Z
+ GBAR_O PBAR_O CN+X_O CN+Y_O CN+Z_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   GBAR_O PBAR_O CN+X_O CN+Y_O CN+Z_O = {
+     CASE (
+       TRN_LH, DELAY(-1,11NS,17NS),
+       TRN_HL, DELAY(-1,15NS,22NS),
+       DELAY(-1,15NS,22NS)
+       )
+     }

.ENDS

*---------
*$
* 74184  BCD-TO-BINARY CONVERTERS
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	09/12/89  	Update interface and model names

.subckt 74184  GBAR A B C D E Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(5) DPWR DGND
+	A	B	C	D	E
+	AI	BI	CI	DI	EI
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2 inva(5) DPWR DGND
+	AI	BI	CI	DI	EI
+	AN	BN	CN	DN	EN
+	D0_GATE IO_STD
U3 ao(3,3) DPWR DGND
+	AI	CN	DN
+	AN	CN	DI
+	AN	BN	DI
+	X1
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U4 ao(5,6) DPWR DGND
+	AN	BN	EI	$D_HI	$D_HI
+	CN	BN	EI	DN	$D_HI
+	CN	BI	EN	DN	$D_HI
+	CN	BI	AN	EN	$D_HI
+	CN	BN	AI	EN	DI
+	CN	BI	AI	EI	DI
+	X2
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U5 ao(4,5) DPWR DGND
+	AN	BN	CI	DN
+	BI	CN	EI	DN
+	AN	BN	CN	DI
+	BN	CN	EN	DI
+	AN	CN	EN	DI
+	X3
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U6 ao(5,5) DPWR DGND
+	CN	EI	DN	$D_HI	$D_HI
+	AN	BN	CN	EI	$D_HI
+	AN	BN	EI	DN	$D_HI
+	AN	BN	CI	EN	DI
+	AI	BI	CN	EN	DI
+	X4
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U7 ao(5,3) DPWR DGND
+	BI	CN	EI	DI	$D_HI
+	AI	CN	EI	DI	$D_HI
+	AN	BN	CI	EI	DI
+	X5
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U8 ao(4,4) DPWR DGND
+	AN	BN	CN	DI
+	AN	EN	DN	$D_HI
+	AI	BI	EI	DN
+	AN	BN	CI	DN
+	X6
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U9 ao(4,4) DPWR DGND
+	CI	BN	DN	$D_HI
+	CN	BI	EN	DN
+	AN	CI	EI	DN
+	AI	BI	CN	DN
+	X7
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U10 ao(5,3) DPWR DGND
+	CN	BN	EN	DN	$D_HI
+	AI	BN	CN	DN	$D_HI
+	AN	BI	CN	EI	DN
+	X8
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U11 ora(2,8) DPWR DGND
+	GBAR	X1
+	GBAR	X2
+	GBAR	X3
+	GBAR	X4
+	GBAR	X5
+	GBAR	X6
+	GBAR	X7
+	GBAR	X8
+	Y1	Y2	Y3	Y4	Y5	Y6	Y7	Y8
+	D_184_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_184_1 ugate (
+	TPLHTY=8NS	TPHLTY=1NS
+	TPLHMX=10NS	TPHLMX=5NS
+	)
.model D_184_2 ugate (
+	TPLHTY=19NS	TPHLTY=22NS
+	TPLHMX=30NS	TPHLMX=35NS
+	)
*--------
*$
* 74185A  BINARY-TO-BCD CONVERTERS
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	09/12/89  	Update interface and model names

.subckt 74185A  GBAR A B C D E Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(5) DPWR DGND
+	A	B	C	D	E
+	AI	BI	CI	DI	EI
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2 inva(5) DPWR DGND
+	AI	BI	CI	DI	EI
+	AN	BN	CN	DN	EN
+	D0_GATE IO_STD
U3 ao(5,10) DPWR DGND
+	AN	BI	CN	EI	$D_HI
+	AN	CN	DN	EI	$D_HI
+	AI	CN	DN	EN	$D_HI
+	AI	CI	DN	EI	$D_HI
+	AI	BI	CI	EI	$D_HI
+	AI	BI	CN	EN	$D_HI
+	AN	BI	CI	DN	EN
+	AI	BN	CI	DI	EN
+	AN	BN	CI	DI	EI
+	AN	BN	CN	DI	EN
+	X1
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U4 ao(5,8) DPWR DGND
+	BI	CN	DN	EN	$D_HI
+	AI	BI	CI	DN	$D_HI
+	AN	BI	DN	EI	$D_HI
+	AN	BN	CI	DI	$D_HI
+	BN	CI	DI	EN	$D_HI
+	AN	BN	DI	EN	$D_HI
+	AI	BI	CN	DI	EI
+	AI	BN	CN	DN	EI
+	X2
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U5 ao(5,6) DPWR DGND
+	AN	BN	CI	DN	EN
+	AI	BN	CN	DI	EN
+	AN	BI	CI	DI	EN
+	AN	BN	CN	DI	EI
+	AI	BN	CI	DI	EI
+	AI	BI	CN	DN	EI
+	X3
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U6 ao(4,8) DPWR DGND
+	CN	DN	EI	$D_HI
+	BI	CN	EI	$D_HI
+	BN	CI	EI	DI
+	AI	CN	EI	$D_HI
+	BN	CN	DI	EN
+	AI	CI	EN	DN
+	BI	CI	EN	DN
+	AI	BI	CI	EN
+	X4
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U7 ao(3,4) DPWR DGND
+	CN	DN	EI
+	CI	DI	EN
+	BI	DI	EN
+	BI	CI	DI
+	X5
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U8 ao(2,2) DPWR DGND
+	CI EI EI DI   X6
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U9 bufa(2) DPWR DGND
+	$D_HI $D_HI   X7 X8
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY}
U10 ora(2,8) DPWR DGND
+	GBAR	X1
+	GBAR	X2
+	GBAR	X3
+	GBAR	X4
+	GBAR	X5
+	GBAR	X6
+	GBAR	X7
+	GBAR	X8
+	Y1	Y2	Y3	Y4	Y5	Y6	Y7	Y8
+	D_185A_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_185A_1 ugate (
+	TPLHTY=8NS	TPHLTY=1NS
+	TPLHMX=10NS	TPHLMX=5NS
+	)
.model D_185A_2 ugate (
+	TPLHTY=19NS	TPHLTY=22NS
+	TPLHMX=30NS	TPHLMX=35NS
+	)

*---------
*$
* 74194  4-BIT BIDIRECTIONAL UNIVERSAL SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1988, TI
* NH 7/7/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 74194 CLK_I CLRBAR_I S1_I S0_I SL_I SR_I A_I B_I C_I D_I
+             QA_O QB_O QC_O QD_O
+       OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+       PARAMS:   MNTYMXDLY = 0    IO_LEVEL = 0

U194LOG LOGICEXP(14,19) DPWR DGND
+ CLK_I CLRBAR_I S1_I S0_I SL_I SR_I A_I B_I C_I D_I QA QB QC QD
+ CLK CLRBAR S1 S0 SL SR A B C D KA KB KC KD JA JB JC JD CLOCK
+ D0_GATE  IO_STD  IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
*
* INTERMEDIATE TERM
+   S0BAR = { ~S0_I }
+   S1BAR = { ~S1_I }
+   MODE = { ~( S0BAR | S1BAR ) }
*
* OUTPUT ASSIGNMENT
*
+   CLK = { CLK_I }
+   CLRBAR = { CLRBAR_I }
+   S1 = { S1_I }
+   S0 = { S0_I }
+   SL = { SL_I }
+   SR = { SR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
+   KA = { ~( (SR & S1BAR) | (MODE & A) | (S0BAR & QB) ) }
+   KB = { ~( (QA & S1BAR) | (MODE & B) | (S0BAR & QC) ) }
+   KC = { ~( (QB & S1BAR) | (MODE & C) | (S0BAR & QD) ) }
+   KD = { ~( (QC & S1BAR) | (MODE & D) | (S0BAR & SL) ) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
+   CLOCK = { ~( (S0BAR & S1BAR) | CLK ) }

U1 JKFF(4) DPWR DGND $D_HI CLRBAR CLOCK JA JB JC JD KA KB KC KD
+ QA QB QC QD $D_NC $D_NC $D-NC $D_NC
+ D0_EFF  IO_STD

U194DLY PINDLY(4,0,2) DPWR DGND
+ QA QB QC QD
+ CLK CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY}   IO_LEVEL = {IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CHANGED_LH(CLK,0) & TRN_LH, DELAY(-1,14NS,22NS),
+       CHANGED_LH(CLK,0) & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,19NS,30NS),
+       DELAY(8NS,20NS,31NS)          ;DEFAULT
+       )
+     }

U194CON CONSTRAINT(10) DPWR DGND
+ CLK CLRBAR S0 S1 SL SR A B C D
+ IO_STD
+
+ BOOLEAN:
+   NOT_CLEAR = { CLRBAR!='0 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(2) S0 S1
+   CLOCK LH = CLK
+   SETUPTIME = 30NS
+   WHEN = { NOT_CLEAR }
+
+ SETUP_HOLD:
+   DATA(1) SL
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (S1!='0 ^ CHANGED(S1,0)) & (S0!='1 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(1) SR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (S1!='1 ^ CHANGED(S1,0)) & (S0!='0 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(4) A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (S1!='0 ^ CHANGED(S1,0)) & (S0!='0 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 25NS

.ENDS

*---------
*$
* 74195  4-BIT PARALLEL-ACCESS SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1988, STANDARD, LS, S, TI
* NH 7/2/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 74195 CLK_I SH/LDBAR_I CLRBAR_I J_I KBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O QDBAR_O
+ OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0   IO_LEVEL = 0

U195LOG LOGICEXP(13,18) DPWR DGND
+ CLK_I SH/LDBAR_I CLRBAR_I J_I KBAR_I A_I B_I C_I D_I QA QB QC QABAR
+ CLK SH/LDBAR CLRBAR J KBAR A B C D KA KB KC KD JA JB JC JD CLOCK
+ D0_GATE  IO_STD  IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   CLK = { CLK_I }
+   SH/LDBAR = { SH/LDBAR_I }
+   CLRBAR = { CLRBAR_I }
+   J = { J_I }
+   KBAR = { KBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
* INTERMEDIATE TERM
+   LOAD = { ~SH/LDBAR }
+
+   KA = { ~((QABAR & J & SH/LDBAR) | (SH/LDBAR & KBAR & QA) | (LOAD & A)) }
+   KB = { ~( (QA & SH/LDBAR) | (LOAD & B) ) }
+   KC = { ~( (QB & SH/LDBAR) | (LOAD & C) ) }
+   KD = { ~( (QC & SH/LDBAR) | (LOAD & D) ) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
+   CLOCK = { ~(CLK & CLRBAR) }

U1 JKFF(4) DPWR DGND $D_HI CLRBAR CLOCK JA JB JC JD KA KB KC KD
+ QA QB QC QD QABAR $D_NC $D_NC QDBAR
+ D0_EFF   IO_STD

U195DLY PINDLY(5,0,2) DPWR DGND
+ QA QB QC QD QDBAR
+ CLK CLRBAR
+ QA_O QB_O QC_O QD_O QDBAR_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY}   IO_LEVEL = {IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O QDBAR_O = {
+     CASE(
+       CHANGED_LH(CLK,0) & TRN_LH, DELAY(-1,14NS,22NS),
+       CHANGED_LH(CLK,0) & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,19NS,30NS),
+       DELAY(-1,20NS,31NS)            ;DEFAULT
+       )
+     }

U195CON CONSTRAINT(9) DPWR DGND
+ CLK CLRBAR SH/LDBAR J KBAR A B C D
+ IO_STD
+
+ BOOLEAN:
+   NOT_CLEAR = { CLRBAR!='0 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 30MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 16NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 12NS
+
+ SETUP_HOLD:
+   DATA(1) SH/LDBAR
+   CLOCK LH = CLK
+   SETUPTIME_LO = 25NS
+   SETUPTIME_HI = 10NS
+   WHEN = { NOT_CLEAR }
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 25NS
+
+ SETUP_HOLD:                          ;SHIFT MODE
+   DATA(2) J KBAR                     ;CHECK WHEN SH/LDBAR = 1 OR
+   CLOCK LH = CLK                     ;AT THE TRANSITION FROM H TO L
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (SH/LDBAR!='0 ^ CHANGED(SH/LDBAR,0)) }
+
+ SETUP_HOLD:                          ;LOAD MODE
+   DATA(4) A B C D                    ;CHECK WHEN SH/LDBAR = 0 OR
+   CLOCK LH = CLK                     ;AT THE TRANSITION FROM L TO H
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (SH/LDBAR!='1 ^ CHANGED(SH/LDBAR,0)) }

.ENDS

*---------
*$
* 74196  4-Bit Presettable Decade Counter/Latch
*
* The TTL Data Book, 1988, TI
* JSW   8/3/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices

.SUBCKT 74196 LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U196LOG LOGICEXP(10,17) DPWR DGND
+ LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I QB QC
+ LOADBAR CLRBAR CLK1 CLK2 A B C D JD SA SB SC SD RA RB RC RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LOADBAR = { LOADBAR_I }
+   CLRBAR = { CLRBAR_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~CLRBAR | ~LOADBAR }
+   SA = { ~(A & LOAD & CLRBAR) }
+   SB = { ~(B & LOAD & CLRBAR) }
+   SC = { ~(C & LOAD & CLRBAR) }
+   SD = { ~(D & LOAD & CLRBAR) }
+   RA = { ~(SA & LOAD) }
+   RB = { ~(SB & LOAD) }
+   RC = { ~(SC & LOAD) }
+   RD = { ~(SD & LOAD) }
+   JD = { QB & QC }

UJK1 JKFF(1) DPWR DGND SA RA CLK1 $D_HI $D_HI QA $D_NC D0_EFF IO_STD
UJK2 JKFF(1) DPWR DGND SB RB CLK2 QDBAR QDBAR QB $D_NC D0_EFF IO_STD
UJK3 JKFF(1) DPWR DGND SC RC QB $D_HI $D_HI QC $D_NC D0_EFF IO_STD
UJK4 JKFF(1) DPWR DGND SD RD CLK2 JD QD QD QDBAR D0_EFF IO_STD

U196DLY PINDLY(4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 A B C D LOADBAR CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = { CHANGED(CLRBAR,0) }
+   LOAD = { CHANGED(LOADBAR,0) }
+   CLOCK1 = { CHANGED_HL(CLK1,0) }
+   CLOCK2 = { CHANGED_HL(CLK2,0) }
+ PINDLY:
+   QA_O = {
+     CASE(
+       CLOCK1 & TRN_LH, DELAY(-1,7NS,12NS),
+       CLOCK1 & TRN_HL, DELAY(-1,10NS,15NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }
+   QB_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,12NS,18NS),
+       CLOCK2 & TRN_HL, DELAY(-1,14NS,21NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }
+   QC_O = {
+     CASE(
+       CHANGED(C,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLOCK2 & TRN_LH, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       CLOCK2 & TRN_HL, DELAY(-1,28NS,42NS),
+       DELAY(-1,28NS,42NS)
+       )
+     }
+   QD_O = {
+     CASE(
+       CLOCK2 & TRN_HL, DELAY(-1,12NS,18NS),
+       CLOCK2 & TRN_LH, DELAY(-1,14NS,21NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }

U196CON CONSTRAINT(8) DPWR DGND
+ CLK1 CLK2 LOADBAR CLRBAR A B C D
+ IO_STD
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 50MEG
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK1
+   MIN_LO = 10NS
+   MIN_HI = 10NS
+ WIDTH:
+   NODE = CLK2
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 20NS
+   WHEN = { CLRBAR!='0 }
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 15NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 20NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 20NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK HL = LOADBAR
+   SETUPTIME_HI = 10NS
+   SETUPTIME_LO = 15NS
+   HOLDTIME = 20NS
+ GENERAL:
+   WHEN = { LOADBAR=='0 & (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0)
+     | CHANGED(D,0)) }
+   MESSAGE = "Invalid hold time of DATA with respect to LOADBAR."

.ENDS

*---------
*$
* 74197  4-Bit Presettable Binary Counter/Latch
*
* The TTL Data Book, 1988, TI
* JSW   7/31/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices

.SUBCKT 74197 LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U197LOG LOGICEXP(8,16) DPWR DGND
+ LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I
+ LOADBAR CLRBAR CLK1 CLK2 A B C D SA SB SC SD RA RB RC RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LOADBAR = { LOADBAR_I }
+   CLRBAR = { CLRBAR_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~CLRBAR | ~LOADBAR }
+   SA = { ~(A & LOAD & CLRBAR) }
+   SB = { ~(B & LOAD & CLRBAR) }
+   SC = { ~(C & LOAD & CLRBAR) }
+   SD = { ~(D & LOAD & CLRBAR) }
+   RA = { ~(SA & LOAD) }
+   RB = { ~(SB & LOAD) }
+   RC = { ~(SC & LOAD) }
+   RD = { ~(SD & LOAD) }

UJK1 JKFF(1) DPWR DGND SA RA CLK1 $D_HI $D_HI QA $D_NC D0_EFF IO_STD
UJK2 JKFF(1) DPWR DGND SB RB CLK2 $D_HI $D_HI QB $D_NC D0_EFF IO_STD
UJK3 JKFF(1) DPWR DGND SC RC QB $D_HI $D_HI QC $D_NC D0_EFF IO_STD
UJK4 JKFF(1) DPWR DGND SD RD QC $D_HI $D_HI QD $D_NC    D0_EFF IO_STD

U197DLY PINDLY(4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 A B C D LOADBAR CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = { CHANGED(CLRBAR,0) }
+   LOAD = { CHANGED(LOADBAR,0) }
+   CLOCK1 = { CHANGED_HL(CLK1,0) }
+   CLOCK2 = { CHANGED_HL(CLK2,0) }
+ PINDLY:
+   QA_O = {
+     CASE(
+       CLOCK1 & TRN_LH, DELAY(-1,7NS,12NS),
+       CLOCK1 & TRN_HL, DELAY(-1,10NS,15NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }
+   QB_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,12NS,18NS),
+       CLOCK2 & TRN_HL, DELAY(-1,14NS,21NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }
+   QC_O = {
+     CASE(
+       CHANGED(C,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLOCK2 & TRN_LH, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       CLOCK2 & TRN_HL, DELAY(-1,28NS,42NS),
+       DELAY(-1,28NS,42NS)
+       )
+     }
+   QD_O = {
+     CASE(
+       CHANGED(D,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       CLOCK2 & TRN_LH, DELAY(-1,36NS,54NS),
+       CLOCK2 & TRN_HL, DELAY(-1,42NS,63NS),
+       DELAY(-1,42NS,63NS)
+       )
+     }

U197CON CONSTRAINT(8) DPWR DGND
+ CLK1 CLK2 LOADBAR CLRBAR A B C D
+ IO_STD
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 50MEG
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK1
+   MIN_LO = 10NS
+   MIN_HI = 10NS
+ WIDTH:
+   NODE = CLK2
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 20NS
+   WHEN = { CLRBAR!='0 }
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 15NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 20NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 20NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK HL = LOADBAR
+   SETUPTIME_HI = 10NS
+   SETUPTIME_LO = 15NS
+   HOLDTIME = 20NS
+   WHEN = { CLRBAR!='0 }
+ GENERAL:
+   WHEN = { LOADBAR=='0 & (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0)
+     | CHANGED(D,0)) }
+   MESSAGE = "Invalid hold time of DATA with respect to LOADBAR."

.ENDS

*---------
*$
* 74246  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN-COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74246   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

X1   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O   DPWR DGND   74247
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.ENDS

*--------
*$
* 74247  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74247   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}

U247LOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { (BBI & DBI) | (ALT & BLT & CBI) | (ABI & BLT & CLT & DLT) }
+   OUTB   = { (BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI) }
+   OUTC   = { (CBI & DBI) | (ALT & BBI & CLT) }
+   OUTD   = { (ABI & BLT & CLT & DLT) | (ALT & BLT & CBI) |
+              (ABI & BBI & CBI) }
+   OUTE   = {  ABI | (BLT & CBI) }
+   OUTF   = { (ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT) }
+   OUTG   = { (ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR) }

U247DLY_OC PINDLY (7,0,0) DPWR DGND
+ OUTA   OUTB   OUTC   OUTD   OUTE   OUTF   OUTG
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }

.ENDS
*--------
*$
* 74248  DECODER/DRIVER BCD-7 SEGMENT WITH INTERNAL PULLUPS
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74248   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}

U248LOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { ~((BBI & DBI) | (ALT & BLT & CBI) | (ABI & BLT & CLT & DLT)) }
+   OUTB   = { ~((BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI)) }
+   OUTC   = { ~((CBI & DBI) | (ALT & BBI & CLT)) }
+   OUTD   = { ~((ABI & BLT & CLT & DLT) | (ALT & BLT & CBI) |
+                (ABI & BBI & CBI)) }
+   OUTE   = { ~( ABI | (BLT & CBI)) }
+   OUTF   = { ~((ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT)) }
+   OUTG   = { ~((ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR)) }

U248DLY PINDLY (7,0,0) DPWR DGND
+ OUTA   OUTB   OUTC   OUTD   OUTE   OUTF   OUTG
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }

.ENDS
*--------
*$
* 74249  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN-COLLECTOR OUTPUTS
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74249   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}

U249LOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { ~((BBI & DBI) | (ALT & BLT & CBI) | (ABI & BLT & CLT & DLT)) }
+   OUTB   = { ~((BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI)) }
+   OUTC   = { ~((CBI & DBI) | (ALT & BBI & CLT)) }
+   OUTD   = { ~((ABI & BLT & CLT & DLT) | (ALT & BLT & CBI) |
+                (ABI & BBI & CBI)) }
+   OUTE   = { ~( ABI | (BLT & CBI)) }
+   OUTF   = { ~((ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT)) }
+   OUTG   = { ~((ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR)) }

U249DLY_OC PINDLY (7,0,0) DPWR DGND
+ OUTA   OUTB   OUTC   OUTD   OUTE   OUTF   OUTG
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }

.ENDS
*--------
*$
* 74251  MULTIPLEXER/DATA SELECTOR 8-1 LINE WITH 3-STATE OUTPUTS
*
* THE TTL DATA BOOK, 1988, TI
* TC  08/24/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES

.SUBCKT 74251 GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ Y_O W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U251LOG LOGICEXP(12,14) DPWR DGND
+ GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ GBAR A B C D0 D1 D2 D3 D4 D5 D6 D7 W Y
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D0 = { D0_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   D3 = { D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   IG = { ~GBAR }
+   ID0 = { D0 & IA & IB & IC & IG }
+   ID1 = { D1 & A & IB & IC & IG }
+   ID2 = { D2 & IA & B & IC & IG }
+   ID3 = { D3 & A & B & IC & IG }
+   ID4 = { D4 & IA & IB & C & IG }
+   ID5 = { D5 & A & IB & C & IG }
+   ID6 = { D6 & IA & B & C & IG }
+   ID7 = { D7 & A & B & C & IG }
+   W = { ~(ID0 | ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7) }
+   Y = { ~W }

U251DLY PINDLY(2,1,11) DPWR DGND
+ W Y
+ GBAR
+ A B C D0 D1 D2 D3 D4 D5 D6 D7
+ W_O Y_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+     CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+ TRISTATE:
+   ENABLE LO GBAR
+   Y_O = {
+     CASE(
+       SELECT & TRN_LH, DELAY(-1,29NS,45NS),
+       SELECT & TRN_HL, DELAY(-1,28NS,45NS),
+       TRN_ZL, DELAY(-1,26NS,40NS),
+       DATA & TRN_HL, DELAY(-1,18NS,28NS),
+       DATA & TRN_LH, DELAY(-1,17NS,28NS),
+       TRN_ZH, DELAY(-1,17NS,27NS),
+       TRN_LZ, DELAY(-1,15NS,23NS),
+       TRN_HZ, DELAY(-1,5NS,8NS),
+       DELAY(-1,30NS,46NS)
+       )
+     }
+   W_O = {
+     CASE(
+       TRN_ZL, DELAY(-1,24NS,40NS),
+       SELECT & TRN_HL, DELAY(-1,21NS,33NS),
+       SELECT & TRN_LH, DELAY(-1,20NS,33NS),
+       TRN_ZH, DELAY(-1,17NS,27NS),
+       TRN_LZ, DELAY(-1,15NS,23NS),
+       DATA & TRN_LH, DELAY(-1,10NS,15NS),
+       DATA & TRN_HL, DELAY(-1,9NS,15NS),
+       TRN_HZ, DELAY(-1,5NS,8NS),
+       DELAY(-1,25NS,41NS)
+       )
+     }

.ENDS

*---------
*$
* 74259  8-BIT ADDRESSABLE LATCHES
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	09/11/89	Update interface and model names

.subckt 74259  CLRBAR GBAR D S0 S1 S2 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(3) DPWR DGND
+	CLRBAR GBAR D   RB GB DATA
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U2 bufa(3) DPWR DGND
+	S0 S1 S2   SA SB SC
+	D_259_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U3 inva(3) DPWR DGND
+	SA SB SC   AB BB CB
+	D0_GATE IO_STD
U4 nanda(3,8) DPWR DGND
+	AB	BB	CB
+	SA	BB	CB
+	AB	SB	CB
+	SA	SB	CB
+	AB	BB	SC
+	SA	BB	SC
+	AB	SB	SC
+	SA	SB	SC
+	T0	T1	T2	T3	T4	T5	T6	T7
+	D0_GATE IO_STD
U5 nora(2,8) DPWR DGND
+	GB	T0
+	GB	T1
+	GB	T2
+	GB	T3
+	GB	T4
+	GB	T5
+	GB	T6
+	GB	T7
+	G0	G1	G2	G3	G4	G5	G6	G7
+	D0_GATE IO_STD
U6 ora(2,8) DPWR DGND
+	G0	RB
+	G1	RB
+	G2	RB
+	G3	RB
+	G4	RB
+	G5	RB
+	G6	RB
+	G7	RB
+	R0	R1	R2	R3	R4	R5	R6	R7
+	D0_GATE IO_STD
U7 dltch(1) DPWR DGND
+	$D_HI R0 G0   DATA   Q0 $D_NC
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U8 dltch(1) DPWR DGND
+	$D_HI R1 G1   DATA   Q1 $D_NC
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U9 dltch(1) DPWR DGND
+	$D_HI R2 G2   DATA   Q2 $D_NC
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U10 dltch(1) DPWR DGND
+	$D_HI R3 G3   DATA   Q3 $D_NC
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U11 dltch(1) DPWR DGND
+	$D_HI R4 G4   DATA   Q4 $D_NC
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U12 dltch(1) DPWR DGND
+	$D_HI R5 G5   DATA   Q5 $D_NC
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U13 dltch(1) DPWR DGND
+	$D_HI R6 G6   DATA   Q6 $D_NC
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U14 dltch(1) DPWR DGND
+	$D_HI R7 G7   DATA   Q7 $D_NC
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_259_1 ugate (
+	TPLHTY=6NS	TPLHMX=8NS
+	TPHLTY=6NS	TPHLMX=8NS
+	)
.model D_259_2 ugff (
+	TWGHMN=15NS	TWPCLMN=15NS
+	TSUDGMN=15NS	TPPCQHLTY=16NS
+	TPPCQHLMX=25NS	TPDQLHTY=14NS
+	TPDQLHMX=24NS	TPDQHLTY=11NS
+	TPDQHLMX=20NS	TPGQLHTY=12NS
+	TPGQLHMX=20NS	TPGQHLTY=11NS
+	TPGQHLMX=20NS
+	)
*----------
*$
* 74265  QUAD. COMPLEMENTARY-OUTPUT ELEMENTS
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	07/5/89  	Update interface and model names

.subckt 74265  1A 1W 1Y 2A 2B 2W 2Y 3A 3B 3W 3Y 4A 4W 4Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(6) DPWR DGND
+	1A	2A	2B	3A	3B	4A
+	1A_BUF	2A_BUF	2B_BUF	3A_BUF	3B_BUF	4A_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 bufa(2) DPWR DGND
+	1A_BUF 4A_BUF   1W 4W
+	D_265_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U2 inva(2) DPWR DGND
+	1A_BUF 4A_BUF   1Y 4Y
+	D_265_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U3 anda(2,2) DPWR DGND
+	2A_BUF 2B_BUF 3A_BUF 3B_BUF   2W 3W
+	D_265_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U4 nanda(2,2) DPWR DGND
+	2A_BUF 2B_BUF 3A_BUF 3B_BUF   2Y 3Y
+	D_265_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_265_1 ugate (
+	TPLHTY=11.6NS	TPLHMX=18NS
+	TPHLTY=9.8NS	TPHLMX=18NS
+	)
.model D_265_2 ugate (
+	TPLHTY=10.2NS	TPLHMX=18NS
+	TPHLTY=11.3NS	TPHLMX=18NS
+	)
.model D_265_3 ugate (
+	TPLHTY=11.6NS	TPLHMX=18NS
+	TPHLTY=9.8NS	TPHLMX=18NS
+	)
.model D_265_4 ugate (
+	TPLHTY=10.2NS	TPLHMX=18NS
+	TPHLTY=11.3NS	TPHLMX=18NS
+	)
*--------
*$
* 74273  OCTAL D-TYPE EDGE-TRIGGERED FLIP-FLOPS WITH CLEAR
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	07/5/89  	Update interface and model names

.subckt 74273  CLRBAR CLK D1 D2 D3 D4 D5 D6 D7 D8 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UD dff(8) DPWR DGND
+	$D_HI	CLRBAR	CLK
+	D1	D2	D3	D4	D5	D6	D7	D8
+	Q1	Q2	Q3	Q4	Q5	Q6	Q7	Q8
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_273 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_273 ueff (
+	TWCLKLMN=16.5NS	TWCLKHMN=16.5NS
+	TWPCLMN=16.5NS	TSUDCLKMN=20NS
+	TSUPCCLKHMN=25NS	THDCLKMN=5NS
+	TPPCQHLTY=18NS	TPPCQHLMX=27NS
+	TPCLKQLHTY=17NS	TPCLKQLHMX=27NS
+	TPCLKQHLTY=18NS	TPCLKQHLMX=27NS
+	)
*---------
*$
* 74276  QUADRUPLE J-K FLIP-FLOPS
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	07/5/89  	Update interface and model names

.subckt 74276  PREBAR CLRBAR CLK1 CLK2 CLK3 CLK4 J1 J2 J3 J4 KBAR1 KBAR2 KBAR3
+	KBAR4 Q1 Q2 Q3 Q4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	PREBAR CLRBAR   PREB CLRB
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
UK inva(4) DPWR DGND
+	KBAR1 KBAR2 KBAR3 KBAR4   K1 K2 K3 K4
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 jkff(1) DPWR DGND
+	PREB CLRB CLK1   J1 K1   Q1 Q1BAR
+	D_276 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U2 jkff(1) DPWR DGND
+	PREB CLRB CLK2   J2 K2   Q2 Q2BAR
+	D_276 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U3 jkff(1) DPWR DGND
+	PREB CLRB CLK3   J3 K3   Q3 Q3BAR
+	D_276 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U4 jkff(1) DPWR DGND
+	PREB CLRB CLK4   J4 K4   Q4 Q4BAR
+	D_276 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_276 ueff (
+	TWCLKLMN=15NS	TWCLKHMN=13.5NS
+	TWPCLMN=12NS	TSUPCCLKHMN=10NS
+	TSUDCLKMN=3NS	THDCLKMN=10NS
+	TPPCQLHTY=15NS	TPPCQLHMX=25NS
+	TPPCQHLTY=18NS	TPPCQHLMX=30NS
+	TPCLKQLHTY=17NS	TPCLKQLHMX=30NS
+	TPCLKQHLTY=20NS	TPCLKQHLMX=30NS
+	)

*--------
*$
* 74278   PRIORITY REGISTERS 4-BIT CASCADABLE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-31-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74278   P0_I STRB_I D1_I D2_I D3_I D4_I
+ Y1_O Y2_O Y3_O Y4_O P1_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DLTCH(4) DPWR DGND
+ $D_HI $D_HI STRB
+ D1    D2    D3    D4
+ Q1    Q2    Q3    Q4
+ Q1BAR Q2BAR Q3BAR Q4BAR
+ D0_GFF  IO_STD

U278LOG LOGICEXP (14,11) DPWR DGND
+ P0_I STRB_I D1_I D2_I D3_I D4_I   Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ P0   STRB   D1   D2   D3   D4     Y1 Y2 Y3 Y4 P1
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   P0     = { P0_I }
+   STRB   = { STRB_I }
+   D1     = { D1_I }
+   D2     = { D2_I }
+   D3     = { D3_I }
+   D4     = { D4_I }
+   Y1     = { ~(P0 | Q1BAR ) }
+   Y2     = { ~(P0 | Q2BAR | Q1 ) }
+   Y3     = { ~(P0 | Q3BAR | Q2 | Q1 ) }
+   Y4     = { ~(P0 | Q4BAR | Q3 | Q2 | Q1 ) }
+   P1     = { P0 | Q4 | Q3 | Q2 | Q1 }

U278DLY PINDLY (5,0,6) DPWR DGND
+ Y1   Y2   Y3   Y4   P1
+ P0 STRB D1 D2 D3 D4
+ Y1_O Y2_O Y3_O Y4_O P1_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   STROBE = { CHANGED(STRB,0) }
+   BUSY   = { CHANGED(P0,0) }
+   PRIOR1 = { CHANGED_HL(D1,0) | BUSY }
+   PRIOR2 = { CHANGED_HL(D2,0) | PRIOR1 }
+   PRIOR3 = { CHANGED_HL(D3,0) | PRIOR2 | PRIOR1 }
+
+ PINDLY:
+   Y1_O = {
+     CASE (
+       STROBE & TRN_LH, DELAY(-1,-1,30NS),
+       STROBE & TRN_HL, DELAY(-1,-1,31NS),
+                TRN_LH, DELAY(-1,-1,30NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,39NS)
+       )
+     }
+   Y2_O = {
+     CASE (
+       STROBE & TRN_LH, DELAY(-1,-1,30NS),
+       STROBE & TRN_HL, DELAY(-1,-1,31NS),
+       PRIOR1 & TRN_LH, DELAY(-1,-1,38NS),
+       PRIOR1 & TRN_HL, DELAY(-1,-1,31NS),
+                TRN_LH, DELAY(-1,-1,30NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,39NS)
+       )
+     }
+   Y3_O = {
+     CASE (
+       STROBE & TRN_LH, DELAY(-1,-1,30NS),
+       STROBE & TRN_HL, DELAY(-1,-1,31NS),
+       PRIOR2 & TRN_LH, DELAY(-1,-1,38NS),
+       PRIOR2 & TRN_HL, DELAY(-1,-1,31NS),
+                TRN_LH, DELAY(-1,-1,30NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,39NS)
+       )
+     }
+   Y4_O = {
+     CASE (
+       STROBE & TRN_LH, DELAY(-1,-1,30NS),
+       STROBE & TRN_HL, DELAY(-1,-1,31NS),
+       PRIOR3 & TRN_LH, DELAY(-1,-1,38NS),
+       PRIOR3 & TRN_HL, DELAY(-1,-1,31NS),
+                TRN_LH, DELAY(-1,-1,30NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,39NS)
+       )
+     }
+   P1_O = {
+     CASE (
+       BUSY   & TRN_LH, DELAY(-1,-1,23NS),
+       BUSY   & TRN_HL, DELAY(-1,-1,30NS),
+       STROBE & TRN_LH, DELAY(-1,-1,38NS),
+       STROBE & TRN_HL, DELAY(-1,-1,42NS),
+                TRN_LH, DELAY(-1,-1,46NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,46NS)
+       )
+     }

U278CON CONSTRAINT (5) DPWR DGND
+ STRB D1 D2 D3 D4
+ IO_STD
+
+ WIDTH:
+   NODE      = STRB
+   MIN_HI    = 20NS
+ SETUP_HOLD:
+   DATA(4)   = D1 D2 D3 D4
+   CLOCK HL  = STRB
+   SETUPTIME = 20NS
+   HOLDTIME  =  5NS

.ENDS

*--------
*$
* 74279  QUADRUPLE SBAR-RBAR LATCHES
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	09/07/89  	Update interface and model names

.subckt 74279  1RBAR 1S1BAR 1S2BAR 2RBAR 2SBAR 1Q 2Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(2) DPWR DGND
+	1RBAR 2RBAR   1RB 2RB
+	D_279_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U2 nanda(3,2) DPWR DGND
+	1RB Q1 $D_HI 1S1BAR 1S2BAR Q1B   Q1B Q1
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U3 nanda(2,2) DPWR DGND
+	2RB Q2 2SBAR Q2B   Q2B Q2
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U4 wdthck(5) DPWR DGND
+	1RBAR	1S1BAR	1S2BAR	2RBAR	2SBAR
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	1RLO	1S1LO	1S2LO	2RLO	2SLO
+	D_279_2 IO_STD MNTYMXDLY={MNTYMXDLY}
U5 ora(3,2) DPWR DGND
+	1RLO 1S1LO 1S2LO 2RLO 2SLO $D_LO   X1 X2
+	D0_GATE IO_STD
U6 inva(2) DPWR DGND
+	X1 X2   T1 T2
+	D0_GATE IO_STD
U7 buf3 DPWR DGND
+	$D_X   X1   1Q
+	D_279_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U8 buf3 DPWR DGND
+	$D_X   X2   2Q
+	D_279_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U9 buf3 DPWR DGND
+	Q1   T1   1Q
+	D_279_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U10 buf3 DPWR DGND
+	Q2   T2   2Q
+	D_279_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_279_1 ugate (
+	TPHLTY=6NS	TPHLMX=12NS
+	)
.model D_279_2 uwdth (
+	TWLMN=20NS
+	)
.model D_279_3 utgate (
+	TPLHTY=12NS	TPHLTY=9NS
+	TPLHMX=22NS	TPHLMX=15NS
+	TPZHTY=12NS	TPZLTY=9NS
+	TPZHMX=22NS	TPZLMX=15NS
+	TPLZTY=12NS	TPHZTY=9NS
+	TPLZMX=22NS	TPHZMX=15NS
+	)
*--------
*$
* 74283 4-BIT BINARY FULL ADDERS WITH FAST CARRY
*
* TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTTKY DATA BOOK, 1988, TI
* NH 8/26/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 74283 C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I C4_O
+             SUM1_O SUM2_O SUM3_O SUM4_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0  IO_LEVEL = 0

U283LOG LOGICEXP(9,14) DPWR DGND
+ C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I
+ C0 A1 A2 A3 A4 B1 B2 B3 B4 C4 SUM1 SUM2 SUM3 SUM4
+ D0_GATE IO_STD IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   C0 = { C0_I }
+   A1 = { A1_I }
+   A2 = { A2_I }
+   A3 = { A3_I }
+   A4 = { A4_I }
+   B1 = { B1_I }
+   B2 = { B2_I }
+   B3 = { B3_I }
+   B4 = { B4_I }
+
+   NAND4 = { ~(A4 & B4) }
+   NAND3 = { ~(A3 & B3) }
+   NAND2 = { ~(A2 & B2) }
+   NAND1 = { ~(A1 & B1) }
+   NOR4 = { ~(A4 | B4) }
+   NOR3 = { ~(A3 | B3) }
+   NOR2 = { ~(A2 | B2) }
+   NOR1 = { ~(A1 | B1) }
+   C0BAR = { ~C0 }
+
+   SUM1 = { (NAND1 & ~NOR1) ^ C0 }
+   SUM2 = { (NAND2 & ~NOR2) ^ (~(NOR1 | (NAND1 & C0BAR))) }
+   SUM3 = { (NAND3 & ~NOR3) ^ (~(NOR2 | (NOR1 & NAND2) |
+            (NAND2 & NAND1 & C0BAR))) }
+   SUM4 = { (NAND4 & ~NOR4) ^ (~(NOR3 | (NOR2 & NAND3) |
+            (NOR1 & NAND3 & NAND2) | (NAND3 & NAND2 & NAND1 & C0BAR))) }
+   C4 = { ~( NOR4 | (NOR3 & NAND4) | (NOR2 & NAND4 & NAND3) |
+             (NOR1 & NAND4 & NAND3 & NAND2) |
+             (NAND4 & NAND3 & NAND2 & NAND1 & C0BAR) ) }

U283DLY PINDLY(5,0,9) DPWR DGND
+ SUM1 SUM2 SUM3 SUM4 C4
+ C0 A1 A2 A3 A4 B1 B2 B3 B4
+ SUM1_O SUM2_O SUM3_O SUM4_O C4_O
+ IO_STD MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_AB = { CHANGED(A1,0) | CHANGED(B1,0) | CHANGED(A2,0) |
+                 CHANGED(B2,0) | CHANGED(A3,0) | CHANGED(B3,0) |
+                 CHANGED(A4,0) | CHANGED(B4,0) }
+
+ PINDLY:
+   SUM1_O SUM2_O SUM3_O SUM4_O = {
+     CASE(
+       ANY_CH_AB, DELAY(-1,16NS,24NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,14NS,21NS),
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,12NS,21NS),
+       DELAY(-1,17NS,25NS)                       ;DEFAULT
+       )
+     }
+   C4_O = {
+     CASE(
+       (ANY_CH_AB | CHANGED(C0,0)) & TRN_HL, DELAY(-1,11NS,16NS),
+       (ANY_CH_AB | CHANGED(C0,0)) & TRN_LH, DELAY(-1,9NS,14NS),
+       DELAY(-1,12NS,17NS)                     ;DEFAULT
+       )
+     }

.ENDS

*---------
*$
* 74290  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-3-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE -- EXCEPT FOR THE PIN ARRANGEMENT, THE '290 IS ELECTRICALLY AND
*           FUNCTIONALLY IDENTICAL TO THE '90A
* NOTICE -- THE CKA TO QD PIN DELAY IS NOT INCLUDED IN THIS MODEL SINCE
*           THE DIV2 AND DIV5 SECTIONS OF THE COUNTER ACT INDEPENDENTLY.

.SUBCKT 74290  R91 R92 CKA CKB R01 R02  QA QB QC QD
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

X1   R91 R92 CKA CKB R01 R02   QA QB QC QD   DPWR DGND   7490A
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.ENDS

*---------
*$
* 74293  COUNTER BINARY 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   6-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE -- EXCEPT FOR THE PIN ARRANGEMENT, THE '293 IS ELECTRICALLY AND
*           FUNCTIONALLY IDENTICAL TO THE '93A
* NOTICE -- THE CKA TO QD PIN DELAY IS NOT INCLUDED IN THIS MODEL SINCE
*           THE DIV2 AND DIV8 SECTIONS OF THE COUNTER ACT INDEPENDENTLY.

.SUBCKT 74293  CKA CKB R01 R02  QA QB QC QD
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

X1   CKA CKB R01 R02   QA QB QC QD   DPWR DGND   7493A
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.ENDS
*--------
*$
* 74298  MULTIPLEXERS QUAD 2-INPUT WITH STORAGE
*
* THE TTL DATA BOOK, 1988, TI
* TC  08/25/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES

.SUBCKT 74298 WS_I CLK_I A1_I A2_I B1_I B2_I C1_I C2_I D1_I D2_I
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 JKFF(4) DPWR DGND $D_HI $D_HI CLK
+ JA JB JC JD KA KB KC KD QA QB QC QD $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_STD

U298LOG LOGICEXP(10,18) DPWR DGND
+ WS_I CLK_I A1_I A2_I B1_I B2_I C1_I C2_I D1_I D2_I
+ WS CLK A1 A2 B1 B2 C1 C2 D1 D2 JA JB JC JD KA KB KC KD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   WS = { WS_I }
+   CLK = { CLK_I }
+   A1 = { A1_I }
+   A2 = { A2_I }
+   B1 = { B1_I }
+   B2 = { B2_I }
+   C1 = { C1_I }
+   C2 = { C2_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   IWS = { ~WS }
+   KA = { ~((A1 & IWS) | (WS & A2)) }
+   KB = { ~((B1 & IWS) | (WS & B2)) }
+   KC = { ~((C1 & IWS) | (WS & C2)) }
+   KD = { ~((D1 & IWS) | (WS & D2)) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }

U298DLY PINDLY(4,0,0) DPWR DGND
+ QA QB QC QD
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       TRN_LH, DELAY(-1,18NS,27NS),
+       DELAY(-1,21NS,32NS)
+       )
+     }

U298CON CONSTRAINT(10) DPWR DGND
+ A1 A2 B1 B2 C1 C2 D1 D2 WS CLK
+ IO_STD
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ SETUP_HOLD:
+   DATA(4) = A1 B1 C1 D1
+   CLOCK HL = CLK
+   SETUPTIME = 15NS
+   HOLDTIME = 5NS
+   WHEN = { WS!='1 ^ CHANGED(WS,0) }
+ SETUP_HOLD:
+   DATA(4) = A2 B2 C2 D2
+   CLOCK HL = CLK
+   SETUPTIME = 15NS
+   HOLDTIME = 5NS
+   WHEN = { WS!='0 ^ CHANGED(WS,0) }
+ SETUP_HOLD:
+   DATA(1) = WS
+   CLOCK HL = CLK
+   SETUPTIME = 25NS

.ENDS

*---------
*$
* 74351 DUAL DATA SELECTOR/MULTIPLEXER WITH 3-STATE OUTPUTS
*
* THE TTL DATA BOOK, VOL 2, STANDARD, S, LS, TTL, 1985, TI
* NH 8/25/92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES

.SUBCKT 74351 GBAR_I A_I B_I C_I 1D0_I 1D1_I 1D2_I 1D3_I D4_I D5_I D6_I D7_I
+             2D0_I 2D1_I 2D2_I 2D3_I 1Y_O 2Y_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0 IO_LEVEL = 0

U351LOG LOGICEXP(16,18) DPWR DGND
+ GBAR_I A_I B_I C_I 1D0_I 1D1_I 1D2_I 1D3_I D4_I D5_I D6_I D7_I 2D0_I 2D1_I
+   2D2_I 2D3_I
+ GBAR A B C 1D0 1D1 1D2 1D3 D4 D5 D6 D7 2D0 2D1 2D2 2D3 1Y 2Y
+ D0_GATE IO_STD IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   GBAR = { GBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   1D0 = { 1D0_I }
+   1D1 = { 1D1_I }
+   1D2 = { 1D2_I }
+   1D3 = { 1D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   2D0 = { 2D0_I }
+   2D1 = { 2D1_I }
+   2D2 = { 2D2_I }
+   2D3 = { 2D3_I }
+
+   EN = { ~GBAR }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+
+   ZERO  = { CBAR & BBAR & ABAR & EN }
+   ONE   = { CBAR & BBAR & A & EN }
+   TWO   = { CBAR & B & ABAR & EN }
+   THREE = { CBAR & B & A & EN }
+   FOUR  = { C & BBAR & ABAR & EN }
+   FIVE  = { C & BBAR & A & EN }
+   SIX   = { C & B & ABAR & EN }
+   SEVEN = { C & B & A & EN }
+
+   1OUT0 = { 1D0 & ZERO }
+   1OUT1 = { 1D1 & ONE }
+   1OUT2 = { 1D2 & TWO }
+   1OUT3 = { 1D3 & THREE }
+   OUT4 = { D4 & FOUR }
+   OUT5 = { D5 & FIVE }
+   OUT6 = { D6 & SIX }
+   OUT7 = { D7 & SEVEN }
+   2OUT0 = { 2D0 & ZERO }
+   2OUT1 = { 2D1 & ONE }
+   2OUT2 = { 2D2 & TWO }
+   2OUT3 = { 2D3 & THREE }
+
+   1Y = { ~(1OUT0 | 1OUT1 | 1OUT2 | 1OUT3 | OUT4 | OUT5 | OUT6 | OUT7) }
+   2Y = { ~(2OUT0 | 2OUT1 | 2OUT2 | 2OUT3 | OUT4 | OUT5 | OUT6 | OUT7) }

U351DLY PINDLY(2,1,16) DPWR DGND
+ 1Y 2Y
+ GBAR
+ GBAR A B C 1D0 1D1 1D2 1D3 D4 D5 D6 D7 2D0 2D1 2D2 2D3
+ 1Y_O 2Y_O
+ IO_STD MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_1D = { CHANGED(1D0,0) | CHANGED(1D1,0) | CHANGED(1D2,0) |
+                 CHANGED(1D3,0) | CHANGED(D4,0)  | CHANGED(D5,0)  |
+                 CHANGED(D6,0)  | CHANGED(D7,0)  | CHANGED(2D0,0) }
+   ANY_CH_2D = { CHANGED(2D0,0) | CHANGED(2D1,0) | CHANGED(2D2,0) |
+                 CHANGED(1D3,0) | CHANGED(D4,0)  | CHANGED(D5,0)  |
+                 CHANGED(D6,0)  | CHANGED(D7,0)  | CHANGED(2D0,0) }
+   CH_SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+
+ TRISTATE:
+   ENABLE LO GBAR
+   1Y_O = {
+     CASE(
+       TRN_HZ, DELAY(-1,6NS,20NS),
+       TRN_LZ, DELAY(-1,10NS,20NS),
+       TRN_ZH, DELAY(-1,18NS,33NS),
+       TRN_ZL, DELAY(-1,20NS,33NS),
+       CH_SELECT, DELAY(-1,20NS,30NS),
+       ANY_CH_1D, DELAY(-1,10NS,22NS),
+       DELAY(-1,21NS,34NS)                    ;DEFAULT
+       )
+     }
+
+ TRISTATE:
+   ENABLE LO GBAR
+   2Y_O = {
+     CASE(
+       TRN_HZ, DELAY(-1,6NS,20NS),
+       TRN_LZ, DELAY(-1,10NS,20NS),
+       TRN_ZH, DELAY(-1,18NS,33NS),
+       TRN_ZL, DELAY(-1,20NS,33NS),
+       CH_SELECT, DELAY(-1,20NS,30NS),
+       ANY_CH_2D, DELAY(-1,10NS,22NS),
+       DELAY(-1,21NS,34NS)                    ;DEFAULT
+       )
+     }

.ENDS

*--------
*$
* 74365A  Hex Bus Drivers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	7/18/89 	Update interface and model names

.subckt 74365A  A1 A2 A3 A4 A5 A6 G1BAR G2BAR Y1 Y2 Y3 Y4 Y5 Y6
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA nor(2) DPWR DGND
+	G1BAR G2BAR   E
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 buf3a(6) DPWR DGND
+	A1	A2	A3	A4	A5	A6
+	E
+	Y1	Y2	Y3	Y4	Y5	Y6
+	D_365A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_365A utgate (
+	tplhmx=16ns	tphlmx=22ns
+	tpzhmx=35ns	tpzlmx=37ns
+	tphzmx=11ns	tplzmx=27ns
+	)
*---------
*$
* 74366A  Hex Bus Drivers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	06/27/89	Update interface and model names

.subckt 74366A  A1 A2 A3 A4 A5 A6 G1BAR G2BAR Y1 Y2 Y3 Y4 Y5 Y6
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA nor(2) DPWR DGND
+	G1BAR G2BAR   E
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 inv3a(6) DPWR DGND
+	A1	A2	A3	A4	A5	A6
+	E
+	Y1	Y2	Y3	Y4	Y5	Y6
+	D_366A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_366A utgate (
+	tplhmx=17ns	tphlmx=16ns
+	tpzhmx=35ns	tpzlmx=37ns
+	tphzmx=11ns	tplzmx=27ns
+	)
*---------
*$
* 74367A  Hex Bus Drivers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	7/18/89		Update interface and model names

.subckt 74367A  1A1 1A2 1A3 1A4 2A1 2A2 G1BAR G2BAR 1Y1 1Y2 1Y3 1Y4 2Y1 2Y2
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UINV inva(2) DPWR DGND
+	G1BAR G2BAR   G1 G2
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 buf3a(4) DPWR DGND
+	1A1 1A2 1A3 1A4   G1   1Y1 1Y2 1Y3 1Y4
+	D_367A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U2 buf3a(2) DPWR DGND
+	2A1 2A2   G2   2Y1 2Y2
+	D_367A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_367A utgate (
+	tplhmx=16ns	tphlmx=22ns
+	tpzhmx=35ns	tpzlmx=37ns
+	tphzmx=11ns	tplzmx=27ns
+	)
*---------
*$
* 74368A  Hex Bus Drivers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	7/18/89 	Update interface and model names

.subckt 74368A  1A1 1A2 1A3 1A4 2A1 2A2 G1BAR G2BAR 1Y1 1Y2 1Y3 1Y4 2Y1 2Y2
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UINV inva(2) DPWR DGND
+	G1BAR G2BAR   G1 G2
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U1 inv3a(4) DPWR DGND
+	1A1 1A2 1A3 1A4   G1   1Y1 1Y2 1Y3 1Y4
+	D_368A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U2 inv3a(2) DPWR DGND
+	2A1 2A2   G2   2Y1 2Y2
+	D_368A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL=0
.ends

.model D_368A utgate (
+	tplhmx=17ns	tphlmx=16ns
+	tpzhmx=35ns	tpzlmx=37ns
+	tphzmx=11ns	tplzmx=27ns
+	)
*---------
*$
* 74376  Quadruple J-K Flip-Flops
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	7/18/89		Update interface and model names

.subckt 74376  CLRBAR CLK J1 J2 J3 J4 KBAR1 KBAR2 KBAR3 KBAR4 Q1 Q2 Q3 Q4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UK inva(5) DPWR DGND
+	CLK	KBAR1	KBAR2	KBAR3	KBAR4
+	CLKBAR	K1	K2	K3	K4
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
UJK1 jkff(4) DPWR DGND
+	$D_HI	CLRBAR	CLKBAR
+	J1	J2	J3	J4	K1	K2	K3	K4
+	Q1	Q2	Q3	Q4	$D_NC	$D_NC	$D_NC	$D_NC
+	D_376 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_376 ueff (
+	twclklmn=12ns	twclkhmn=22ns
+	twpclmn=12ns	tsupcclkhmn=10ns
+	thdclkmn=20ns	tppcqhlty=17ns
+	tppcqhlmx=30ns	tpclkqlhty=22ns
+	tpclkqlhmx=35ns	tpclkqhlty=24ns
+	tpclkqhlmx=35ns
+	)
*--------
*$
* 74390  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-1-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74390   CKA_I CKB_I CLR_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKA      $D_HI $D_HI     QA $D_NC
+ D0_EFF IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLOCK2   $D_HI $D_HI     QB QBBAR
+ D0_EFF IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB       $D_HI $D_HI     QC QCBAR
+ D0_EFF IO_STD
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLOCK4   $D_HI $D_HI     QD QDBAR
+ D0_EFF IO_STD
U390LOG LOGICEXP (6,6) DPWR DGND
+ CKA_I CKB_I CLR_I    QBBAR QCBAR QDBAR
+ CKA   CKB   CLR      CLRBAR CLOCK2 CLOCK4
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CKA    = { CKA_I }
+   CKB    = { CKB_I }
+   CLR    = { CLR_I }
+   CLRBAR = { ~CLR }
+   CLOCK2 = { CKB & QDBAR }
+   CLOCK4 = { ~((QBBAR & QDBAR) | (QCBAR & QDBAR)) & CKB }

U390DLY PINDLY (4,0,3) DPWR DGND
+ QA   QB   QC   QD
+ CKA CKB CLR
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLOCKEDB = { CHANGED_HL(CKB,0) }
+   CLEARED  = { CHANGED_LH(CLR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKEDA & TRN_LH, DELAY(-1,12NS,20NS),
+       CLOCKEDA & TRN_HL, DELAY(-1,13NS,20NS),
+       DELAY(-1,24NS,39NS)
+       )
+     }
+   QB_O QD_O = {
+     CASE (
+       CLOCKEDB & TRN_LH, DELAY(-1,13NS,21NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,14NS,21NS),
+       DELAY(-1,24NS,39NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       CLEARED, DELAY(-1,24NS,39NS),
+       TRN_LH,  DELAY(-1,24NS,39NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }

U390CON CONSTRAINT (3) DPWR DGND
+ CKA CKB CLR
+ IO_STD
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 25MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 20MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 25NS
+   MIN_HI         = 25NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CKA
+   RELEASETIME_HL = 25NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CKB
+   RELEASETIME_HL = 25NS

.ENDS

*---------
*$
* 74393  COUNTER BINARY 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   6-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE: PROPAGATION DELAYS FOR A-TO-QB AND A-TO-QC WERE NOT SPECIFIED
*         IN THE DATA BOOK, SO THEY WERE INTERPOLATED FROM THE A-TO-QA AND
*         A-TO-QD PROPAGATION DELAYS

.SUBCKT 74393   A_I CLR_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR A    $D_HI $D_HI     QA $D_NC
+ D0_EFF  IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QA   $D_HI $D_HI     QB $D_NC
+ D0_EFF  IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB   $D_HI $D_HI     QC $D_NC
+ D0_EFF  IO_STD
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC   $D_HI $D_HI     QD $D_NC
+ D0_EFF  IO_STD
U5 BUFA(2) DPWR DGND
+ A_I   CLR_I
+ A     CLR
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
U6 INV DPWR DGND
+ CLR   CLRBAR
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}

U393DLY PINDLY (4,0,2) DPWR DGND
+ QA   QB   QC   QD
+ CLR A
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKED = { CHANGED_HL(A,0) }
+   CLEARED = { CHANGED_LH(CLR,0) }
+
+ PINDLY:
+ QA_O = {
+   CASE (
+     CLOCKED & TRN_LH, DELAY(-1,12NS,20NS),
+     CLOCKED & TRN_HL, DELAY(-1,13NS,20NS),
+     DELAY(-1,24NS,39NS)
+     )
+   }
+ QB_O = {
+   CASE (
+     CLOCKED, DELAY(-1,23NS,35NS), 	;GUESSED PROP DELAY--NOT IN DATA BOOK
+     DELAY(-1,24NS,39NS)
+     )
+   }
+ QC_O = {
+   CASE (
+     CLEARED, DELAY(-1,24NS,39NS),
+     DELAY(-1,33NS,50NS)     		;GUESSED PROP DELAY--NOT IN DATA BOOK
+     )
+   }
+ QD_O = {
+   CASE (
+     CLEARED, DELAY(-1,24NS,39NS),
+     DELAY(-1,40NS,60NS)
+     )
+   }

U393CON CONSTRAINT (2) DPWR DGND
+ A CLR
+ IO_STD
+
+ FREQ:
+   NODE           = A
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = A
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = A
+   RELEASETIME_HL = 25NS

.ENDS

*---------
*$
* 74425  Quadruple Bus Buffers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	 9/26/89	Update interface and model names

.subckt 74425  GBAR A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UINV inv DPWR DGND
+	GBAR   G
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
UY buf3 DPWR DGND
+	A   G   Y
+	D_425 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_425 utgate (
+	tplhty=8ns	tplhmx=13ns
+	tphlty=12ns	tphlmx=18ns
+	tpzhty=11ns	tpzhmx=17ns
+	tpzlty=16ns	tpzlmx=25ns
+	tphzty=5ns	tphzmx=8ns
+	tplzty=7ns	tplzmx=12ns
+	)
*--------
*$
* 74426  Quadruple Bus Buffers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	 9/26/89	Update interface and model names

.subckt 74426  G A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UY buf3 DPWR DGND
+	A   G   Y
+	D_426 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends

.model D_426 utgate (
+	tplhty=8ns	tplhmx=13ns
+	tphlty=12ns	tphlmx=18ns
+	tpzhty=11ns	tpzhmx=18ns
+	tpzlty=16ns	tpzlmx=25ns
+	tphzty=10ns	tphzmx=16ns
+	tplzty=12ns	tplzmx=18ns
+	)

*--------
*$
* 74490  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   7-2-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74490   CLR_I SET9_I CLK_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CLK      $D_HI $D_HI    QA $D_NC
+ D0_EFF  IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 CLOCK2   $D_HI $D_HI    QB QBBAR
+ D0_EFF  IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 QB       $D_HI $D_HI    QC QCBAR
+ D0_EFF  IO_STD
U4 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CLOCK4   $D_HI $D_HI    QD QDBAR
+ D0_EFF  IO_STD

U490LOG LOGICEXP (7,8) DPWR DGND
+ CLR_I  SET9_I  CLK_I QA QBBAR QCBAR QDBAR
+ CLR    SET9    CLK  CLRBAR23 CLOCK2 CLOCK4 CLRBAR SET9BAR
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLR      = { CLR_I }
+   CLRBAR   = { ~CLR }
+   SET9     = { SET9_I }
+   SET9BAR  = { ~SET9 }
+   CLK      = { CLK_I }
+   CLRBAR23 = { CLRBAR & SET9BAR }
+   CLOCK2   = { QA & QDBAR }
+   CLOCK4   = { ~( (QBBAR & QDBAR) | (QCBAR & QDBAR) ) & QA }

U490DLY PINDLY (4,0,3) DPWR DGND
+ QA   QB   QC   QD
+ CLR SET9 CLK
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKED = { CHANGED_HL(CLK,0) }
+   CLEARED = { CHANGED_LH(CLR,0) }
+   SETNINE = { CHANGED_LH(SET9,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKED & TRN_LH, DELAY(-1,12NS,20NS),
+       CLOCKED & TRN_HL, DELAY(-1,13NS,20NS),
+       DELAY(-1,24NS,39NS)
+       )
+     }
+   QB_O = {
+     CASE (
+       SETNINE, DELAY(-1,20NS,36NS),
+       CLEARED, DELAY(-1,24NS,39NS),
+       TRN_LH,  DELAY(-1,24NS,39NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       SETNINE, DELAY(-1,20NS,36NS),
+       CLEARED, DELAY(-1,24NS,39NS),
+       TRN_LH,  DELAY(-1,32NS,54NS),
+       DELAY(-1,36NS,54NS)
+       )
+     }
+   QD_O = {
+     CASE (
+       TRN_LH,  DELAY(-1,24NS,39NS),
+       CLEARED, DELAY(-1,24NS,39NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }

U490CON CONSTRAINT (3) DPWR DGND
+ CLR SET9 CLK
+ IO_STD
+
+ FREQ:
+   NODE           = CLK
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = CLK
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+   WHEN           = { SET9!='1 }
+ WIDTH:
+   NODE           = SET9
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CLK
+   RELEASETIME_HL = 25NS
+   WHEN           = { SET9!='1 }
+ SETUP_HOLD:
+   DATA(1)        = SET9
+   CLOCK HL       = CLK
+   RELEASETIME_HL = 25NS

.ENDS

*---------
*$
*****************************************************************************
* I/O MODELS, Digital Power Supply, Stimulus Models Etc. - From DIG_IO.LIB
*****************************************************************************
*
*  Copyright OrCAD, Inc. 1998 All Rights Reserved.

* Release date: December 1992

* The parameters in this model library were derived from:
*
*   The TTL Data Book, Texas Instruments, 1985
*     vol. 2, pp 1-21 to 1-28, pp 3-4 to 3-9, and pp 3-79 to 3-81
*
* AtoD and DtoA Subcircuits
* -------------------------
* The subcircuits in this library are used to convert analog signals
* into digital signals (AtoD) and digital signals into analog signals
* (DtoA).  The PSpice Digital Simulation Option creates "X" devices which
* reference these subcircuits whenever it needs to convert a digital or
* analog signal.  The user usually will not need to use these subcircuits
* directly.  However, if you need to add new AtoD or DtoA subcircuits, the
* interface nodes must be in the following order, and have the following
* parameters:
*
*   AtoD: .subckt <name> <analog-node> <dig-node> <dig-pwr> <dig-gnd>
*         +	params: CAPACITANCE=0
*
*   DtoA: .subckt <name> <dig-node> <analog-node> <dig-pwr> <dig-gnd>
*         +	params: DRVL=0  DRVH=0  CAPACITANCE=0
*
* I/O Models
* ----------
* I/O models specify the names of the AtoD and DtoA subcircuits PSpice must
* use to convert analog signals to digital signals or vice versa.  (I/O models
* also describe driving and loading characteristics.)  Up to four of each
* AtoD and DtoA subcircuit names may be specified in an I/O model, using
* parameters AtoD1 through AtoD4, and DtoA1 through DtoA4.  The subcircuit
* which PSpice actually uses depends on the value of the IO_LEVEL parameter
* in a subcircuit reference.
*
* As implemented in this library, the levels have the following definitions:
*
*   IO_LEVEL  Definition
*   --------  --------------------------------------------------------------
*      1      AtoD generates X, R, and F between VIL max and VIH min
*      2      AtoD transitions directly between 0 and 1 at Vt
*      3      Unused (Same as level 1)
*      4      Unused (Same as level 2)
*
* Note that Schmitt-trigger inputs always transition directly between 0 and 1.
*
* For example, to specify the basic interface without an intermediate
* X value, you would use:
*
* X1 in out 74LS04 PARAMS: IO_LEVEL=2
*
* If the IO_LEVEL is not specified for a device, the default IO_LEVEL is used.
* The default level is controled by the .OPTION parameter DIGIOLVL, which
* defaults to 1.
*
* Switching Times
* ---------------
* The I/O models include switching time parameters for low-to-high, and
* high-to-low transitions (TSWLHn and TSWHLn).  There is a different pair of
* switching times for each IO_LEVEL value.  These times are subtracted from
* the propagation delay times for devices which have a DtoA subcircuit created
* at their output.  The switching time is the time it takes the output of the
* DtoA to change its output voltage from steady state to the logic threshold.
* The switching time values are selected so that inserting a DtoA-AtoD pair
* in a logic path does not change the overall propagation delay.  (Assuming
* that no additional load is placed on the analog signal.)
*
* Power Supplies
* --------------
* The I/O models also specify the name of a digital power supply subcircuit.
* These subcircuits are called by PSpice in the event any AtoD/DtoA interfaces
* are created.
*-----------------------------------------------------------------------------
* Digital Power Supplies
*-----------------------------------------------------------------------------

*  PSpice calls a power supply subcircuit as a consequence of AtoD or DtoA
*  interface creation.  The resulting digital power supply nodes are used
*  by the AtoD/DtoA interfaces.  The name of the power supply subcircuit
*  is specified in the technology's I/O models.  Currently, these power
*  supplies are:
*
*    Device Type   Subcircuit Name  Nodes Created
*    ------------- ---------------  ---------------------------------------
*    TTL           DIGIFPWR	    $G_DPWR  $G_DGND
*
*  PSpice always passes node 0 as the required analog reference node "GND".
*  By default, the nodes created by the subcircuit call are global nodes
*  ($G_xxx) which are used throughout the device library for that family.
*
*  The default power supply voltage for TTL (and compatible CMOS) devices
*  is 5.0v.
*
*
*
* TTL/CMOS power supply
*
.subckt DIGIFPWR  AGND
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params:   VOLTAGE=5.0v REFERENCE=0v
*
VDPWR  DPWR DGND  {VOLTAGE}
R1     DPWR AGND  1MEG
VDGND  DGND AGND  {REFERENCE}
R2     DGND AGND  1MEG
.ends
*$

*-----------------------------------------------------------------------------
* Stimulus Device Models and Subcircuits
*-----------------------------------------------------------------------------

*-------------------------------------------------
* Stimulus I/O Models

*
.model IO_STM uio (
+	drvh=0	drvl=0
+	DtoA1="DtoA_STM"	DtoA2="DtoA_STM"
+	DtoA3="DtoA_STM"	DtoA4="DtoA_STM"
+	DIGPOWER="DIGIFPWR"
+	)
*$
.model IO_STM_OC uio (
+	drvh=1MEG	drvl=0
+	DtoA1="DtoA_STM_OC"	DtoA2="DtoA_STM_OC"
+	DtoA3="DtoA_STM_OC"	DtoA4="DtoA_STM_OC"
+	DIGPOWER="DIGIFPWR"
+	)
*$

*-------------------------------------------------
* Stimulus DtoA Subcircuit

*
.subckt DtoA_STM  D A  DPWR DGND
+	params: DRVL=0 DRVH=0 CAPACITANCE=0
*
N1  A DGND DPWR DINSTM DGTLNET=D IO_STM
C1  A DGND {CAPACITANCE+0.1pF}
.ends
*$

*-------------------------------------------------
* Stimulus Open Collector DtoA Subcircuit

*
.subckt DtoA_STM_OC  D A  DPWR DGND
+	params: DRVL=0 DRVH=0 CAPACITANCE=0
*
N1  A DGND DPWR DINSTM_OC DGTLNET=D IO_STM_OC
C1  A DGND {CAPACITANCE+0.1pF}
.ends
*$

*-------------------------------------------------
* Stimulus Digital Input/Output Models
*
* We use 1/2 ohm and a 500ps transition time, on the assumption that
* this will be a "strong" signal source with a "fast" switching time
* in most systems which use this library. Change the tsw's and/or the
* rlow and rhi values if these don't work for your system.
*
*
.model DINSTM dinput (
+	s0name="0"	s0tsw=0.5ns	s0rlo=.5	s0rhi=1k
+	s1name="1"	s1tsw=0.5ns	s1rlo=1k	s1rhi=.5
+	s2name="X"	s2tsw=0.5ns	s2rlo=0.429	s2rhi=1.16 ; .313ohm, 1.35v
+	s3name="R"	s3tsw=0.5ns	s3rlo=0.429	s3rhi=1.16 ; .313ohm, 1.35v
+	s4name="F"	s4tsw=0.5ns	s4rlo=0.429	s4rhi=1.16 ; .313ohm, 1.35v
+	s5name="Z"	s5tsw=0.5ns	s5rlo=1MEG	s5rhi=1MEG
+	)
*$
.model DINSTM_OC dinput (
+	s0name="0"	s0tsw=0.5ns	s0rlo=.5	s0rhi=1k
+	s1name="1"	s1tsw=0.5ns	s1rlo=1MEG	s1rhi=1MEG
+	s2name="X"	s2tsw=0.5ns	s2rlo=0.429	s2rhi=1.16 ; .313ohm, 1.35v
+	s3name="R"	s3tsw=0.5ns	s3rlo=0.429	s3rhi=1.16 ; .313ohm, 1.35v
+	s4name="F"	s4tsw=0.5ns	s4rlo=0.429	s4rhi=1.16 ; .313ohm, 1.35v
+	s5name="Z"	s5tsw=0.5ns	s5rlo=1MEG	s5rhi=1MEG
+	)
*$


*-----------------------------------------------------------------------------
* Zero-Delay Models
*-----------------------------------------------------------------------------

*-------------------------------------------------
* Zero-Delay Gate Model

*
.model D0_GATE ugate ()
*$

*-------------------------------------------------
* Zero-Delay Tristate Gate Model

*
.model D0_TGATE utgate ()
*$

*-------------------------------------------------
* Zero-Delay Edge-Triggered Flip-Flop Model

*
.model D0_EFF ueff ()
*$

*-------------------------------------------------
* Zero-Delay Gated Flip-Flop Model

*
.model D0_GFF ugff ()
*$


*-----------------------------------------------------------------------------
* Default Models and Subcircuits
*-----------------------------------------------------------------------------

*-------------------------------------------------
* Default I/O Models

*
.model IO_DFT uio (
+	drvh=50	drvl=50
+	AtoD1="AtoD_STD"	AtoD2="AtoD_STD_NX"
+	AtoD3="AtoD_STD"	AtoD4="AtoD_STD_NX"
+	DtoA1="DtoA_STD"	DtoA2="DtoA_STD"
+	DtoA3="DtoA_STD"	DtoA4="DtoA_STD"
+	DIGPOWER="DIGIFPWR"
+	)
*$
.model IO_DFT_OC uio (
+	drvh=1MEG	drvl=50
+	AtoD1="AtoD_STD"	AtoD2="AtoD_STD"
+	AtoD3="AtoD_STD"	AtoD4="AtoD_STD"
+	DtoA1="DtoA_STD_OC"	DtoA2="DtoA_STD_OC"
+	DtoA3="DtoA_STD_OC"	DtoA4="DtoA_STD_OC"
+	DIGPOWER="DIGIFPWR"
+	)
*$

*-------------------------------------------------
* Default AtoD Subcircuit

*
.subckt AtoDDEFAULT  A D  DPWR DGND
+	params: CAPACITANCE=0
*
O1  A DGND DO74 DGTLNET=D IO_DFT
.ends
*$

*-------------------------------------------------
* Default DtoA Subcircuit

*
.subckt DtoADEFAULT  D A  DPWR DGND
+	params: DRVL=0 DRVH=0 CAPACITANCE=0
*
N1  A DGND DPWR DIN74 DGTLNET=D IO_DFT
C1  A DGND {CAPACITANCE+0.1pF}
.ends
*$


******************************************************************************
* 74/54 Family (standard TTL)
******************************************************************************

*-------------------------------------------------
* 7400 I/O Models

*
.model IO_STD uio (
+	drvh=96.4	drvl=104
+	AtoD1="AtoD_STD"	AtoD2="AtoD_STD_NX"
+	AtoD3="AtoD_STD"	AtoD4="AtoD_STD_NX"
+	DtoA1="DtoA_STD"	DtoA2="DtoA_STD"
+	DtoA3="DtoA_STD"	DtoA4="DtoA_STD"
+       tswhl1=1.373ns          tswlh1=3.382ns
+       tswhl2=1.346ns          tswlh2=3.424ns
+       tswhl3=1.511ns          tswlh3=3.517ns
+       tswhl4=1.487ns          tswlh4=3.564ns
+	DIGPOWER="DIGIFPWR"
+	)
*$
.model IO_STD_ST uio (
+	drvh=96.4	drvl=104
+	AtoD1="AtoD_STD_ST"	AtoD2="AtoD_STD_ST"
+	AtoD3="AtoD_STD_ST"	AtoD4="AtoD_STD_ST"
+	DtoA1="DtoA_STD"	DtoA2="DtoA_STD"
+	DtoA3="DtoA_STD"	DtoA4="DtoA_STD"
+       tswhl1=1.373ns          tswlh1=3.382ns
+       tswhl2=1.346ns          tswlh2=3.424ns
+       tswhl3=1.511ns          tswlh3=3.517ns
+       tswhl4=1.487ns          tswlh4=3.564ns
+	DIGPOWER="DIGIFPWR"
+	)
*$
.model IO_STD_OC uio (
+	drvh=1MEG	drvl=104
+	AtoD1="AtoD_STD"	AtoD2="AtoD_STD_NX"
+	AtoD3="AtoD_STD"	AtoD4="AtoD_STD_NX"
+	DtoA1="DtoA_STD_OC"	DtoA2="DtoA_STD_OC"
+	DtoA3="DtoA_STD_OC"	DtoA4="DtoA_STD_OC"
*  tsw values measured with 330 ohm pull up
+       tswhl1=2.617ns          tswlh1=1.432ns
+       tswhl2=2.598ns          tswlh2=1.460ns
+       tswhl3=2.747ns          tswlh3=1.589ns
+       tswhl4=2.732ns          tswlh4=1.615ns
+	DIGPOWER="DIGIFPWR"
+	)
*$

*-------------------------------------------------
* 7400 Standard AtoD Subcircuits

*
.subckt AtoD_STD  A D  DPWR DGND
+	params: CAPACITANCE=0
*
O0  A DGND DO74 DGTLNET=D IO_STD
C1  A DGND {CAPACITANCE+0.1pF}
D0	DGND	a	D74CLMP
D1	1	2	D74
D2      2       DGND	D74
R1	DPWR	3	4k
Q1      1       3       A       0	Q74 ; substrate should be DGND
.ends
*$

.subckt AtoD_STD_NX  A D  DPWR DGND
+	params: CAPACITANCE=0
*
O0  A DGND DO74_NX DGTLNET=D IO_STD
C1  A DGND {CAPACITANCE+0.1pF}
D0	DGND	a	D74CLMP
D1	1	2	D74
D2      2       DGND	D74
R1	DPWR	3	4k
Q1      1       3       A       0	Q74 ; substrate should be DGND
.ends
*$

*-------------------------------------------------
* 7400 Schmitt-trigger AtoD Subcircuits

*
.subckt AtoD_STD_ST  A D  DPWR DGND
+	params: CAPACITANCE=0
*
O0  A DGND DO74_ST DGTLNET=D IO_STD
C1  A DGND {CAPACITANCE+0.1pF}
D0	DGND	a	D74CLMP
D1	1	2	D74
D2      2       DGND	D74
R1	DPWR	3	4k
Q1      1       3       A       0	Q74
.ends
*$

*-------------------------------------------------
* 7400 standard DtoA Subcircuit

*
.subckt DtoA_STD  D A  DPWR DGND
+	params: DRVL=0 DRVH=0 CAPACITANCE=0
*
N1  A DGND DPWR DIN74 DGTLNET=D IO_STD
C1  A DGND {CAPACITANCE+0.1pF}
.ends
*$

*-------------------------------------------------
* 7400 open collector DtoA Subcircuit

*
.subckt DtoA_STD_OC  D A  DPWR DGND
+	params: DRVL=0 DRVH=0 CAPACITANCE=0
*
N1  A DGND DPWR DIN74_OC DGTLNET=D IO_STD_OC
C1  A DGND {CAPACITANCE+0.1pF}
.ends
*$

*-------------------------------------------------
* 7400 Digital Input/Output Models

*
.model DIN74 dinput (
+	s0name="0"	s0tsw=3.5ns	s0rlo=7.13	s0rhi=389 ; 7ohm,    0.09v
+	s1name="1"	s1tsw=5.5ns	s1rlo=467	s1rhi=200 ; 140ohm,  3.5v
+	s2name="X"	s2tsw=3.5ns	s2rlo=42.9	s2rhi=116 ; 31.3ohm, 1.35v
+	s3name="R"	s3tsw=3.5ns	s3rlo=42.9	s3rhi=116 ; 31.3ohm, 1.35v
+	s4name="F"	s4tsw=3.5ns	s4rlo=42.9	s4rhi=116 ; 31.3ohm, 1.35v
+	s5name="Z"	s5tsw=3.5ns	s5rlo=200K	s5rhi=200K
+	)
*$
.model DIN74_OC dinput (
+	s0name="0"	s0tsw=3.5ns	s0rlo=7.13	s0rhi=389 ; 7ohm,    0.09v
+	s1name="1"	s1tsw=5.5ns	s1rlo=200K	s1rhi=200K
+	s2name="X"	s2tsw=3.5ns	s2rlo=42.9	s2rhi=116 ; 31.3ohm, 1.35v
+	s3name="R"	s3tsw=3.5ns	s3rlo=42.9	s3rhi=116 ; 31.3ohm, 1.35v
+	s4name="F"	s4tsw=3.5ns	s4rlo=42.9	s4rhi=116 ; 31.3ohm, 1.35v
+	s5name="Z"	s5tsw=5.5ns	s5rlo=200K	s5rhi=200K
+	)
*$
.model DO74 doutput (
+	s0name="X"	s0vlo=0.8	s0vhi=2.0
+	s1name="0"	s1vlo=-1.5	s1vhi=0.8
+	s2name="R"	s2vlo=0.8	s2vhi=1.4
+	s3name="R"	s3vlo=1.3	s3vhi=2.0
+	s4name="X"	s4vlo=0.8	s4vhi=2.0
+	s5name="1"	s5vlo=2.0	s5vhi=7.0
+	s6name="F"	s6vlo=1.3	s6vhi=2.0
+	s7name="F"	s7vlo=0.8	s7vhi=1.4
+	)
*$
.model DO74_NX doutput (
+	s0name="0"	s0vlo=-1.5	s0vhi=1.35
+	s2name="1"	s2vlo=1.35	s2vhi=7.0
+	)
*$
.model DO74_ST doutput (
+	s0name="0"	s0vlo=-1.5	s0vhi=1.7
+	s1name="1"	s1vlo=0.9	s1vhi=7.0
+	)
*$

******************************************************************************
* TTL device models
******************************************************************************

* These parameter values are taken from:
*
*   "Analysis and Design of Digital Integrated Circuits"
*   by David A. Hodges and Horace G. Jackson
*   1983, McGraw-Hill  pg 301
*
*
.model D74 d (
+	is=1e-16	rs=25	cjo=2pf
+	)
*$
.model D74S d (
+	is=1e-12	vj=.7	rs=25	cjo=2pf
+	)
*$
.model D74CLMP d (
+	is=1e-15	rs=2	cjo=2pf
+	)
*$
.model D74SCLMP d (
+	is=1e-11	vj=.7	rs=2	cjo=2pf
+	)
*$
.model Q74 npn (
+	ise=1e-16	isc=4e-16
+	bf=49	br=.03
+	cje=1pf	cjc=.5pf
+	cjs=3pf	vje=0.9v
+	vjc=0.8v	vjs=0.7v
+	mje=0.5	mjc=0.33
+	mjs=0.33	tf=0.2ns
+	tr=10ns	rb=50
+	rc=20
+	)
*$
.model Q74S npn (
+	ise=1e-16	isc=4e-16
+	bf=49	br=.33
+	cje=1pf	cjc=.5pf
+	cjs=3pf	vje=0.9v
+	vjc=0.8v	vjs=0.7v
+	mje=0.5	mjc=0.33
+	mjs=0.33	tf=0.2ns
+	tr=10ns	rb=50
+	rc=20
+	)
*$
* 74S11  Triple 3-input Positive-And Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn 	06/23/89	Update interface and model names
*
.subckt 74S11  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(3) DPWR DGND
+	A B C   Y
+	D_S11 IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends
*
.model D_S11 ugate (
+	tplhty=4.5ns	tplhmx=7ns
+	tphlty=5ns	tphlmx=7.5ns
+	)
*$
* 74S I/O Models
*
.model IO_S uio (
+	drvh=72.7	drvl=60.6
+	AtoD1="AtoD_S"	AtoD2="AtoD_S_NX"
+	AtoD3="AtoD_S"	AtoD4="AtoD_S_NX"
+	DtoA1="DtoA_S"	DtoA2="DtoA_S"
+	DtoA3="DtoA_S"	DtoA4="DtoA_S"
+       tswhl1=0.708ns          tswlh1=0.811ns
+       tswhl2=0.712ns          tswlh2=0.807ns
+       tswhl3=0.788ns          tswlh3=0.889ns
+       tswhl4=0.795ns          tswlh4=0.887ns
+	DIGPOWER="DIGIFPWR"
+	)
*$
.model IO_S_OC uio (
+	drvh=1MEG	drvl=60.6
+	AtoD1="AtoD_S"	AtoD2="AtoD_S_NX"
+	AtoD3="AtoD_S"	AtoD4="AtoD_S_NX"
+	DtoA1="DtoA_S_OC"	DtoA2="DtoA_S_OC"
+	DtoA3="DtoA_S_OC"	DtoA4="DtoA_S_OC"
+       tswhl1=1.199ns          tswlh1=0.335ns
+       tswhl2=1.197ns          tswlh2=0.334ns
+       tswhl3=1.305ns          tswlh3=0.483ns
+       tswhl4=1.306ns          tswlh4=0.471ns
+	DIGPOWER="DIGIFPWR"
+	)
*$
.model IO_S_ST uio (
+	drvh=72.7	drvl=60.6
+	AtoD1="AtoD_S_ST"	AtoD2="AtoD_S_ST"
+	AtoD3="AtoD_S_ST"	AtoD4="AtoD_S_ST"
+	DtoA1="DtoA_S"	DtoA2="DtoA_S"
+	DtoA3="DtoA_S"	DtoA4="DtoA_S"
+       tswhl1=0.708ns          tswlh1=0.811ns
+       tswhl2=0.712ns          tswlh2=0.807ns
+       tswhl3=0.788ns          tswlh3=0.889ns
+       tswhl4=0.795ns          tswlh4=0.887ns
+	DIGPOWER="DIGIFPWR"
+	)
*$
.model IO_S_OC_ST uio (
+	drvh=1MEG	drvl=60.6
+	AtoD1="AtoD_S_ST"	AtoD2="AtoD_S_ST"
+	AtoD3="AtoD_S_ST"	AtoD4="AtoD_S_ST"
+	DtoA1="DtoA_S_OC"	DtoA2="DtoA_S_OC"
+	DtoA3="DtoA_S_OC"	DtoA4="DtoA_S_OC"
+       tswhl1=1.199ns          tswlh1=0.335ns
+       tswhl2=1.197ns          tswlh2=0.334ns
+       tswhl3=1.305ns          tswlh3=0.483ns
+       tswhl4=1.306ns          tswlh4=0.471ns
+	DIGPOWER="DIGIFPWR"
+	)
*$
*
*-------------------------------------------------
* 74S00 Standard AtoD Subcircuits
*
.subckt AtoD_S  A D  DPWR DGND
+	params: CAPACITANCE=0
*
O0  A DGND DO74S DGTLNET=D IO_S
C1  A DGND {CAPACITANCE+0.1pF}
D0	DGND	a	D74SCLMP
D1	1	2	D74
D2      2       DGND	D74
R1	DPWR	3	2.8k
Q1      1       3       A       0	Q74S
D3      3       1       D74S
.ends
*$
*
.subckt AtoD_S_NX  A D  DPWR DGND
+	params: CAPACITANCE=0
*
O0  A DGND DO74S_NX DGTLNET=D IO_S
C1  A DGND {CAPACITANCE+0.1pF}
D0	DGND	a	D74SCLMP
D1	1	2	D74
D2      2       DGND	D74
R1	DPWR	3	2.8k
Q1      1       3       A       0	Q74S
D3      3       1       D74S
.ends
*$
*
* 74S Schmitt-trigger AtoD Subcircuits
*
.subckt AtoD_S_ST  A D  DPWR DGND
+	params: CAPACITANCE=0
*
O0  A DGND DO74S_ST DGTLNET=D IO_S
C1  A DGND {CAPACITANCE+0.1pF}
D0	DGND	a	D74SCLMP
D1	1	2	D74
D2      2       DGND	D74
R1	DPWR	3	2.8k
Q1      1       3       A       0	Q74S
D3      3       1       D74S
.ends
*$
*
* 74S Standard DtoA Subcircuit
*
.subckt DtoA_S  D A  DPWR DGND
+	params: DRVL=0 DRVH=0 CAPACITANCE=0
*
N1  A DGND DPWR DIN74S DGTLNET=D IO_S
C1  A DGND {CAPACITANCE+0.1pF}
.ends
*$
*
* 74S Open Collector DtoA Subcircuit
*
.subckt DtoA_S_OC  D A  DPWR DGND
+	params: DRVL=0 DRVH=0 CAPACITANCE=0
*
N1  A DGND DPWR DIN74S_OC DGTLNET=D IO_S_OC
C1  A DGND {CAPACITANCE+0.1pF}
.ends
*$
*
* 74S Digital Input/Output Models
.model DIN74S dinput (
+	s0name="0"	s0tsw=1.5ns	s0rlo=12.0	s0rhi=389 ; 11.7ohm, 0.15v
+	s1name="1"	s1tsw=1.5ns	s1rlo=224	s1rhi=74.7 ; 56.0ohm, 3.75v
+	s2name="X"	s2tsw=1.5ns	s2rlo=34.6	s2rhi=98.4 ; 25.6ohm, 1.30v
+	s3name="R"	s3tsw=1.5ns	s3rlo=34.6	s3rhi=98.4 ; 25.6ohm, 1.30v
+	s4name="F"	s4tsw=1.5ns	s4rlo=34.6	s4rhi=98.4 ; 25.6ohm, 1.30v
+	s5name="Z"	s5tsw=1.5ns	s5rlo=200K	s5rhi=200K
+	)
*$
.model DIN74S_OC dinput (
+	s0name="0"	s0tsw=1.5ns	s0rlo=12.0	s0rhi=389 ; 11.7ohm, 0.15v
+	s1name="1"	s1tsw=1.5ns	s1rlo=200K	s1rhi=200K
+	s2name="X"	s2tsw=1.5ns	s2rlo=34.6	s2rhi=98.4 ; 25.6ohm, 1.30v
+	s3name="R"	s3tsw=1.5ns	s3rlo=34.6	s3rhi=98.4 ; 25.6ohm, 1.30v
+	s4name="F"	s4tsw=1.5ns	s4rlo=34.6	s4rhi=98.4 ; 25.6ohm, 1.30v
+	s5name="Z"	s5tsw=1.5ns	s5rlo=200K	s5rhi=200K
+	)
*$
.model DO74S doutput (
+	s0name="X"	s0vlo=0.8	s0vhi=2.0
+	s1name="0"	s1vlo=-1.5	s1vhi=0.8
+	s2name="R"	s2vlo=0.8	s2vhi=1.35
+	s3name="R"	s3vlo=1.25	s3vhi=2.0
+	s4name="X"	s4vlo=0.8	s4vhi=2.0
+	s5name="1"	s5vlo=2.0	s5vhi=7.0
+	s6name="F"	s6vlo=1.25	s6vhi=2.0
+	s7name="F"	s7vlo=0.8	s7vhi=1.35
+	)
*$
.model DO74S_NX doutput (
+	s0name="0"	s0vlo=-1.5	s0vhi=1.3
+	s2name="1"	s2vlo=1.3	s2vhi=7.0
+	)
*$
.model DO74S_ST doutput (
+	s0name="0"	s0vlo=-1.5	s0vhi=1.7
+	s1name="1"	s1vlo=0.9	s1vhi=7.0
+	)
*$
*
* Programmable Logic Device
*
* PAL20RP4B
*
* Programmable Logic Devices Databook and Design Guide,
* 1989 Edition, National Semiconductor
* tdn   09/10/91	Created
*
.subckt PAL20RP4B  PIN1 PIN2 PIN3 PIN4 PIN5 PIN6 PIN7 PIN8 PIN9 PIN10 PIN11
+	PIN13 PIN14 PIN15 PIN16 PIN17 PIN18 PIN19 PIN20 PIN21 PIN22 PIN23
+	optional: PIN24=$G_DPWR PIN12=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
+	text: JEDEC_FILE="PAL.JED"
U1 plandc(20,64) pin24 pin12
+	pin2	pin23	pin3	pin22	pin4
+	pin21	pin5	q_20	pin6	q_19
+	pin7	q_18	pin8	q_17	pin9
+	pin16	pin10	pin15	pin11	pin14
+	row1	row2	row3	row4	row5	row6	row7	row8
+	row9	row10	row11	row12	row13	row14	row15	row16
+	row17	row18	row19	row20	row21	row22	row23	row24
+	row25	row26	row27	row28	row29	row30	row31	row32
+	row33	row34	row35	row36	row37	row38	row39	row40
+	row41	row42	row43	row44	row45	row46	row47	row48
+	row49	row50	row51	row52	row53	row54	row55	row56
+	row57	row58	row59	row60	row61	row62	row63	row64
+	D0_PLD IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+	FILE=|JEDEC_FILE|
U2 ora(7,4) pin24 pin12
+	row2	row3	row4	row5	row6	row7	row8
+	row10	row11	row12	row13	row14	row15	row16
+	row50	row51	row52	row53	row54	row55	row56
+	row58	row59	row60	row61	row62	row63	row64
+	or22	or21	or16	or15
+	D0_gate IO_LS
U3 ora(8,4) pin24 pin12
+	row17	row18	row19	row20	row21	row22	row23	row24
+	row25	row26	row27	row28	row29	row30	row31	row32
+	row33	row34	row35	row36	row37	row38	row39	row40
+	row41	row42	row43	row44	row45	row46	row47	row48
+	or20	or19	or18	or17
+	D0_gate IO_LS
UXOR pland(1,8) pin24 pin12
+	$D_LO   xor22 xor21 xor20 xor19 xor18 xor17 xor16 xor15
+	PAL20RP_XOR IO_LS FILE=|JEDEC_FILE|
U4 xora(8) pin24 pin12
+	or22	xor22
+	or21	xor21
+	or20	xor20
+	or19	xor19
+	or18	xor18
+	or17	xor17
+	or16	xor16
+	or15	xor15
+	out22	out21	d20	d19	d18	d17	out16	out15
+	D0_gate IO_LS
U5 dff(4) pin24 pin12
+	$d_hi	$d_hi	pin1
+	d20	d19	d18	d17
+	out20	out19	out18	out17	qr_20	qr_19	qr_18	qr_17
+	D_PAL_24POL_REGB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U6 bufa(4) pin24 pin12
+	qr_20 qr_19 qr_18 qr_17   q_20 q_19 q_18 q_17
+	D_PAL_24POLDB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U7 inv pin24 pin12
+	pin13   regen
+	D0_gate IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U8 inv3 pin24 pin12
+	out22   row1   pin22
+	D_PAL_24POLPB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U9 inv3 pin24 pin12
+	out21   row9   pin21
+	D_PAL_24POLPB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
UA inv3 pin24 pin12
+	out20   regen   pin20
+	D_PAL_24POLRB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
UB inv3 pin24 pin12
+	out19   regen   pin19
+	D_PAL_24POLRB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
UC inv3 pin24 pin12
+	out18   regen   pin18
+	D_PAL_24POLRB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
UD inv3 pin24 pin12
+	out17   regen   pin17
+	D_PAL_24POLRB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
UE inv3 pin24 pin12
+	out16   row49   pin16
+	D_PAL_24POLPB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
UF inv3 pin24 pin12
+	out15   row57   pin15
+	D_PAL_24POLPB IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends
*$
*
.model D_PAL_24POLRB utgate ( ; Gate pin enabled output from reg
+	tplhty=08ns	tplhmx=12ns
+	tphlty=08ns	tphlmx=12ns
+	tplzty=11ns	tplzmx=15ns
+	tphzty=11ns	tphzmx=15ns
+	tpzlty=10ns	tpzlmx=15ns
+	tpzhty=10ns	tpzhmx=15ns
+	)
*$
.model D_PAL_24POLDB ugate ( ; Register to feedback delay
+	tplhty=08ns	tplhmx=12ns
+	tphlty=08ns	tphlmx=12ns
+	)
*$
.model D_PAL_24POL_REGB ueff ( ; Register timing
+	twclkhmn=10ns	twclkhty=05ns
+	twclklmn=10ns	twclklty=05ns
+	tsudclkmn=15ns	tsudclkty=10ns
+	)
*$
.model PAL20RP_XOR upld (
+	offset=2560
+	)
*$
*
*--------------------------------------------------------------------
* Library of optocoupler models

* This is a reduced version of OrCAD's Opto-coupler components library.
*   You are welcome to make as many copies of it as you find convenient.

* The parameters in this model library were derived from the data sheets for
* each part.
*
*.model 4N25
* 6-pin DIP: pin #1   #2   #4   #5   #6
*                |    |    |    |    |
.subckt A4N25  	pin1 pin2 pin4 pin5 pin6	params: rel_CTR=1
*		Motorola	pid=4N25
*		88-01-04 pwt
*		88-01-18 pwt	rework Cje approximation

* The data sheet used for this model is from Motorola: it was the most
* complete for DC and switching parameters, and is was easy to find the
* component IR-LED and phototransistor as separate devices for further
* specifications.

  d_MainLED	pin1 pin2	MainLED
  d_PhotoLED	pin1 1		PhotoLED .001
  v_PhotoLED	1 pin2		0

  f_TempComp	0 2		v_PhotoLED 1.7
  r_TempComp	2 0		TempComp {rel_CTR}

  g_BaseSrc	5 6 2 0		.9
  q_PhotoBJT	5 6 4		PhotoBJT
  r_C		5 pin5		.1
  r_B		6 pin6		.1
  r_E		4 pin4		.1

* Since active devices dominate pin-to-pin capacitance on each "side" of the
* optocoupler, isolation is modeled by identical capacitances and resistances
* linked to a common point; this gives isolation of .5pF and 1E+11 ohms
  c_1		pin1 7		.4p
  r_1		pin1 7		.12T
  c_2		pin2 7		.4p
  r_2		pin2 7		.12T
  c_4		pin4 7		.4p
  r_4		pin4 7		.12T
  c_5		pin5 7		.4p
  r_5		pin5 7		.12T
  c_6		pin6 7		.4p
  r_6		pin6 7		.12T

* Similar to Motorola MLED15.
.model MainLED  D(Is=10.01e-21 Rs=2.049 Ikf=11.84 N=1.053 Xti=3 Cjo=40p M=.34
+                Vj=.75 Isr=30n Nr=3.8 Bv=6 Ibv=100u Tt=.5u)

* Models photon generation: same as MainLED except no AC effects, no breakdown.
.model PhotoLED D(Is=1.1p Rs=.66 Ikf=30m N=1.9 Xti=3 Cjo=0   M=.34 Vj=.75
+		Isr=30n Nr=3.8 Bv=0 Tt=0)

* Temperature compensation for system: 1.38x @ -55'C, .54x @ +100'C, all @ 10mA
* Note: the photo BJT has its own temperature corrections, which must be kept
* as the transistor is electrically available.
.model TempComp	RES(R=1 Tc1=-11.27m Tc2=43.46u)

* Similar to Motorola MDR3050; Hfe=325 @ Ic=500uA, Vce=5V
* Use beta variation (w/Parts) to model change in current-transfer ratio (CTR).
* Hand adjust reverse beta (Br) to match saturation characteristics.
* Set Isc to model dark current.
* Hand adjust Cjc to match fall time @ Ic=10mA (which yields rise time, too).
* Hand adjust reverse transit-time (Tr) to match storage time @ Ic=10mA.
* Delay time set by LED I-V and C-V characteristics; set Cje to 25% of Cjc,
* inspection of phototransistor chip layouts show the emitter area is 20%-25%
* that of the collector area.  The same layouts show that base resistance is
* made negligible by design; also, the operating currents are small.
* Hand adjust forward transit-time (Tf) to match MDR3050 pulse data.  Check
* against 4N25 frequency response (Fig 11, 12).
.model PhotoBJT NPN(Is=10f Xti=3 Vaf=60
+		Bf=400 Ne=3.75 Ise=580p Ikf=.26 Xtb=1.5
+		Br=.04 Nc=2    Isc=3.5n
+		Cjc=10p  Mjc=.3333 Vjc=.75 Tr=88u
+		Cje=2.5p Mje=.3333 Vje=.75 Tf=1.5n)
.ends
*$
*-------------------------------------------------------------------------------
* Library of Thyristor (SCR and Triac) models

* This is a reduced version of OrCAD's Thyristor components library.
* You are welcome to make as many copies of it as you find convenient.

* Library of SCR models

* NOTE:  This library requires the "Analog Behavioral Modeling"
*        option available with PSpice.  A model developed without
*        Behavioral Modeling was found to be very slow and not
*        very robust.

* This macromodel uses a controlled switch as the basic SCR
* structure.  In all cases, the designer should use
* the manufacturer's data book for actual part selection.

* The required parameters were derived from data sheet (Motorola)
* information on each part.  When available, only "typical"
* parameters are used (except for Idrm which is always
* a "max" value).  If a "typical" parameter is not available,
* a "min" or "max" value may be used in which case a comment is
* made in the library.

* The SCRs are modeled at room temperature and do not track
* changes with temperature.  Note that Vdrm is specified by the
* manufacturer as valid over a temperature range.  Also, in
* nearly all cases, dVdt and Toff are specified by the
* manufacturer at approximately 100 degrees C.  This results in a
* model which is somewhat "conservative" for a room temperature
* model.

* The parameter dVdt (when available from the date sheet) is used
* to model the Critical Rate of Rise of Off-State Voltage.  If
* not specified, dVdt is defaulted to 1000 V/microsecond.
* A side effect of this model is that the turn-on current, Ion,
* is determined by Vtm/(Ih*Vdrm).  Vtm is also used as the
* holding voltage.
*
.SUBCKT Scr anode gate cathode PARAMS:
+ Vdrm=400v     Vrrm=400v     Idrm=10u
+ Ih=6ma        dVdt=5e7
+ Igt=5ma       Vgt=0.7v
+ Vtm=1.7v      Itm=24
+ Ton=1u        Toff=15u

* Where:
* Vdrm =>  Forward breakover voltage
* Vrrm =>  Reverse breakdown voltage
* Idrm =>  Peak blocking current
* Ih   =>  Holding current
* dVdt =>  Critical value for dV/dt triggering
* Igt  =>  Gate trigger current
* Vgt  =>  Gate trigger voltage
* Vtm  =>  On-state voltage
* Itm  =>  On-state current
* Ton  =>  Turn-on time
* Toff =>  Turn-off time

* Main conduction path
Scr      anode   anode0  control 0       Vswitch ; controlled switch
Dak1     anode0  anode2  Dakfwd  OFF             ; SCR is initially off
Dka      cathode anode0  Dkarev  OFF
VIak     anode2  cathode                         ; current sensor

* dVdt Turn-on
Emon     dvdt0   0       TABLE {v(anode,cathode)} (0 0) (2000 2000)
CdVdt    dvdt0   dvdt1   100pfd                  ; displacement current
Rdlay    dvdt1   dvdt2   1k
VdVdt    dvdt2   cathode DC 0.0
EdVdt    condvdt 0       TABLE {i(vdVdt)-100p*dVdt}  (0 0 ) (.1m 10)
RdVdt    condvdt 0       1meg

* Gate
Rseries  gate    gate1   {(Vgt-0.65)/Igt}
Rshunt   gate1   gate2   {0.65/Igt}
Dgkf     gate1   gate2   Dgk
VIgf     gate2   cathode                         ; current sensor

* Gate Turn-on
Egate1   gate4   0       TABLE {i(Vigf)-0.95*Igt} (0 0) (1m 10)
Rgate1   gate4   0       1meg
Egon1    congate 0       TABLE {v(gate4)*v(anode,cathode)} (0 0) (10 10)
Rgon1    congate 0       1meg

* Main Turn-on
EItot    Itot    0       TABLE {i(VIak)+5E-5*i(VIgf)/Igt} (0 0) (2000 2000)
RItot    Itot    0       1meg
Eprod    prod    0       TABLE {v(anode,cathode)*v(Itot)} (0 0) (1 1)
Rprod    prod    0       1meg
Elin     conmain 0       TABLE
+        {10*(v(prod) - (Vtm*Ih))/(Vtm*Ih)} (0 0) (2 10)
Rlin     conmain 0       1meg

* Turn-on/Turn-off control
Eonoff   contot  0       TABLE
+        {v(congate)+v(conmain)+v(condvdt)} (0 0) (10 10)

* Turn-on/Turn-off delays
Rton    contot  dlay1   825
Dton    dlay1   control Delay
Rtoff   contot  dlay2   {290*Toff/Ton}
Dtoff   control dlay2   Delay
Cton    control 0       {Ton/454}

* Reverse breakdown
Dbreak  anode   break1  Dbreak
Dbreak2 cathode break1  Dseries

* Controlled switch model
.MODEL Vswitch vswitch
+ (Ron = {(Vtm-0.7)/Itm}, Roff = {Vdrm*Vdrm/(Vtm*Ih)},
+  Von = 5.0,             Voff = 1.5)

* Diodes
.MODEL  Dgk     D       (Is=1E-16 Cjo=50pf Rs=5)
.MODEL  Dseries D       (Is=1E-14)
.MODEL  Delay   D       (Is=1E-12 Cjo=5pf  Rs=0.01)
.MODEL  Dkarev  D       (Is=1E-10 Cjo=5pf  Rs=0.01)
.MODEL  Dakfwd  D       (Is=4E-11 Cjo=5pf)
.MODEL  Dbreak  D       (Ibv=1E-7 Bv={1.1*Vrrm} Cjo=5pf Rs=0.5)

* Allow the gate to float if required
Rfloat  gate    cathode 1e10

.ENDS
*$
.SUBCKT 2N1595          anode gate cathode




* "Typical" parameters
X1 anode gate cathode Scr PARAMS:
+ Vdrm=50v   Vrrm=50v     Ih=5ma       Vtm=1.1v     Itm=1
+ dVdt=1e9   Igt=2ma      Vgt=.7v      Ton=0.8u     Toff=10u
+ Idrm=10u
* 90-5-18    Morotola     DL137, Rev 2, 3/89
.ENDS
*$
* Library of Triac models

* NOTE:  This library requires the "Analog Behavioral Modeling"
*        option available with PSpice.

* This macromodel uses two controlled switches as the basic triac
* structure.  The model was developed to provide firing in all
* four quadrants.  It should be noted, however, that the library
* contains parts which the manufacturer has guaranteed will fire
* in 4 quadrants, 3 quadrants or 2 quadrants.  Therefore, the
* designer should always use the manufacturer's data book for
* part selection.

* The required parameters were derived from data sheet (Motorola)
* information on each part.  When available, only "typical"
* parameters are used (except for Idrm which is always
* a "max" value).  If a "typical" parameter is not available,
* a "min" or "max" value may be used in which case a comment is
* made in the library.

* The triacs are modeled at room temperature and do not track
* changes with temperature.  Note that Vdrm is specified by the
* manufacturer as valid over a temperature range.  Also, in
* nearly all cases, dVdt is specified by the manufacturer at
* approximately 100 degrees C.  This results in a model which
* is somewhat "conservative" for a room temperature model.

* The parameter dVdt (when available from the date sheet) is used
* to model the Critical Rate of Rise of Off-State Voltage.  If
* not specified, dVdt is defaulted to 1000 V/microsecond.  The
* Critical Rate of Rise of Commutation Voltage is not modeled.
* It is generally good practice to use an RC snubber network
* across the triac to limit the commutating dvdt to a value below
* the maximum allowable rating (see manufacturer's data sheet and
* application notes).  Also, note that the turn-off time is
* assumed to be zero.
*
.SUBCKT Triac MT2 gate MT1 PARAMS:
+ Vdrm=400v     Idrm=10u
+ Ih=6ma        dVdt=50e6
+ Igt=20ma      Vgt=0.9v
+ Vtm=1.3v      Itm=17
+ Ton=1.5u

* Where:
* Vdrm =>  Forward breakover voltage
* Idrm =>  Peak blocking current
* Ih   =>  Holding current [MT2(+)]
* dVdt =>  Critical value for dV/dt triggering
* Igt  =>  Gate trigger current [MT2(+),G(-)]
* Vgt  =>  Gate trigger voltage [MT2(+),G(-)]
* Vtm  =>  On-state voltage
* Itm  =>  On-state current
* Ton  =>  Turn-on time

* Main conduction path
Striac   MT2     MT20    cntrol   0       Vswitch ; controlled switch
Dak1     MT20    MT22    Dak      OFF             ; triac is initially off
VIak     MT22    MT1                              ; current sensor
Striacr  MT2     MT23    cntrolr  0       Vswitch ; controlled switch
Dka1     MT21    MT23    Dak      OFF             ; triac is initially off
VIka     MT1     MT21                             ; reverse current sense

* dVdt Turn-on
Emon     dvdt0   0       TABLE {ABS(V(MT2,MT1))} (0 0) (2000 2000)
CdVdt    dvdt0   dvdt1   100pfd                  ; displacement current
Rdlay    dvdt1   dvdt2   1k
VdVdt    dvdt2   MT1     DC 0.0
EdVdt    condvdt 0       TABLE {i(vdVdt)-100p*dVdt}  (0 0 ) (.1m 10)
RdVdt    condvdt 0       1meg

* Gate
Rseries  gate    gate1   {(Vgt-0.65)/Igt}
Rshunt   gate1   gate2   {0.65/Igt}
Dgkf     gate1   gate2   Dgk
Dgkr     gate2   gate1   Dgk
VIgf     gate2   MT1     DC 0.0                  ; current sensor

* Gate Turn-on
Egate    congate 0       TABLE {(ABS(i(VIgf))-0.95*Igt)} (0 0) (1m 10)
Rgate    congate 0       1meg

* Holding current, holding voltage (Quadrant I)
Emain1   main1   0       TABLE {i(VIak)-Ih+5e-3*i(VIgf)/Igt} (0 0) (.1m 1)
Rmain1   main1   0       1meg
Emain2   main2   0       TABLE {v(MT2,MT1)-(Ih*Vtm/Itm)} (0 0) (.1m 1)
Rmain2   main2   0       1meg
Emain3   cnhold  0       TABLE {v(main1,0)*v(main2,0)} (0 0 (1 10)
Rmain3   cnhold  0       1meg

* Holding current, holding voltage (Quadrant III)
Emain1r  main1r   0       TABLE {i(VIka)-Ih-5e-3*i(VIgf)/Igt} (0 0) (.1m 1)
Rmain1r  main1r   0       1meg
Emain2r  main2r   0       TABLE {v(MT1,MT2)-(Ih*Vtm/Itm)} (0 0) (.1m 1)
Rmain2r  main2r   0       1meg
Emain3r  cnholdr  0       TABLE {v(main1r,0)*v(main2r,0)} (0 0 (1 10)
Rmain3r  cnholdr  0       1meg

* Main
Emain4   main4    0       table {(1.0-ABS(i(VIgf))/Igt)} (0 0) (1 1)
Rmain4   main4    0       1meg
Emain5   cnmain   0       table {v(mt2,mt1)-1.05*Vdrm*v(main4)} (0 0) (1 10)
Rmain5   cnmain   0       1meg

Emain5r  cnmainr  0       table {v(mt1,mt2)-1.05*Vdrm*v(main4)} (0 0) (1 10)
Rmain5r  cnmainr  0       1meg

* Turn-on/Turn-off control (Quadrant I )
Eonoff   contot  0       TABLE
+        {v(cnmain)+v(congate)+v(cnhold)+v(condvdt)} (0 0) (10 10)

* Turn-on/Turn-off delays (Quadrant I)
Rton     contot  dlay1   825
Dton     dlay1   cntrol  Delay
Rtoff    contot  dlay2   {2.9E-3/Ton}
Dtoff    cntrol  dlay2   Delay
Cton     cntrol  0       {Ton/454}

* Turn-on/Turn-off control (Quadrant III)
Eonoffr  contotr 0       TABLE
+        {v(cnmainr)+v(congate)+v(cnholdr)+v(condvdt)} (0 0) (10 10)

* Turn-on/Turn-off delays (Quadrant III)
Rtonr    contotr dlayr1   825
Dtonr    dlayr1  cntrolr  Delay
Rtoffr   contotr dlayr2   {2.9E-3/Ton}
Dtoffr   cntrolr dlayr2   Delay
Ctonr    cntrolr 0        {Ton/454}

* Controlled switch model
.MODEL Vswitch vswitch
+ (Ron = {(Vtm-0.7)/Itm}, Roff = {1.75E-3*Vdrm/Idrm},
+  Von = 5.0,             Voff = 1.5)

* Diodes
.MODEL  Dgk     D         (Is=1E-16 Cjo=50pf Rs=5)
.MODEL  Delay   D         (Is=1E-12 Cjo=5pf  Rs=0.01)
.MODEL  Dak     D         (Is=4E-11 Cjo=5pf)

* Allow the gate to float if required
Rfloat  gate    MT1 1e10

.ENDS

*$
.SUBCKT 2N5444          MT2 gate MT1
* Min and Max parameters
X1 MT2 gate MT1 Triac PARAMS:
+ Vdrm=200v  Idrm=10u     Ih=70ma      dVdt=50e6   Ton=1u
+ Igt=70ma   Vgt=2.0v     Vtm=1.65v    Itm=56
* 90-5-18    Morotola     DL137, Rev 2, 3/89
.ENDS

*$
* Mixed a/d model for Cmos version of 555.
*
* Notes from OrCAD: This model is not supported by the Basics+ package.
* The Delay Line model that this model uses is not supported by the Basics+
* package.
*
.subckt 555d 1 2 3 4 5 6 7 8
+ params:maxfreq=3e6
  r1 8     5    13k
  r2 5     botm 13k
  r3 botm  0    13k
  m1 7 qb 0 0 nchan l=2u w=1000u
  otop 6     5  cmp dgtlnet=r io_std
  obot botm  2  cmp dgtlnet=s io_std
  ud1 dlyline 8 1 s sd dlymod io_std
  ud2 dlyline 8 1 r rd dlymod io_std
  u1 srff(1) 8 1 strt 4 hi sd rd 3 qb t_srff io_555
  uhigh stim(1,1) 8 1  hi io_stm 0s 1
  ustrt stim(1,1) 8 1  strt io_stm 0s 0 1ns 1
.model nchan nmos cgbo=1p cgdo=1p cgso=1p
.model dlymod udly(dlymn={.5/maxfreq}
+ dlyty={.5/maxfreq}
+ dlymx={0.5/maxfreq})
.model cmp doutput(
+ s0name=0 s0vlo=-500 s0vhi=0
+ s1name=1 s1vlo=   0 s1vhi=500)
.model io_555 uio (
+	drvh=96.4	drvl=104
+	atod1="atod_555"	atod2="atod_555"
+	atod3="atod_555"	atod4="atod_555"
+	dtoa1="dtoa_555"	dtoa2="dtoa_555"
+	dtoa3="dtoa_555"	dtoa4="dtoa_555")
.model t_srff ugff (tppcqlhty=120ns)
.ends
*|* DIGITAL 555 CONNECTED AS AN ASTABLE
*|.LIB EVAL.LIB
*|.OPTIONS ITL5=0 ITL1=500
*|.PARAM CVAL=20000P
*|VRESET 4 0 PULSE(0 5 1NS .1U .1U 1 2)
*|C2 OUT 0 10P
*|VCC 8 0 5
*|RA 8 7 4700
*|RB 7 6 2200
*|C1 6 0 {CVAL}
*|X1 0 6 OUT 4 5 6 7 8 555D
*|.TRAN 1N 800U
*|.PROBE
*|.END
*$
.subckt atod_555  a d  dpwr dgnd
+	params: capacitance=0
*
  o0  a dgnd do555 dgtlnet=d io_std
  c1  a 0 {capacitance+0.1pf}
.ends
.subckt dtoa_555  d a  dpwr dgnd
+	params: drvl=0 drvh=0 capacitance=0
*
  n1  a dgnd dpwr din555 dgtlnet=d io_std
  c1  a 0 {capacitance+.1pf}
.ends
*$
.model din555 dinput (
+	s0name="0"	s0tsw=0.7ns	s0rlo=100	s0rhi=1meg
+	s1name="1"	s1tsw=0.7ns	s1rlo=1meg	s1rhi=300
+	s2name="x"	s2tsw=0.7ns	s2rlo=200	s2rhi=200
+	s3name="r"	s3tsw=0.7ns	s3rlo=200	s3rhi=200
+	s4name="f"	s4tsw=0.7ns	s4rlo=200	s4rhi=200
+	s5name="z"	s5tsw=0.7ns	s5rlo=200k	s5rhi=200k
+	)
*$
.model DO555 doutput (
+	s0name="X"	s0vlo=0.8	s0vhi=2.0
+	s1name="0"	s1vlo=-1.5	s1vhi=0.8
+	s2name="R"	s2vlo=0.8	s2vhi=1.4
+	s3name="R"	s3vlo=1.3	s3vhi=2.0
+	s4name="X"	s4vlo=0.8	s4vhi=2.0
+	s5name="1"	s5vlo=2.0	s5vhi=50.0
+	s6name="F"	s6vlo=1.3	s6vhi=2.0
+	s7name="F"	s7vlo=0.8	s7vhi=1.4
+	)
*$
* Time Dependent Switch Models
*
* For DC and AC analyses, the switch will be Open.
.SUBCKT  Sw_tClose  1  2  PARAMS:
+ tClose=0     ; time at which switch begins to close
+ ttran=1u     ; time required to switch states (must be realistic, not 0)
+ Rclosed=0.01 ; Closed state resistance
+ Ropen=1Meg   ; Open state resistance (Ropen/Rclosed < 1E10)
V1 3 0 pulse(0 1 {tClose} {ttran} 1 10k 11k)
S1 1 2 3 0 Smod
.model Smod Vswitch(Ron={Rclosed} Roff={Ropen})
.ends

*$
* For DC and AC analyses, the switch will be Closed.
.SUBCKT  Sw_tOpen   1  2  PARAMS:
+ tOpen=0      ; time at which switch begins to close
+ ttran=1u     ; time required to switch states (must be realistic, not 0)
+ Rclosed=0.01 ; Closed state resistance
+ Ropen=1Meg   ; Open state resistance (Ropen/Rclosed < 1E10)
V1 3 0 pulse(1 0 {tOpen} {ttran} 1 10k 11k)
S1 1 2 3 0 Smod
.model Smod Vswitch(Ron={Rclosed} Roff={Ropen})
.ends
* end of time dependent switch models
*$

*
* Coupled and uncoupled models for board parasitic support
*

* Coupled, equal, distributed
.subckt P/T2C in1 in2 out1 out2 params: len=1 r=0 l=1 c=1 g=0 lm=1 cm=1
t1 in1 0 out1 0 len={len} l={l} c={c} r={r} g={g}
t2 in2 0 out2 0 len={len} l={l} c={c} r={r} g={g}
k1 t1 t2 lm={lm} cm={cm}
.ends
*$

* Coupled, equal, lumped T-section
.subckt P/L2C in1 in2 out1 out2 params: len=1 r=0 l=1 c=1 g=0 lm=1 cm=1
r1 in1 1 {len*r}
l1 1 2 {len*l/2}
c1 2 0 {len*(c)}
l2 2 out1 {len*l/2}

r3 in2 3 {len*r}
l3 3 4 {len*l/2}
c2 4 0 {len*(c)}
l4 4 out2 {len*l/2}

k1 l1 l3 {lm/l}
k2 l2 l4 {lm/l}
c3 2 4 {len*cm}
.ends
*$

* Coupled, unequal, distributed (asymmetrical)
.subckt P/T2C_A in1 in2 out1 out2
+ params: len=1 l1=1 c1=1 r1=0 g1=0 l2=1 c2=1 r2=0 g2=0 lm=1 cm=1
t1 in1 0 out1 0 len={len} l={l1} c={c1} r={r1} g={g1}
t2 in2 0 out2 0 len={len} l={l2} c={c2} r={r2} g={g2}
k1 t1 t2 lm={lm} cm={cm}
.ends
*$

* Coupled, unequal, lumped T-section
.subckt P/L2C_A in1 in2 out1 out2
+ params: len=1 l1=1 c1=1 r1=0 g1=0 l2=1 c2=1 r2=0 g2=0 lm=1 cm=1

r1 in1 1 {len*r1}
l1 1 2 {len*l1/2}
c1 2 0 {len*(c1)}
l2 2 out1 {len*l1/2}

r3 in2 3 {len*r2}
l3 3 4 {len*l2/2}
c2 4 0 {len*(c2)}
l4 4 out2 {len*l2/2}

k1 l1 l3 {lm/l1}
k2 l2 l4 {lm/l2}
c3 2 4 {len*cm}
.ends
*$

* Uncoupled (single), distributed
.subckt P/TS in out params: len=1 r=0 l=1 c=1 g=0
t1  in 0 out 0 len={len} l={l} r={r} c={c} g={g}
.ends
*$

* Uncoupled (single), lumped
.subckt P/LS in out params: len=1 r=0 l=1 c=1 g=0
r1  in  1   {len*r}
l1  1   2   {len*l/2}
c1  2   0   {len*c/2}
l2  2  out  {len*l/2}
.ends
*$

*-----------------------------------------------------------------------------
* Lossy transmission line coupling .subckt models
*
* The following set of subcircuits, t2coupled ... t5coupled, can 
* be used to model coupling between lossy transmission lines.
* The coupling is realized using the method descibed in "Efficient Transient
* Simulation of Lossy Interconnect", by J.S. Roychowdhury and D.O. Pederson,
* published in the Proc. DAC 91, and is subject to the following limitations:
*
* 1) all of the line parameters, C, L, R, G, Cm, & Lm, must be the same for
*    all of the lines in the set;
* 2) coupling is modeled across adjacent lines only;
* 3) edge effects are neglected as a result of the first limitation.
*
*
* Subckt t2coupled for 2 coupled transmission lines
*
*                  Line 1 Input
*                   |  Line 2 Input
*                   |   |  Line 1 Output
*                   |   |   |  Line 2 Output
*                   |   |   |   |
.subckt t2coupled   1   2   3   4   params: r=0 l=-1 g=0 c=-1 lm=0 cm=0 len=-1
t1     1   0   3   0   r={r} l={l} g={g} c={c} len={len}
t2     2   0   4   0   r={r} l={l} g={g} c={c} len={len}
k12   t1  t2  lm={lm} cm={cm}
.ends t2coupled
*$

* Subckt t3coupled for 3 coupled transmission lines
*
*                  Line 1 Input
*                   |  Line 2 Input
*                   |   |  Line 3 Input
*                   |   |   |  Line 1 Output
*                   |   |   |   |  Line 2 Output
*                   |   |   |   |   |  Line 3 Output
*                   |   |   |   |   |   |
.subckt t3coupled   1   2   3   4   5   6   params: r=0 l=-1 g=0 c=-1 lm=0 cm=0 len=-1
t1     1   0   4   0   r={r} l={l} g={g} c={c} len={len}
t2     2   0   5   0   r={r} l={l} g={g} c={c} len={len}
t3     3   0   6   0   r={r} l={l} g={g} c={c} len={len}
k12   t1  t2  lm={lm} cm={cm}
k23   t2  t3  lm={lm} cm={cm}
.ends t3coupled
*$

*-------------------------------------------------------------------------------
* Library of PCI82430 I/O Buffer Model

* This is a reduced version of OrCAD's IBIS components library.
* You are welcome to make as many copies of it as you find convenient.
*                                         
*  Component:           S82374EB ESC
*  Signals:             BALE,BE#[3:0],CHRDY,CMD#,EOP,EX16#,EX32#,EXRDY,IORC#,
*                       IOWC#,LA[31:2],M16#,MRDC#,MSBURST#,MWTC#,M/IO,NOWS#,
*                       REFRESH#,RSTDDRV,SA0,SA1,SBHE#,SD[7:0],SMRDC#,SMWTCH#,
*                       SPKR,START#,W/R# (Note:  EXRDY,EX16#,CHRDY,EX32#,
*                       M16#, and NOWS# are open drain signals, and can only
*                       be driven low.)
*
*  Buffer Type          O  
*  ESC2 Revision:       1.0
*
*  Model type:          best case:  min ramp time, min package parasitics, 
*                       min die capacitance, max output current
*
*
*
*                 	Input	Output	VCC	GND	Enable
.subckt ESC2_B 	        100  	200 	300 	400 	500
+ PARAMS:
+ R_pkg = 226m          ; package bond wire and lead resistance at output
+ L_pkg = 8.5n          ; package bond wire and lead inductance at output
+ C_pkg = 1.9p          ; package bond wire and lead capacitance at output
+ C_comp = 2p           ; die capacitance at output
+ dVdt_r = {5.25/0.45}  ; output rise time in V/ns
+ dVdt_f = {5.25/0.44}  ; output fall time in V/ns
*
*
******* Parameters *******
.PARAM Rtr = { (1/dVdt_r) * 1e5}
.PARAM Rtf = { (1/dVdt_f) * 1e5 }
.PARAM Vinh = 1.56v             ; Input high threshold voltage
.PARAM Vinl = 1.47v		; Input low threshold voltage
*
******* Input and Enable Threshld **********************
Ein_thr_dn 800 0 VALUE = {TABLE(V(100,400),
+ Vinl, 0,
+ Vinl+1e-6, 1)}
*
Ein_thr_up 810 0 VALUE = {TABLE (V(100,400),
+ Vinh-1e-6, 1,
+ Vinh, 0)}
*
Ein_thr 530 0 VALUE = {TABLE (V(500,400),
+ Vinl, 0,
+ Vinh, 1)}
*
Edn 820 0 VALUE = {LIMIT(V(800,0), 0, V(530,0))}
Eup 830 0 VALUE = {LIMIT(V(810,0), 0, V(530,0))}
Rdum1 530 0 10meg
Rdum2 800 0 10meg
Rdum3 810 0 10meg
Rdum4 820 0 10meg
Rdum5 830 0 10meg
*
******** Rise & Fall Time *******
Gramp_dn 840 400a VALUE={v(840,400a) / (abs(v(840,400) * Rtf
+ + V(820,400) * 1e9) + 1e-4) }
rgramp_dn 400a 400 0.1
Cramp_dn 840 400 0.01p
*
GRchrg_dn 840 220 VALUE={v(840,220)/(abs(v(830,0) * 1e+7)+1e-4)}
cchrg_dn 840 220 1f
rchrg_dn 840 220 10meg
*
Gramp_up 300a 850 VALUE = {v(300a,850) / (abs(v(300,850) * Rtr +
+ V(830,400) * 1e9) + 1e-4)}
Vramp_up 300a 300 10u
Cramp_up 850 300 0.01pf
*
ERchrg_up 850 220b VALUE = {I(Vchrg_up) * (abs(v(820,0) * 1e9) + 1e-4)}
Vchrg_up 220b 220 0
cchrg_up 850 220 5f
*
******* Output Pulldown *******
Esw_dn 240 0 VALUE = { TABLE(v(840),
+ 4.5-1e-5, 1,
+ 4.5, 0) }
*
Rout_dn 220 400 1
Gadj_dn 220 400 VALUE = {V(280,220)}
Elim_dn 280 400 VALUE = {LIMIT(v(260,0), -v(240,0)*1e3, v(240,0)*1e3)}
Epwl_dn 260 0 TABLE {v(220,840)}
+ -5.0v, -216m
+ -4.0v, -212m
+ -3.0v, -207m
+ -2.0v, -189m
+ -1.0v, -126m
+ 0.0v, 0m
+ 0.5v, 71m
+ 1.0v, 126m
+ 1.5v, 163m
+ 2.0v, 189m
+ 2.5v, 202m
+ 3.0v, 207m
+ 3.5v, 210m
+ 4.0v, 212m
+ 4.5v, 214m
+ 5.0v, 216m
+ 10.0v, 230m
Rdum6 240 0 10meg
Rdum7 260 0 10meg
Rdum8 280 400 10meg
*
******* Output clamp to GND *******
Ggnd_out 220 400 TABLE {v(220,400)}
+ -5.0v, -1725m
+ -1.0v, -110m
+ -0.9v, -70m
+ -0.8v, -35m
+ -0.7v, -5m
+ -0.6v, 0m
+ -0.5v, 0m
+ -0.4v, 0m
+ 0.0v, 0m
*
******* Output pullup *******
Esw_up 230 0 VALUE = {TABLE(v(850),
+ 0.5, 0,
+ 0.5+1e-5, 1 )}
*
Rout_up 300 220 1
Gadj_up 300 220 VALUE={v(220,270)}
Elim_up 300 270 VALUE={LIMIT(v(0,250), -v(230)*1e3, v(230)*1e3)}
Epwl_up 250 0 TABLE={v(850,220)}
+ -5.0v, 135m
+ -4.0v, 127m
+ -3.0v, 113m
+ -2.0v, 91m
+ -1.0v, 53m
+ 0.0v, 0m
+ 0.5v, -28m
+ 1.0v, -53m
+ 1.5v, -75m
+ 2.0v, -91m
+ 2.5v, -105m
+ 3.0v, -113m
+ 3.5v, -121m
+ 4.0v, -127m
+ 4.5v, -131m
+ 5.0v, -135m
+ 10.0v, -155m
Rdum9 230 0 10meg
Rdum10 250 0 10meg
Rdum11 270 300 10meg
*
******* Output clamp to VCC ********
GVcc_out 220 300 TABLE {V(300,220)}
+ -5.0v, 970m
+ -1.0v, 74m
+ -0.9v, 52m
+ -0.8v, 30m
+ -0.7v, 4m
+ -0.6v, 0m
+ -0.5v, 0m
+ -0.4v, 0m
+ 0.0v, 0m
*
******* Output Package *******
Cout_pkg 200 400 {C_pkg}
Rout_pkg 200 210 {R_pkg}
Lout_pkg 210 220 {L_pkg}
Rout_snb 210 220 100
Cout_die 220 400 {C_comp}
******* End of Subcircuit *******
.ENDS
*$
*
.SUBCKT CD4016B 1 2 3 4 5
* Specifications from SGS and Harris data books
* 1 ANALOG INPUT
* 2 ANALOG OUTPUT
* 3 CONTROL
* 4 VDD (POSITIVE SUPPLY)
* 5 VSS (NEGATIVE SUPPLY)
*
RINP  3 11 1500
D1 11 4 D1
D2 5 11 D1
*
M1 12 11 4 4 MP4016A L=8U W=48U  AD=500P AS=500P PD=110U PS=110U
M2 12 11 5 5 MN4016A L=8U W=16U  AD=160P AS=160P PD=48U PS=48U
*
M1A 13 12 4 4 MP4016A L=8U W=96U  AD=500P AS=500P PD=110U PS=110U
M2A 13 12 5 5 MN4016A L=8U W=32U  AD=160P AS=160P PD=48U PS=48U
*
M3 1 12 2 4  MP4016A L=8U W=360U AD=3600P AS=3600P PD=900U PS=900U
M4 2 13 1 5  MN4016A L=8U W=120U AD=1080P AS=1080P PD=286U PS=286U
*
.MODEL MN4016A NMOS LEVEL=2 VTO=1.45 TOX=1000E-10 NSUB=4.7E16
+XJ=3U LD=2U UO=625 UCRIT=1E5 UEXP=0.45 UTRA=0.25 RSH=15 
+NEFF=2.5 VMAX=1E6 CGBO=3E-10 CGDO=10E-10 CGSO=10E-10 CJSW=2F
+NFS=4E12  GAMMA=2.2 LAMBDA=0.02
*
.MODEL MP4016A PMOS LEVEL=2 VTO=-1.5 TOX=1000E-10 NSUB=7.6E15
+XJ=3U LD=1.5U UO=225 UCRIT=3E5 UEXP=.5 UTRA=0.25 RSH=15
+NEFF=2.5 VMAX=1E5 CGBO=3E-10 CGDO=10E-10 CGSO=10E-10 CJSW=1F
+NFS=1E12  GAMMA=1.8 LAMBDA=0.02
* 
.MODEL D1 D IS=923.17E-18 RS=10 CJO=1.0000E-12 M=.3333  VJ=.75
+ ISR=100.00E-12  BV=35.357  IBV=10U  TT=5.0000E-9
.ENDS
*$
*
* End of library file
